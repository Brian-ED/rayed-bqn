#!/usr/bin/env BQN
# SPDX-License-Identifier: AGPL-3.0-or-later
# SPDX-FileCopyrightText: 2023 Rampoina <rampoina@protonmail.com>

âŸ¨FindIdx,SplitOnEmptyâŸ©â†â€¢Import "utils.bqn"

Gameâ‡{ # The Game function creates a game object
  ğ•Š nâ€¿levelPathâ€¿dcharsâ€¿charsâ€¿colors: # from parameters:
  # n: starting level
  # levelPath: the path of the file containing the levels
  # dchars: the characters to use for drawing
  # chars: the characters that are used in the level representation
  # colors: a list with colors

  # Game representation:
  # -------------------------------------------------------------------------------
  # The game has the following objects represented as consecutive integers:
  âŸ¨floor,player,box,machine,pmachine,wall,lmirror,rmirror,hbeam,vbeam,xbeam,llaser,rlaser,ulaser,dlaserâŸ©â‡â†•â‰ chars

  mirrorsâ‡lmirrorâ€¿rmirror # the mirrors to reflect
  beamsâ†hbeamâ€¿vbeamâ€¿xbeam # the laser beams
  lasersâ†llaserâ€¿rlaserâ€¿ulaserâ€¿dlaser # shot by the laser
  # Each with every possible orientation

  # There are *movable* objects like the following:
  movablesâ†playerâ€¿boxâˆ¾mirrors # player, box and mirrors

  # And *opaque* objects which don't reflect lasers:
  opaqueâ†playerâ€¿boxâ€¿machineâ€¿wallâˆ¾lasers

  # *Empty* objects can contain other ones on top:
  emptiesâ†floorâˆ¾beams
  
  # We use a list of game objects (ints) to represent each tile
  lTilesâ†{âŠ‘ğ•©âˆŠmovables ? 
           ğ•©â€¿floor; # the movables are on top of the floor (list of 2 elements)
           â‰ğ•© # And the rest are a list of just that element
         }Â¨â†•â‰ chars 

  # We transform each character into its tile representation and we transform
  # it into a 2d matrix
  # the matrix is padded to ensure that that we can always get 3 tiles
  # centered on the player and pointing to the current direction
  Ascii2Matrixâ†{(âŠ‘charsâŠğ•©)âŠ‘lTiles}Â¨(âŠ¢â†‘ËÂ·â‰âŸœÂ¬2+â‰¢) # ğ•© : Matrix of characters

  # Rules:
  # -------------------------------------------------------------------------------
  #
  # --- Rule 1: -------------------------------------------------------------------
  # - The player can push but not pull any movable object one tile away in the
  #   current direction to an empty tile:

  # ğ•©: âŸ¨âŸ¨1,0âŸ©,âŸ¨0âŸ©âŸ© (2 tiles) | result: âŸ¨âŸ¨0âŸ©,âŸ¨1,0âŸ©âŸ©
  # (Try to) Move the first object in the first tile to the second tile.
  # Only move *movable* tile â†’ *empty* tile
  # the second tile can't be a movable object because we moved it previously
  # if it is it means that the object was unmovable (next to a wall) so we do nothing
  Moveâ†{aâ€¿b:âŸ¨1â†“a,(âŠ‘a)âˆ¾bâŸ©}âŸ{âˆ¨Â´(â¥Šmovablesâ‰âŒœempties)â‰¡âŒœ<âŠ‘Â¨ğ•©}
  
  # ğ•©: âŸ¨âŸ¨1,0âŸ©,âŸ¨2,0âŸ©,âŸ¨0,0)âŸ© (3 tiles) | result: âŸ¨âŸ¨0âŸ©,âŸ¨1,0âŸ©,âŸ¨2,0)âŸ©
  # Given 3 tiles try to Push the second tile (possibly a movable object)
  # and afterwards try to move the first one (the player) if possible
  Pushâ†MoveâŒ¾(2â†‘âŠ¢)MoveâŒ¾(1â†“âŠ¢)

  # ğ•©: object coordinate (3â€¿1) |  ğ•¨: direction vector (Â¯1â€¿0)
  # result: âŸ¨ âŸ¨ 3 1 âŸ© âŸ¨ 2 1 âŸ© âŸ¨ 1 1 âŸ© âŸ©
  # returns 3 tiles in the specified direction from the
  Tilesâ†{âŸ¨ğ•©,ğ•©+ğ•¨,ğ•©+2Ã—ğ•¨âŸ©} # given object (including itself)

  # We (try to) push the tile in front of the player
  Stepâ†{PushâŒ¾((ğ•¨ Tiles âŠ‘player FindIdx âŠ‘Â¨ğ•©)âŠ¸âŠ‘)ğ•©} # ğ•¨ S ğ•© | ğ•¨: direction | ğ•©:level | Step the game

  # - The lasers shoot lasers beams that get intercepted by opaque objects and
  #   bounce on mirrors:

  # wâ€¿d Bounce x | x: map | wâ€¿d: w: current position, d: direction of the laser
  # Calculates the bounces of a laser beam recursively
  Bounceâ†{(wâ€¿d)S x:{ # Base case:
    âŠ‘opaqueâˆŠËœâŠ‘wâŠ‘x? # When the beam touches an opaque object (not a mirror):

      (machine=âŠ‘wâŠ‘x)â—¶âŸ¨ # if it's not a machine:
          x,           # we do nothing
         âŸ¨pmachineâŸ©Ë™âŒ¾(wâŠ¸âŠ‘)x # and if it is, we change it to a powered machine
         âŸ©@; # and the recursion stops

      âŠ‘emptiesâˆŠËœâŠ‘wâŠ‘x ? # When the beam passes through an empty space:

        # we draw the laser beam and recurse to the next:
        âŸ¨w+d,dâŸ©S{ # we choose the type of laser beam to draw
          cTileâ†(floorâ€¿hbeamâ€¿vbeamâ€¿xbeamâŠğ•©) # depending on the current tile:
          #                            floor hbeam vbeam xbeam  |  floor hbeam vbeam xbeam  
          cBeamâ†    ((Ã—âŠ‘d)    âŠ‘       âŸ¨hbeamâ€¿hbeamâ€¿xbeamâ€¿xbeam  ,  vbeamâ€¿xbeamâ€¿vbeamâ€¿xbeamâŸ©)
          # and  beam direction        Horizontal               |  Vertical
          cTileâŠcBeam
        }âŒ¾(wâŠ¸âŠ‘)x;

        # When the beam touches a mirror:
        dâ†âŒ½dÃ—-âŠ¸Â¬lmirror=âŠ‘wâŠ‘x # calculate the mirror bounce direction
        âŸ¨w+d,dâŸ©S x           # and recurse to the next position
      } 
  }
  
  # We find each laser machine and shoot a beam in its direction
  # Shoot ğ•© | ğ•©: map | calculates the bounces for each laser
  Shootâ†{ğ•© {ğ•¨BounceÂ´âŒ½ğ•©} âˆ¾âŸ¨<0â€¿Â¯1,<0â€¿1,<Â¯1â€¿0,<1â€¿0âŸ©(âŠ£â‹ˆËœÂ¨+)Â¨ FindIdxâŸœ(âŠ‘Â¨ğ•©)Â¨ lasers}

  # --- Rule 2: -------------------------------------------------------------------
  # - The Player wins when all machines are powered:
  Winâ†{Â¬âˆ¨Â´âˆ¨Ëmachine=âŠ‘Â¨Shoot ğ•©}# ğ•©: level | Win condition, no unpowered machines after shooting laser


  # Drawing:
  # -------------------------------------------------------------------------------

  # Colors:
  # The parameter 'color' is a list of colors passed to the Game function to alter the
  colsâ†(â‰ chars)â¥Š<(âŠ‘colors)       # base color,
  cols (1âŠ‘colors)Ë™âŒ¾(pmachineâŠ¸âŠ‘)â†© # the color for the powered machine
  cols (2âŠ‘colors)Â¨âŒ¾(mirrorsâŠ¸âŠ)â†©  # the color for the mirrors
  cols (3âŠ‘colors)Â¨âŒ¾(beamsâŠ¸âŠ)â†©    # the color for the laser beams

  Colorâ‡{(ğ•©âŠ‘cols)âˆ¾ğ•©âŠ‘dchars}  # ğ•©: game Object (int) | draw object with color
  DrawLevelâ†{âˆ¾Â´Â¨<Ë˜ColorÂ¨+Â´Â¨Shoot ğ•¨ StepÂ´ âŒ½ğ•©} # ğ•¨ Draw ğ•© | ğ•¨: levels | ğ•©: moves | Draw the game in ASCII

  # State and state mutating functions:
  # -------------------------------------------------------------------------------

  movesâ‡âŸ¨0â€¿0âŸ© # list of moves, each move is a direction, we start without moving
  currentLevelâ‡n-1
  "Invalid number of fchars" ! 15=â‰ chars
  "Invalid number of chars"  ! 15=â‰ dchars
  "The level file contains illegal characters" ! âˆ§Â´charsâˆŠËœâˆ¾Â´â€¢Flines levelPath
  levelsâ†Ascii2MatrixÂ¨>Â¨SplitOnEmptyâ€¢FLines levelPath # Load file containing levels
  "Some levels don't contain any player" ! Â¬âˆ¨Â´0=â‰ Â¨{player FindIdx âŠ‘Â¨ğ•©}Â¨levels
  "Some levels don't contain any machine" ! Â¬âˆ¨Â´0=â‰ Â¨{machine FindIdx âŠ‘Â¨ğ•©}Â¨levels
  "The starting level is higher than the number of levels" !  currentLevel<â‰ levels
  Nextâ‡{movesâ†©movesâˆ¾<ğ•©}
  Undoâ‡{ğ•Š:movesâ†©(-1<â‰ )âŠ¸â†“moves}
  Drawâ‡{ğ•Š:â€¢OutÂ¨ (currentLevelâŠ‘levels) DrawLevel moves}
  WinLevelâ‡{ğ•Š:Win(currentLevelâŠ‘levels)StepÂ´âŒ½moves}
  Resetâ‡{ğ•Š:movesâ†©âŸ¨0â€¿0âŸ©}
  NextLevelâ‡{ğ•Š:currentLevelâ†©currentLevel+1â‹„Reset @}
  Overâ‡{ğ•Š:currentLevel<â‰ levels} # has the user beaten all of the levels?
}
