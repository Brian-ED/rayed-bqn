âŸ¨câ‡color,window,draw,kâ‡keyâŸ©â†râ†â€¢Import "../../raylib.bqn"
âŸ¨DrawBoardâ‡DrawâŸ©â†â€¢Import"spritesLoad.bqn"

gâ†{
  chars  â† " @oâ­#/\-|+<>^v" # the characters that are used in the level representation
  âŸ¨empty,player,machine,pmachine,wall
  lmirror,rmirror,hbeam,vbeam,xbeam,llaser
  rlaser,ulaser,dlaserâŸ©â‡â†•â‰ chars

  mirrorsâ‡lmirrorâ€¿rmirror
  beamsâ†hbeamâ€¿vbeamâ€¿xbeam
  lasersâ†llaserâ€¿rlaserâ€¿ulaserâ€¿dlaser
  movablesâ†playerâˆ¾mirrors
  opaqueâ†playerâ€¿machineâ€¿wallâˆ¾lasers

  Moveâ†{aâ€¿b:âŸ¨1â†“a,aâŠ‘âŠ¸âˆ¾bâŸ©}âŸ{âˆ¨Â´(â¥Šmovablesâ‰âŒœbeams)â‰¡Â¨<âŠ‘Â¨ğ•©}
  # ğ•©: âŸ¨âŸ¨1,0âŸ©,âŸ¨2,0âŸ©,âŸ¨0,0)âŸ© (3 tiles) | result: âŸ¨âŸ¨0âŸ©,âŸ¨1,0âŸ©,âŸ¨2,0)âŸ©
  # Given 3 tiles try to Push the second tile (possibly a movable object)
  # and afterwards try to move the first one (the player) if possible
  Pushâ†MoveâŒ¾(2â†‘âŠ¢)MoveâŒ¾(1â†“âŠ¢)
  
  Tilesâ†{(ğ•©+ğ•¨Ã—âŠ¢)Â¨â†•3} # given object (including itself)
  # We (try to) push the tile in front of the player
  Stepâ‡{PushâŒ¾((ğ•¨ Tiles âŠ‘player /â—‹â¥ŠâŸœ(â†•â‰¢)âˆ˜â· âŠ‘Â¨ğ•©)âŠ¸âŠ‘)ğ•©} # ğ•¨ S ğ•© | ğ•¨: direction | ğ•©:level | Step the game

  Bounceâ†{dâ€¿w S x:{ # Base case:
    âŠ‘opaqueâˆŠËœwâŠ‘x? # When the beam touches an opaque object (not a mirror):

      (machine=wâŠ‘x)â—¶âŸ¨x,pmachineâŒ¾(wâŠ¸âŠ‘)xâŸ©@;
      âŠ‘(lasersâˆ¾empty)âˆŠËœwâŠ‘x ?
        âŸ¨d,w+dâŸ©S{
          cTileâ†emptyâ€¿hbeamâ€¿vbeamâ€¿xbeamâŠğ•©
          cBeamâ†(Ã—âŠ‘d)âŠ‘âŸ¨hbeamâ€¿hbeamâ€¿xbeamâ€¿xbeam,vbeamâ€¿xbeamâ€¿vbeamâ€¿xbeamâŸ©
          âŠ‘cTileâŠcBeam
        }âŒ¾(wâŠ¸âŠ‘)x;
        dâ†âŒ½dÃ—-âŠ¸Â¬lmirror=wâŠ‘x # calculate the mirror bounce direction
        âŸ¨d,w+dâŸ©S x           # and recurse to the next position
      }
  }
  Shootâ‡{ğ•©BounceÂ´âŒ½âˆ¾âŸ¨0â€¿Â¯1,0â€¿1,Â¯1â€¿0,1â€¿0âŸ©(<âˆ˜âŠ£â‹ˆÂ¨<âŠ¸+)Â¨/â—‹â¥ŠâŸœ(â†•â‰¢)Â¨ğ•©âŠ¸=Â¨lasers}
  colors â† c.blueâ€¿c.yellowâ€¿c.cyanâ€¿c.red
  cols   â† colorsâŠËœâŒˆÂ´(â‰ chars)â†‘Â¨(â†•3)Ã—/â¼Â¨âŸ¨pmachineâŸ©â€¿mirrorsâ€¿beams    

  Ascii2Levelâ†{(â†•â‰ chars)âŠ‘ËœâŠ‘charsâŠğ•©}Â¨
  levelsâ‡Ascii2Levelâˆ˜>Â¨((âŠ¢-Ëœ+`Ã—Â¬)0=â‰ Â¨)âŠ¸âŠ”â€¢FLines "levels.txt"
}
onStart â† {
  gameState â† 1
  moves â† âŸ¨0â€¿0âŸ© # list of moves, each move is a direction, we start without moving
  currentLevelâ†0
  âŸ¨gameState, moves, currentLevelâŸ©
}
PerFrame â† {ğ•ŠâŸ¨gameState, moves, currentLevelâŸ©:
  keyâ†k.GetPressed @
  30â€¿30 c.white draw._Text_ 40Ëœ"Level "âˆ¾â€¢Repr 1+currentLevel
  gameStateâ—¶âŸ¨
    {ğ•¤ # Playing
      # Draw not implemented. map each int as sprite
      10 DrawBoard levelâ†g.Shoot(currentLevelâŠ‘g.levels) g.StepÂ´âŒ½moves
      won â† Â¬âŠ‘g.machineâˆŠâ¥Šlevel
        # has the user beaten all of the levels?
      âŸ¨
        1âŒ¾âŠ‘âŸwon gameState
        âŸ¨0â€¿0âŸ©âŸ('r'=key)(-1<â‰ )âŠ¸â†“âŸ('u'=key) movesâˆ¾âŸ¨0â€¿Â¯1,1â€¿0,Â¯1â€¿0,0â€¿1âŸ©/Ëœâˆ¨Ë["hjkl","aswd"]=key
        1+âŸwon currentLevel
      âŸ©
    }
    {ğ•¤ # info screen
      {currentLevel=0?
        1â†“âˆ¾(@+10)âˆ¾Â¨âŸ¨
        "Power the machines by moving the mirrors"
        "Controls: (hjkl or wasd) to move, u to undo, r to reset level, q to quit"
        âŸ©;
        "Good job! took only "âˆ¾(moves)âˆ¾" moves. press any key to continue to the next level!"
      }c.white draw._Text_ 30 300â€¿300
      âŸ¨0,âŸ¨0â€¿0âŸ©,1âŠ¸+âŸ©{ğ•ğ•©}Â¨âŸ(0â‰¢key) ğ•©
    }
  âŸ©ğ•©
}draw._withCanvas_ c.black
# On end, show "Well played, you win!"

Game â† PerFrameâ€¢_While_ {(window.ShouldClose@)Â¬âŠ¸âˆ§(2âŠ‘ğ•©)<â‰ g.levels}OnStart
Game window._openAs "Arc"