‚ü®
  GetCameraForward
  GetCameraUp
  GetCameraRight

  # Camera movement
  CameraMoveForward
  CameraMoveUp
  CameraMoveRight
  CameraMoveToTarget

  # Camera rotation
  CameraYaw
  CameraPitch
  CameraRoll

  GetCameraViewMatrix
  GetCameraProjectionMatrix

  UpdateCamera
‚ü©‚áê

#   rcamera - Basic camera system with support for multiple camera modes
#
#   CONFIGURATION:
#       #define RCAMERA_IMPLEMENTATION
#           Generates the implementation of the library into the included file.
#           If not defined, the library is in header only mode and can be included in other headers
#           or source files without problems. But only ONE file should hold the implementation.
#
#       #define RCAMERA_STANDALONE
#           If defined, the library can be used as standalone as a camera system but some
#           functions must be redefined to manage inputs accordingly.
#
#
# Function specifiers definition

‚ü®rf‚áêrayffi, key, mouse
  ‚ü®
    GetMouseDelta
    GetFrameTime
    cameraProjection
    cameraMode
  ‚ü© ‚áê rayffi

  ‚ü®
    Vector3RotateByAxisAngle
    VectorAngle
    MatrixLookAt
    MatrixPerspective
    MatrixOrtho
    deg2rad
    MP
    MatrixRotate
  ‚ü© ‚áê raymath

‚ü© ‚Üê rl ‚Üê ‚Ä¢Import "../../raylib.bqn"

cameraIndex ‚áê {
  position   ‚áê 0 # Camera position
  target     ‚áê 1 # Camera target it looks-at
  up         ‚áê 2 # Camera up vector (rotation over its axis)
  fovy       ‚áê 3 # Camera field-of-view aperture in Y (degrees) in perspective, used as near plane width in orthographic
  projection ‚áê 4 # Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
}

camera_first_person_step_trigonometric_divider ‚Üê 8
camera_first_person_step_divider ‚Üê 30
camera_first_person_waving_divider ‚Üê 200

# PLAYER (used by camera)
player_movement_sensitivity ‚Üê 20

#----------------------------------------------------------------------------------
# Module Functions Definition
#----------------------------------------------------------------------------------
# Returns the cameras forward vector (normalized)
GetCameraForward ‚Üê {ùïäcamera:
  √∑‚üú(0‚ä∏=‚ä∏++¬¥‚åæ(√óÀú))-¬¥cameraIndex.target‚ÄøcameraIndex.position‚äècamera
}

# Returns the cameras up vector (normalized)
# Note: The up vector might not be perpendicular to the forward vector
GetCameraUp ‚Üê {ùïäcamera:
  √∑‚üú(0‚ä∏=‚ä∏++¬¥‚åæ(√óÀú)) cameraIndex.up‚äëcamera
}

# Returns the cameras right vector (normalized)
GetCameraRight ‚Üê {ùïäcamera:
  (GetCameraForward camera) 1‚ä∏‚åΩ‚ä∏√ó{1‚åΩùîΩÀú-ùîΩ} GetCameraUp camera
}

# Moves the camera in its forward direction
CameraMoveForward ‚Üê {ùïäcamera‚Äødistance‚ÄømoveInWorldPlane:

  forward ‚Üê {
    # Project vector onto world plane
    √∑‚üú(0‚ä∏=‚ä∏++¬¥‚åæ(√óÀú)) 0‚åæ(1‚ä∏‚äë) ùï©
  }‚çümoveInWorldPlane GetCameraForward camera

  # Move position and target
  (forward√ódistance)‚ä∏+¬®‚åæ(cameraIndex.position‚ÄøcameraIndex.target‚ä∏‚äè) camera
}

# Moves the camera in its up direction
CameraMoveUp ‚Üê {ùïäcamera‚Äødistance:
  (distance√óGetCameraUp camera)‚ä∏+¬®‚åæ(cameraIndex.position‚ÄøcameraIndex.target‚ä∏‚äè)camera
}

# Moves the camera target in its current right direction
CameraMoveRight ‚Üê {ùïäcamera‚Äødistance‚ÄømoveInWorldPlane:
  right ‚Üê {
    # Project vector onto world plane
    √∑‚üú(0‚ä∏=‚ä∏++¬¥‚åæ(√óÀú)) 0‚åæ(1‚ä∏‚äë) ùï©
  }‚çümoveInWorldPlane GetCameraRight camera

  # Scale by distance
  (right√ódistance)‚ä∏+¬®‚åæ(cameraIndex.position‚ÄøcameraIndex.target‚ä∏‚äè)camera
}

# Moves the camera position closer/farther to/from the camera target
CameraMoveToTarget ‚Üê {deltaùïäcamera:
  distance ‚Üê delta++¬¥‚åæ(√óÀú)-¬¥cameraIndex.position‚ÄøcameraIndex.target‚äècamera

  # Set new distance by moving the position along the forward vector
  forward ‚Üê distance√óGetCameraForward camera
  (forward -Àú cameraIndex.target‚äëcamera)‚åæ(cameraIndex.position‚ä∏‚äë)camera
}

# Rotates the camera around its up vector
# Yaw is "looking left and right"
# If rotateAroundTarget is false, the camera rotates around its position
# Note: angle must be provided in radians
CameraYaw ‚Üê {ùïäcamera‚Äøangle‚ÄørotateAroundTarget:
  up ‚Üê GetCameraUp camera # Rotation axis

  # View vector
  targetPosition ‚Üê -¬¥cameraIndex.target‚ÄøcameraIndex.position‚äècamera

  # Rotate view vector around up axis
  targetPosition ‚Ü© Vector3RotateByAxisAngle targetPosition‚Äøup‚Äøangle

  {rotateAroundTarget?
    # Move position relative to target
    (targetPosition -Àú cameraIndex.target‚äëcamera)‚åæ(cameraIndex.position‚ä∏‚äë)camera
  ;
    # rotate around camera.position
    # Move target relative to position
    (targetPosition + cameraIndex.position‚äëcamera)‚åæ(cameraIndex.target‚ä∏‚äë)camera
  } 
}

# Rotates the camera around its right vector, pitch is "looking up and down"
#  - lockView prevents camera overrotation (aka "somersaults")
#  - rotateAroundTarget defines if rotation is around target or around its position
#  - rotateUp rotates the up direction as well (typically only usefull in CAMERA_FREE)
# NOTE: angle must be provided in radians
CameraPitch ‚Üê {ùïäcamera‚Äøangle‚ÄølockView‚ÄørotateAroundTarget‚ÄørotateUp:
  # Up direction
  up ‚Üê GetCameraUp camera

  # View vector
  targetPosition ‚Üê -¬¥cameraIndex.target‚ÄøcameraIndex.position‚äècamera

  angle {
    # In these camera modes we clamp the Pitch angle
    # to allow only viewing straight up or down.

    # Clamp view up
    ùï© ‚åä‚Ü© ¬Ø0.001+up VectorAngle targetPosition

    # Clamp view down
    ùï© ‚åà 0.001-(-up) VectorAngle targetPosition
  }‚çülockView ‚Ü©

  # Rotation axis
  right ‚Üê GetCameraRight camera

  # Rotate view vector around right axis
  targetPosition ‚Ü© Vector3RotateByAxisAngle targetPosition‚Äøright‚Äøangle

  camera {rotateAroundTarget?
    # Move position relative to target
    (targetPosition -Àú cameraIndex.target‚äëùï©)‚åæ(cameraIndex.position‚ä∏‚äë) ùï©
  ;
    # rotate around camera.position
    # Move target relative to position
    (targetPosition + cameraIndex.position‚äëùï©)‚åæ(cameraIndex.target‚ä∏‚äë) ùï©
  } ‚Ü©

  {
    # Rotate up direction around right axis
    Vector3RotateByAxisAngle ùï©‚Äøright‚Äøangle
  }‚åæ(cameraIndex.up‚ä∏‚äë)‚çürotateUp camera
}

# Rotates the camera around its forward vector
# Roll is "turning your head sideways to the left or right"
# Note: angle must be provided in radians
CameraRoll ‚Üê {angleùïäcamera:
  # Rotation axis
  forward ‚Üê GetCameraForward camera

  # Rotate up direction around forward axis
  {Vector3RotateByAxisAngle ùï©‚Äøforward‚Äøangle}‚åæ(cameraIndex.up‚ä∏‚äë)camera
}

# Returns the camera view matrix
GetCameraViewMatrix ‚Üê {ùïäcamera:
  MatrixLookAt cameraIndex.position‚ÄøcameraIndex.target‚ÄøcameraIndex.up‚äècamera
}

# Returns the camera projection matrix
PickCullDist ‚Üê {ùïäcamera_cull_distance_near‚Äøcamera_cull_distance_far:
  ‚ü®
    {aspectùïäcamera: # GetCameraProjectionMatrix
      { ùï© ‚â° rl.cameraProjection.camera_perspective?
        MatrixPerspective‚ü®deg2rad√ócameraIndex.fovy‚äëcamera, aspect, camera_cull_distance_near, camera_cull_distance_far‚ü©

      ; ùï© ‚â° rl.cameraProjection.camera_orthographic?
        top ‚Üê 2√∑ÀúcameraIndex.fovy‚äëcamera
        right ‚Üê top√óaspect

        MatrixOrtho‚ü®-right, right, -top, top, camera_cull_distance_near, camera_cull_distance_far‚ü©
      ;
        =‚åúÀú‚Üï4
      }cameraIndex.projection‚äëcamera
    }
  ‚ü©
}

# Default cull distance
‚ü®GetCameraProjectionMatrix‚ü© ‚Üê PickCullDist 0.01‚Äø1000


#if !defined(RCAMERA_STANDALONE)
# Update camera position for selected mode
# Camera mode: CAMERA_FREE, CAMERA_FIRST_PERSON, CAMERA_THIRD_PERSON, CAMERA_ORBITAL or CUSTOM

MakeCameraUpdater ‚Üê {ùïä‚ü®
    camera_orbital_speed
    camera_rotation_speed
    camera_move_speed
    camera_pan_speed
    camera_mouse_move_sensitivity
    camera_mouse_scroll_sensitivity
  ‚ü©:
  
  {modeùïäcamera:
    mouseDelta ‚Üê GetMouseDelta‚ü®‚ü©
    cm ‚Üê rf.cameraMode
    moveInWorldPlane   ‚Üê ‚à®¬¥mode=cm.camera_third_person                  ‚Äøcm.camera_first_person
    rotateAroundTarget ‚Üê ‚à®¬¥mode=cm.camera_third_person‚Äøcm.camera_orbital
    lockView           ‚Üê ‚à®¬¥mode=cm.camera_third_person‚Äøcm.camera_orbital‚Äøcm.camera_first_person‚Äøcm.camera_free
    rotateUp           ‚Üê 0

    {mode=cm.camera_orbital?
      # Orbital can just orbit
      rotation ‚Üê MatrixRotate‚ü®GetCameraUp camera, camera_orbital_speed√óGetFrameTime‚ü®‚ü©‚ü©
      view ‚Üê -¬¥cameraIndex.position‚ÄøcameraIndex.target‚äècamera
      view MP‚Ü© rotation
      (cameraIndex.target + view)‚åæ(cameraIndex.position‚ä∏‚äë)camera
    ;
      # Camera rotation
      camera ‚Ü© CameraPitch‚ü®camera, camera_rotation_speed√ó-¬¥key.IsDown¬®key.up‚Äøkey.down , lockView, rotateAroundTarget, rotateUp‚ü©
      camera ‚Ü© CameraYaw  ‚ü®camera, camera_rotation_speed√ó-¬¥key.IsDown¬®key.left‚Äøkey.right, rotateAroundTarget‚ü©
      camera ‚Ü© CameraRoll‚üúcamera   camera_rotation_speed√ó-¬¥key.IsDown¬®key.e‚Äøkey.q

      # Camera movement
      # Camera pan (for CAMERA_FREE)
      {(mode = cm.camera_free) ‚àß mouse.IsButtonDown mouse.button.middle?
        camera ‚Ü© CameraMoveRight‚ü®camera,  camera_pan_speed√ó(0‚äëmouseDelta) > 0, moveInWorldPlane‚ü©
        camera ‚Ü© CameraMoveRight‚ü®camera, -camera_pan_speed√ó(0‚äëmouseDelta) < 0, moveInWorldPlane‚ü©
        camera ‚Ü© CameraMoveUp   ‚ü®camera, -camera_pan_speed√ó(1‚äëmouseDelta) > 0‚ü©
        camera ‚Ü© CameraMoveUp   ‚ü®camera,  camera_pan_speed√ó(1‚äëmouseDelta) < 0‚ü©
      ;
        # Mouse support
        camera ‚Ü© CameraYaw  ‚ü®camera, -(0‚äëmouseDelta)√ócamera_mouse_move_sensitivity, rotateAroundTarget‚ü©
        camera ‚Ü© CameraPitch‚ü®camera, -(1‚äëmouseDelta)√ócamera_mouse_move_sensitivity, lockView, rotateAroundTarget, rotateUp‚ü©
      }

      # Keyboard support
      camera ‚Ü© CameraMoveForward‚ü®camera,  camera_move_speed√ókey.IsDown key.w, moveInWorldPlane‚ü©
      camera ‚Ü© CameraMoveRight  ‚ü®camera, -camera_move_speed√ókey.IsDown key.a, moveInWorldPlane‚ü©
      camera ‚Ü© CameraMoveForward‚ü®camera, -camera_move_speed√ókey.IsDown key.s, moveInWorldPlane‚ü©
      camera ‚Ü© CameraMoveRight  ‚ü®camera,  camera_move_speed√ókey.IsDown key.d, moveInWorldPlane‚ü©

      # Gamepad movement
      {ùï§
        # Gamepad controller support
        camera ‚Ü© CameraYaw  ‚ü®camera, camera_mouse_move_sensitivity√ó¬Ø2√órf.GetGamepadAxisMovement 0‚Äørf.gamepadAxis.gamepad_axis_right_x,           rotateAroundTarget‚ü©
        camera ‚Ü© CameraPitch‚ü®camera, camera_mouse_move_sensitivity√ó¬Ø2√órf.GetGamepadAxisMovement 0‚Äørf.gamepadAxis.gamepad_axis_right_y, lockView, rotateAroundTarget, rotateUp‚ü©

        camera ‚Ü© CameraMoveForward‚çü(¬Ø0.25‚â•rf.GetGamepadAxisMovement 0‚Äørf.gamepadAxis.gamepad_axis_left_y)‚ü®camera,  camera_move_speed, moveInWorldPlane‚ü©
        camera ‚Ü© CameraMoveRight  ‚çü(¬Ø0.25‚â•rf.GetGamepadAxisMovement 0‚Äørf.gamepadAxis.gamepad_axis_left_x)‚ü®camera, -camera_move_speed, moveInWorldPlane‚ü©
        camera ‚Ü© CameraMoveForward‚çü( 0.25‚â§rf.GetGamepadAxisMovement 0‚Äørf.gamepadAxis.gamepad_axis_left_y)‚ü®camera, -camera_move_speed, moveInWorldPlane‚ü©
        camera ‚Ü© CameraMoveRight  ‚çü( 0.25‚â§rf.GetGamepadAxisMovement 0‚Äørf.gamepadAxis.gamepad_axis_left_x)‚ü®camera,  camera_move_speed, moveInWorldPlane‚ü©
      }‚çü‚ä¢ rf.IsGamepadAvailable 0

      {ùï§
        camera {CameraMoveUp ‚ü®ùï©,  camera_move_speed‚ü©}‚çü(key.IsDown key.space) ‚Ü©
        camera {CameraMoveUp ‚ü®ùï©, -camera_move_speed‚ü©}‚çü(key.IsDown key.left_control) ‚Ü©
      }‚çü‚ä¢mode=cm.camera_free
    }

    {
      # Zoom target distance
      camera ‚Ü© ùï© CameraMoveToTargetÀú-mouse.WheelMoved@
      camera CameraMoveToTargetÀú 2√ó+¬¥‚ü®
        key.IsPressed key.keypad.subtract
        -key.IsPressed key.keypad.add
      ‚ü©
    }‚çü(‚à®¬¥mode=cm.camera_third_person‚Äøcm.camera_orbital‚Äøcm.camera_free) camera
  }
}

updateCamera ‚Üê MakeCameraUpdater {
  camera_orbital_speed  ‚áê 0.5
  camera_rotation_speed ‚áê 0.03 # Radians per second
  camera_move_speed     ‚áê 0.09
  camera_pan_speed      ‚áê 0.2

  # Camera mouse movement sensitivity
  camera_mouse_move_sensitivity   ‚áê 0.003     # TODO: it should be independant of framerate
  camera_mouse_scroll_sensitivity ‚áê 1.5
}


# Update camera movement, movement/rotation values should be provided by user
UpdateCameraPro ‚Üê {ùïäcamera‚Äømovement‚Äørotation‚Äøzoom:
  # Required values
  # movement.x - Move forward/backward
  # movement.y - Move right/left
  # movement.z - Move up/down
  # rotation.x - yaw
  # rotation.y - pitch
  # rotation.z - roll
  # zoom - Move towards target

  lockView           ‚Üê 1
  rotateAroundTarget ‚Üê 0
  rotateUp           ‚Üê 0
  moveInWorldPlane   ‚Üê 1

  # Camera rotation
  camera ‚Ü© CameraYaw  ‚ü®camera, -(0‚äërotation)√ódeg2rad, rotateAroundTarget‚ü©
  camera ‚Ü© CameraPitch‚ü®camera, -(1‚äërotation)√ódeg2rad, lockView, rotateAroundTarget, rotateUp‚ü©
  camera ‚Ü© CameraRoll ‚ü®camera,  (2‚äërotation)√ódeg2rad‚ü©

  # Camera movement
  camera ‚Ü© CameraMoveForward‚ü®camera, 0‚äëmovement, moveInWorldPlane‚ü©
  camera ‚Ü© CameraMoveRight  ‚ü®camera, 1‚äëmovement, moveInWorldPlane‚ü©
  camera ‚Ü© CameraMoveUp     ‚ü®camera, 2‚äëmovement‚ü©

  # Zoom target distance
  CameraMoveToTarget camera‚Äøzoom
}
