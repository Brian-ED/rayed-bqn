âŸ¨color, window, draw, rfâ‡rayffi, keyâŸ©â†râ†â€¢Import "../../../raylib.bqn"

# Light type
lightType â† {
    directional â‡ 0
    point       â‡ 1
}

modelType â† {
  transform     â‡ 0 # Matrix transform    # Local transform matrix
  meshCount     â‡ 1 # meshCount           # Number of meshes
  materialCount â‡ 2 # materialCount       # Number of materials
  meshes        â‡ 3 # Mesh *meshes        # Meshes array
  materials     â‡ 4 # Material *materials # Materials array
  meshMaterial  â‡ 5 # int *meshMaterial   # Mesh material number
  boneCount     â‡ 6 # int boneCount       # Number of bones
  bones         â‡ 7 # BoneInfo *bones     # Bones information (skeleton)
  bindPose      â‡ 8 # Transform *bindPose # Bones base transformation (pose)
}

shaderType â† {
    programID â‡ 0 # u         # Shader program id
    locs      â‡ 1 # ptr (P i) # Shader locations array (RL_MAX_SHADER_LOCATIONS)
}

# Define the camera to look into our 3d world
camera â†âŸ¨
    3â€¿3â€¿3                          # position   # Camera position
    0â€¿1â€¿0Ã·2                        # target     # Camera looking at point
    0â€¿1â€¿0                          # up         # Camera up vector (rotation towards target)
    45                             # fovy       # Camera field-of-view Y
    r.cameraProjection.perspective # projection # Camera projection type
âŸ©

Show â† {â€¢Out ('â€'-@)âŠ¸+âŒ¾((@=f)âŠ¸/)fâ†â€¢Fmtğ•© â‹„ â€¢term.Flush@ â‹„ ğ•©}

ShaderVal â† {shaderâ€¿shaderTypeğ•ŠshaderVar:
    iâ†rf.GetShaderLocation shaderâ‹ˆğ•©âˆ¾@
    Set â‡ {rf.SetShaderValue shaderâ€¿iâ€¿ğ•©â€¿shaderType}

}

{ğ•¤
    rf.SetConfigFlags r.window.configFlags.msaa_4x_hint  # Enable Multi Sampling Anti Aliasing 4x (if available)
    modelâ€¿cube â† rf.LoadModelFromMeshÂ¨âŸ¨
        rf.GenMeshPlane 10â€¿10â€¿3â€¿3 
        rf.GenMeshCube  2â€¿4â€¿2
    âŸ©

    # Load basic lighting shader
    # loadShader â† "../../C/raylib/src/libraylib.so" â€¢FFI "*:i8"â€¿"LoadShader"â€¿"*i8:c8"â€¿"*i8:c8"
    shader â† rf.LoadShader â€¢file.AtÂ¨"lighting."âŠ¸âˆ¾Â¨"vs"â€¿"fs"
    shaderLocsPtr â† shaderType.locs âŠ‘ shader # shader.locs
    
    font â† r.font.LoadBQN 100

    # Get some required shader locations
    { # shader.locs[SHADER_LOC_VECTOR_VIEW] = GetShaderLocation(shader, "viewPos");
        movedPtr â† shaderLocsPtr rf.MovePtrËœ4Ã—r.shaderLocationIndex.vector_view
        movedPtr rf.ReadI32Ëœâ‹ˆrf.GetShaderLocation shaderâ‹ˆ"viewPos"âˆ¾@
    }
    # Ambient light level (some basic lighting)
    ambientLoc â† rf.GetShaderLocation shaderâ‹ˆ"ambient"âˆ¾@
    rf.SetShaderValue âŸ¨shader, ambientLoc, Ã·10â€¿10â€¿10â€¿1, r.shaderUniformDataType.vec4âŸ©
    
    # Assign out lighting shader to model
    MakeMaterialPtr â† {ğ•¤
        size â† +Â´âŸ¨
            12 # shaderSize
            
            # rest of material struct
            8   # ptrSize
            4Ã—4 # v4Size
        âŸ©
        ptrâ†rf.MemAlloc size
        ptr rf.ReadËœsizeâ†‘âˆ¾Ëœâˆ¾rf.U32ToI8âŒ¾âŠ‘shader
        ptr
    }
    (â€¢Show 36âŠ¸rf.Make)âŒ¾(modelType.materialsâŠ¸âŠ‘)Â¨modelâ€¿cube
    modelâ€¿cube MakeMaterialPtrâŒ¾(modelType.materialsâŠ¸âŠ‘)Â¨â†©
    # model.materials[0].shader â† shader;
    # cube .materials[0].shader â† shader;

    # Create lights
    CreateLight â† {ğ•ŠâŸ¨
            position    # Vector3
            target      # Vector3
            color       # Color
            pKey
            lightsCount
        âŸ©:
        typeâ€¿positionâ€¿targetâ€¿colorâ‡
        colorÃ·â†©255
        enabled â‡ 1
        type â† lightType.point

        # NOTE: Lighting shader naming must be the provided ones
        F â† {typeâ€¿var:
            loc â† rf.GetShaderLocation shaderâ‹ˆ"lights["âˆ¾(â€¢Repr lightsCount)âˆ¾"]."âˆ¾varâˆ¾@
            {ğ•©âŠ£rf.SetShaderValue âŸ¨shaderâ‹„locâ‹„â¥Šğ•©â‹„typeâŸ©}
        }
        su â† r.shaderUniformDataType
        setEnabled  â† {ğ•Šn: Gâ†{enabled  â†© Nğ•©} â‹„ G enabled  â‹„ g} F su.int â€¿"enabled"
        setType     â‡ {ğ•Šn: Gâ†{type     â†© Nğ•©} â‹„ G type     â‹„ g} F su.int â€¿"type"
        setPosition â‡ {ğ•Šn: Gâ†{position â†© Nğ•©} â‹„ G position â‹„ g} F su.vec3â€¿"position"
        setTarget   â‡ {ğ•Šn: Gâ†{target   â†© Nğ•©} â‹„ G target   â‹„ g} F su.vec3â€¿"target"
        setColor    â‡ {ğ•Šn: Gâ†{color    â†© Nğ•©} â‹„ G color    â‹„ g} F su.vec4â€¿"color"
        Toggle      â‡ {ğ•Š: SetEnabledÂ¬enabled}âŸ(key.IsPressedâˆ˜pKey)
        
    }
    lights â† CreateLightÂ¨({aâ€¿bâ€¿k:âŸ¨aâ‹„3â¥Š0â‹„bâ‹„kâŸ©}Â¨âˆ¾Â¨â†•âˆ˜â‰ )âŸ¨
        âŸ¨Â¯2â€¿1â€¿Â¯2 â‹„ color.yellow â‹„ key.yâŸ©
        âŸ¨ 2â€¿1â€¿ 2 â‹„ color.red    â‹„ key.râŸ©
        âŸ¨Â¯2â€¿1â€¿ 2 â‹„ color.green  â‹„ key.gâŸ©
        âŸ¨ 2â€¿1â€¿Â¯2 â‹„ color.blue   â‹„ key.bâŸ©
    âŸ©



    # Main game loop
    {ğ•¤
        rf.UpdateCamera âŸ¨cameraâŸ©â€¿r.cameramode.orbital
        rf.SetShaderValue âŸ¨
            shader
            âŠ¢Â´(r.shaderLocationIndex.vector_view+1) rf.MakeI32 shaderLocsPtr # locsPtr[SHADER_LOC_VECTOR_VIEW]
            âŠ‘camera
            r.shaderUniformDataType.vec3
        âŸ©
        lights {ğ•¨.Toggle@}âŸ(key.IsPressedâŠ¢)Â¨âŸ¨key.yâ‹„key.râ‹„key.gâ‹„key.bâŸ©
        {ğ•¤ 
            ShowÂ¨ cube
            rf.DrawModel âŸ¨model â‹„ 3â¥Š0 â‹„ 1 â‹„ color.whiteâŸ©
            Show "Hi2"
            rf.DrawModel âŸ¨cube â‹„ 3â¥Š0 â‹„ 1 â‹„ color.whiteâŸ©
            # Draw spheres to show where the lights are
            {ğ•©.enabled? rf.DrawSphereEx ğ•©.positionâ€¿0.2â€¿8â€¿8â€¿(ğ•©.colorÃ—255)
            ;           rf.DrawSphereWires 76âŒ¾âŠ‘âŒ¾âŒ½âŒ¾âŠ‘âŒ¾âŒ½ âŸ¨ğ•©.position, 0.2, 8, 8, ğ•©.colorÃ—255âŸ©
            }Â¨lights
            rf.DrawGrid 10â€¿1
        } r.draw._in3D camera

        rf.DrawFPS 10â€¿10
        color.darkgrayâ€¿fontâ€¿30 draw.Text 10â€¿40â‹ˆ"Use keys [Y][R][G][B] to toggle lights"

        (key.rightâ€¿key.upâ€¿key.e -â—‹key.IsPressed key.leftâ€¿key.downâ€¿key.q)âŠ¸+âŒ¾(âŠ‘âŠ‘)ğ•©
    }draw._withCanvas_ color.raywhiteâ€¢_While_(Â¬window.ShouldClose) @

    r.font.Unload font
    rf.UnloadModelÂ¨ modelâ€¿cube
    rf.UnloadShader shader
}window._openAs "raylib [shaders] example - basic lighting"



# Draw a model (with texture if set)
DrawModel â† {ğ•Šmodelâ€¿positionâ€¿scaleâ€¿tint:
    rotationAxis â† 0â€¿1â€¿0
    rf.DrawModelExâŸ¨model, position, rotationAxis, 0, 3â¥Šscale, tintâŸ©
}