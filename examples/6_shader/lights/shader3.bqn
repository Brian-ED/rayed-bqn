âŸ¨color, window, draw, rfâ‡rayffi, keyâŸ©â†râ†â€¢Import "../../../raylib.bqn"

# Light type
lightType â† {
    directional â‡ 0
    point       â‡ 1
}

modelType â† {
  transform     â‡ 0 # Matrix transform    # Local transform matrix
  meshCount     â‡ 1 # meshCount           # Number of meshes
  materialCount â‡ 2 # materialCount       # Number of materials
  meshes        â‡ 3 # Mesh *meshes        # Meshes array
  materials     â‡ 4 # Material *materials # Materials array
  meshMaterial  â‡ 5 # int *meshMaterial   # Mesh material number
  boneCount     â‡ 6 # int boneCount       # Number of bones
  bones         â‡ 7 # BoneInfo *bones     # Bones information (skeleton)
  bindPose      â‡ 8 # Transform *bindPose # Bones base transformation (pose)
}

shaderType â† {
    programID â‡ 0 # u         # Shader program id
    locs      â‡ 1 # ptr (P i) # Shader locations array (RL_MAX_SHADER_LOCATIONS)
}

# Define the camera to look into our 3d world
camera â†âŸ¨
    3â€¿3â€¿3                          # position   # Camera position
    0â€¿1â€¿0Ã·2                        # target     # Camera looking at point
    0â€¿1â€¿0                          # up         # Camera up vector (rotation towards target)
    45                             # fovy       # Camera field-of-view Y
    r.cameraProjection.perspective # projection # Camera projection type
âŸ©

Show â† {â€¢Out ('â€'-@)âŠ¸+âŒ¾((@=f)âŠ¸/)fâ†â€¢Fmtğ•© â‹„ â€¢term.Flush@ â‹„ ğ•©}

ShaderVal â† {shaderâ€¿shaderTypeğ•ŠshaderVar:
    iâ†rf.GetShaderLocation shaderâ‹ˆğ•©âˆ¾@
    Set â‡ {rf.SetShaderValue shaderâ€¿iâ€¿(â¥Šğ•©)â€¿shaderType}
}

{ğ•¤
    rf.SetConfigFlags r.window.configFlags.msaa_4x_hint  # Enable Multi Sampling Anti Aliasing 4x (if available)
    modelâ€¿cube â† rf.LoadModelFromMeshÂ¨âŸ¨
        rf.GenMeshPlane 10â€¿10â€¿3â€¿3 
        rf.GenMeshCube  2â€¿4â€¿2
    âŸ©

    # Load basic lighting shader
    # loadShader â† "../../C/raylib/src/libraylib.so" â€¢FFI "*:i8"â€¿"LoadShader"â€¿"*i8:c8"â€¿"*i8:c8"
    shader â† rf.LoadShader â€¢file.AtÂ¨"lighting."âŠ¸âˆ¾Â¨"vs"â€¿"fs"
    shaderLocsPtr â† shaderType.locs âŠ‘ shader # shader.locs
    
    font â† r.font.LoadBQN 100

    # Get some required shader locations
    # shader.locs[SHADER_LOC_VECTOR_VIEW] = GetShaderLocation(shader, "viewPos");
    movedPtr â† shaderLocsPtr rf.MovePtrËœ4Ã—r.shaderLocationIndex.vector_view
    movedPtr rf.ReadI32Ëœâ‹ˆrf.GetShaderLocation shaderâ‹ˆ"viewPos"âˆ¾@

    # Ambient light level (some basic lighting)
    ambientLoc â† rf.GetShaderLocation shaderâ‹ˆ"ambient"âˆ¾@
    rf.SetShaderValue âŸ¨shader, ambientLoc, Ã·10â€¿10â€¿10â€¿1, r.shaderUniformDataType.vec4âŸ©
    
    # Assign out lighting shader to model
    MakeMaterialPtr â† {ğ•¤
        size â† +Â´âŸ¨
            12 # shaderSize
            
            # rest of material struct
            8   # ptrSize
            4Ã—4 # v4Size
        âŸ©
        ptrâ†rf.MemAlloc size
        ptr rf.ReadËœsizeâ†‘âˆ¾Ëœâˆ¾rf.U32ToI8âŒ¾âŠ‘shader
        ptr
    }
#    (â€¢Show 36âŠ¸rf.Make)âŒ¾(modelType.materialsâŠ¸âŠ‘)Â¨modelâ€¿cube
    modelâ€¿cube MakeMaterialPtrâŒ¾(modelType.materialsâŠ¸âŠ‘)Â¨â†©
    # model.materials[0].shader â† shader;
    # cube .materials[0].shader â† shader;

    # Create lights
    lights â† {ğ•ŠâŸ¨
            position
            color
            pKey
            lightsCount
        âŸ©:
        positionâ€¿colorâ‡
        colorÃ·â†©255
        enabled â‡ 1

        # NOTE: Lighting shader naming must be the provided ones
        _Setter â† {typeâ€¿var _ğ•£:
            loc â† rf.GetShaderLocation shaderâ‹ˆ"lights["âˆ¾(â€¢Repr lightsCount)âˆ¾"]."âˆ¾varâˆ¾@
            {ğ•©âŠ£rf.SetShaderValue âŸ¨shaderâ‹„locâ‹„â¥Šğ•©â‹„typeâŸ©}
        }
        su â† r.shaderUniformDataType
        su.int â€¿"type"     _Setter lightType.point
        su.vec3â€¿"position" _Setter position
        su.vec3â€¿"target"   _Setter 3â¥Š0
        su.vec4â€¿"color"    _Setter color
        (SetLight â† su.intâ€¿"enabled" _Setter) enabled
        Toggle â‡ {ğ•Š:enabled SetLightâˆ˜Â¬â†©}âŸ(key.IsPressedâˆ˜pKey)
    }âˆ˜âˆ¾Â¨âŸœ(â†•â‰ )âŸ¨
        âŸ¨Â¯2â€¿1â€¿Â¯2 â‹„ color.yellow â‹„ key.yâŸ©
        âŸ¨ 2â€¿1â€¿ 2 â‹„ color.red    â‹„ key.râŸ©
        âŸ¨Â¯2â€¿1â€¿ 2 â‹„ color.green  â‹„ key.gâŸ©
        âŸ¨ 2â€¿1â€¿Â¯2 â‹„ color.blue   â‹„ key.bâŸ©
    âŸ©

    # Main game loop
    {ğ•¤
        rf.UpdateCamera cameraâ‹ˆâŠ¸â‹ˆr.cameramode.orbital
        rf.SetShaderValue âŸ¨
            shader
            âŠ¢Â´(r.shaderLocationIndex.vector_view+1) rf.MakeI32 shaderLocsPtr # locsPtr[SHADER_LOC_VECTOR_VIEW]
            âŠ‘camera
            r.shaderUniformDataType.vec3
        âŸ©
        {ğ•©.Toggle@}Â¨lights
        {ğ•¤ 
#            ShowÂ¨ cube
#            rf.DrawModel âŸ¨model â‹„ 3â¥Š0 â‹„ 1 â‹„ color.whiteâŸ©
#            Show "Hi2"
#            rf.DrawModel âŸ¨cube â‹„ 3â¥Š0 â‹„ 1 â‹„ color.whiteâŸ©
            # Draw spheres to show where the lights are
            {ğ•©.enabled? rf.DrawSphereEx ğ•©.positionâ€¿0.2â€¿8â€¿8â€¿(ğ•©.colorÃ—255)
            ;           rf.DrawSphereWires 76âŒ¾âŠ‘âŒ¾âŒ½âŒ¾âŠ‘âŒ¾âŒ½ âŸ¨ğ•©.position, 0.2, 8, 8, ğ•©.colorÃ—255âŸ©
            }Â¨lights
            rf.DrawGrid 10â€¿1
        } r.draw._in3D camera

        rf.DrawFPS 10â€¿10
        color.darkgrayâ€¿fontâ€¿30 draw.Text 10â€¿40â‹ˆ"Use keys [Y][R][G][B] to toggle lights"

        (key.rightâ€¿key.upâ€¿key.e -â—‹key.IsPressed key.leftâ€¿key.downâ€¿key.q)âŠ¸+âŒ¾(âŠ‘âŠ‘)ğ•©
    }draw._withCanvas_ color.raywhiteâ€¢_While_(Â¬window.ShouldClose) @

    r.font.Unload font
    rf.UnloadModelÂ¨ â€¢ShowÂ¨âŒ¾(â‰>)modelâ€¿cube
    rf.UnloadShader shader
}window._openAs "raylib [shaders] example - basic lighting"



# Draw a model (with texture if set)
DrawModel â† {ğ•Šmodelâ€¿positionâ€¿scaleâ€¿tint:
    rotationAxis â† 0â€¿1â€¿0
    rf.DrawModelExâŸ¨model, position, rotationAxis, 0, 3â¥Šscale, tintâŸ©
}