âŸ¨color, window, draw, rayffi, keyâŸ©â†râ†â€¢Import "../../raylib.bqn"
âŸ¨materialStructâ‡materialâŸ© â† rayffi
Show â† {â€¢Out ('â€'-@)âŠ¸+âŒ¾((@=f)âŠ¸/)fâ†â€¢Fmtğ•© â‹„ â€¢term.Flush@ â‹„ ğ•©}

# RLights

# Light data
###typedef struct {   
###    int type;
###    bool enabled;
###    Vector3 position;
###    Vector3 target;
###    Color color;
###    float attenuation;
###    
###    # Shader locations
###    int enabledLoc;
###    int typeLoc;
###    int positionLoc;
###    int targetLoc;
###    int colorLoc;
###    int attenuationLoc;
###} Light;

# LightToArr â† {l:âŸ¨
#     l.type
#     l.enabled
#     l.position
#     l.target
#     l.color
#     l.attenuation
# 
#     l.enabledLoc
#     l.typeLoc
#     l.positionLoc
#     l.targetLoc
#     l.colorLoc
#     l.attenuationLoc
# âŸ©}

# Light type
###typedef enum {
lightType â† {
    directional â‡ 0
    point       â‡ 1
}

modelType â† {
  transform     â‡ 0 # Matrix transform    # Local transform matrix
  meshCount     â‡ 1 # meshCount           # Number of meshes
  materialCount â‡ 2 # materialCount       # Number of materials
  meshes        â‡ 3 # Mesh *meshes        # Meshes array
  materials     â‡ 4 # Material *materials # Materials array
  meshMaterial  â‡ 5 # int *meshMaterial   # Mesh material number
  boneCount     â‡ 6 # int boneCount       # Number of bones
  bones         â‡ 7 # BoneInfo *bones     # Bones information (skeleton)
  bindPose      â‡ 8 # Transform *bindPose # Bones base transformation (pose)
}

shaderType â† {
    programID â‡ 0 # u         # Shader program id
    locs    â‡ 1 # ptr (P i) # Shader locations array (RL_MAX_SHADER_LOCATIONS)
}

# Create a light and get shader locations
CreateLight â‡ 4âŠ¸âŠ‘{shaderğ•Šğ•©:UpdateLightValues shaderâ€¿ğ•©â‹„ğ•©}{
    ğ•ŠâŸ¨
        type        # int
        position    # Vector3
        target      # Vector3
        color       # Color
        shader      # Shader
        lightsCount # int
    âŸ©:
    typeâ€¿positionâ€¿targetâ€¿colorâ‡
    enabled â‡ 1
    SetType     â‡ {type     â†© ğ•©}
    SetPosition â‡ {position â†© ğ•©}
    SetTarget   â‡ {target   â†© ğ•©}
    SetColor    â‡ {color    â†© ğ•©}

    # NOTE: Lighting shader naming must be the provided ones
    F â† rayffi.GetShaderLocation shaderâ‹ˆ@âˆ¾Ëœ("lights["âˆ¾"]."âˆ¾Ëœâ€¢Repr lightsCount)âŠ¸âˆ¾
    enabledLoc  â‡ F "enabled"
    typeLoc     â‡ F "type"
    positionLoc â‡ F "position"
    targetLoc   â‡ F "target"
    colorLoc    â‡ F "color"
    Toggle â‡ {ğ•Š:enabledÂ¬â†©}
}

# Send light properties to shader
# NOTE: Light shader locations should be available 
UpdateLightValues â† {shaderâ€¿light:
    # Send light to shader
    F â† rayffi.SetShaderValueâŸ¨shaderâŸ©âŠ¸âˆ¾
    su â† r.shaderUniformDataType
    F âŸ¨light.enabledLoc , â‹ˆlight.enabled , su.int âŸ© # TODO: may not work. replaced & at light.enabled with â‹ˆ
    F âŸ¨light.typeLoc    , â‹ˆlight.type    , su.int âŸ© # TODO: may not work. replaced & at light.type with â‹ˆ
    F âŸ¨light.positionLoc, light.position , su.vec3âŸ©
    F âŸ¨light.targetLoc  , light.target   , su.vec3âŸ©
    F âŸ¨light.colorLoc   , light.colorÃ·255, su.vec4âŸ©
}
#RLights END

rayffi.SetConfigFlags r.window.configFlags.msaa_4x_hint  # Enable Multi Sampling Anti Aliasing 4x (if available)

_withConsts â† {ğ”½_ğ•£ ğ•©:
    # Define the camera to look into our 3d world
    camera â†âŸ¨
        3â€¿3â€¿3   # position   # Camera position
        0â€¿1â€¿0Ã·2 # target     # Camera looking at point
        0â€¿1â€¿0   # up         # Camera up vector (rotation towards target)
        45      # fovy       # Camera field-of-view Y
        0       # projection # Camera projection type
    âŸ©
    # Load plane model from a generated mesh
    model â† rayffi.LoadModelFromMesh rayffi.GenMeshPlane 10â€¿10â€¿3â€¿3
    cube  â† rayffi.LoadModelFromMesh rayffi.GenMeshCube  2 â€¿4 â€¿2

    # Load basic lighting shader
    # loadShader â† "../../C/raylib/src/libraylib.so" â€¢FFI "*:i8"â€¿"LoadShader"â€¿"*i8:c8"â€¿"*i8:c8"
    shader â† rayffi.LoadShader@âˆ¾ËœÂ¨"lighting."âŠ¸âˆ¾Â¨"vs"â€¿"fs"
    font â† r.font.LoadBQN 100
    # Get some required shader locations
    { # shader.locs[SHADER_LOC_VECTOR_VIEW] = GetShaderLocation(shader, "viewPos");
        ptr â† shaderType.locs âŠ‘ shader
        movedPtr â† ptr r.rayffi.MovePtrËœ8Ã—r.shaderLocationIndex.vector_view
        
        movedPtr rayffi.ReadËœâ‹ˆrayffi.GetShaderLocation shaderâ‹ˆ"viewPos"âˆ¾@
        
        # shader.locs[SHADER_LOC_VECTOR_VIEW] = GetShaderLocation(shader, "viewPos");
    }
    # Ambient light level (some basic lighting)
    ambientLoc â† rayffi.GetShaderLocation shaderâ‹ˆ"ambient"âˆ¾@
    rayffi.SetShaderValue âŸ¨shader, ambientLoc, Ã·10â€¿10â€¿10â€¿1, r.shaderUniformDataType.vec4âŸ©
    
    # Assign out lighting shader to model
    {shader rayffi.Read modelType.materials âŠ‘ ğ•©}Â¨modelâ€¿cube
    # model.materials[0].shader â† shader;
    # cube .materials[0].shader â† shader;

    # Create lights
    lights â† CreateLightÂ¨â†•âˆ˜â‰ âŠ¸({lğ•Šaâ€¿b:âŸ¨lightType.pointâ‹„aâ‹„3â¥Š0â‹„bâ‹„shaderâ‹„lâŸ©}Â¨)âŸ¨
        Â¯2â€¿1â€¿Â¯2 â‹ˆ color.yellow
         2â€¿1â€¿ 2 â‹ˆ color.red
        Â¯2â€¿1â€¿ 2 â‹ˆ color.green
         2â€¿1â€¿Â¯2 â‹ˆ color.blue
    âŸ©
    font ğ”½ cameraâ€¿shaderâ€¿lightsâ€¿cubeâ€¿model
    r.font.Unload font
    rayffi.UnloadModelÂ¨ modelâ€¿cube
    rayffi.UnloadShader shader
}

# Main game loop
PerFrame â† {fontğ•Šcameraâ€¿shaderâ€¿lightsâ€¿cubeâ€¿model:
    # Update
    #----------------------------------------------------------------------------------
    rayffi.UpdateCamera âŸ¨cameraâŸ©â€¿r.cameramode.orbital # TODO may not work, &camera â†’ âŸ¨cameraâŸ©

    # Update the shader with the camera view vector (points towards { 0.0f, 0.0f, 0.0f })
    rayffi.SetShaderValue âŸ¨
        shader
        {
            locsPtr â† shaderType.locsâŠ‘shader # shader.locs
            Â¯1âŠ‘locsPtr rayffi.MakeI32Ëœ1+r.shaderLocationIndex.vector_view  # locsPtr[SHADER_LOC_VECTOR_VIEW]
        }
        âŠ‘camera
        r.shaderUniformDataType.vec3
    âŸ©

    # Check key inputs to enable/disable lights
    lights {ğ•¨.Toggle@}âŸ(key.IsPressedâŠ¢)Â¨âŸ¨key.yâ‹„key.râ‹„key.gâ‹„key.bâŸ©
    
    # Update light values (actually, only enable/disable them)
    (UpdateLightValues shaderâŠ¸â‹ˆ)Â¨lights
    #----------------------------------------------------------------------------------

    # Draw
    #----------------------------------------------------------------------------------
    {ğ•¤
        {ğ•¤
            rayffi.DrawModel âŸ¨cube â‹„ 3â¥Š0 â‹„ 1 â‹„ color.whiteâŸ©
            rayffi.DrawModel âŸ¨model â‹„ 3â¥Š0 â‹„ 1 â‹„ color.whiteâŸ©

            # Draw spheres to show where the lights are
            {ğ•©.enabled? rayffi.DrawSphereEx ğ•©.positionâ€¿0.2â€¿8â€¿8â€¿ğ•©.color
            ;           rayffi.DrawSphereWires âŸ¨ğ•©.position, 0.2, 8, 8, âˆ¾âŸœ76 3â†‘ğ•©.colorâŸ©
            }Â¨lights

            rayffi.DrawGrid 10â€¿1

        } draw._in3D camera

        rayffi.DrawFPS 10â€¿10

        color.darkgrayâ€¿fontâ€¿30 draw.Text 10â€¿40â‹ˆ"Use keys [Y][R][G][B] to toggle lights"

    }draw._withCanvas_ color.raywhite@
    (key.rightâ€¿key.upâ€¿key.e -â—‹key.IsPressed key.leftâ€¿key.downâ€¿key.q)âŠ¸+âŒ¾(âŠ‘âŠ‘)ğ•©
}

Game â† PerFrameâ€¢_While_(Â¬window.ShouldClose) _withConsts
Game window._openAs "raylib [shaders] example - basic lighting"

