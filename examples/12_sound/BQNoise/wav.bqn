# Functions to read to and write from wave files.
# Does not support many kinds of wave files, such as compressed data.

âŸ¨Read, ReadFull, Write, Read_set, Read_coerceâŸ©â‡

"wav.bqn takes a single option namespace, or no arguments" ! 1â‰¥â‰ â€¢args
o â† â‰ â—¶âŸ¨â€¢Importâˆ˜"options.bqn", âŠ‘âŸ© â€¢args

# The output from Read, or input to Write, is either:
# - A list of:
#     The sample rate (in Hz)
#     The PCM format (see below)
#     PCM data, which has shape nâ€¿l for n channels with l samples.
# - The PCM data only
#   (options.freq and options.fmt are used for rate and format)
# 
# Read returns the plain PCM data if the settings matched the
# options while Read_set and Read_coerce always return the
# plain data.

# A PCM format consists of the type of audio and the bit depth.
# The type is one of:
#   1  unsigned integer
#   3  floating point
# Other audio formats may be supported in the future.

# Wave file header format
wh â† {
  # Field properties are:
  #   len:  Length of field in bytes
  #   typ:  Whether to leave as chars (c) or convert to an integer (i)
  #   err:  Behavior on invalid value: fail (e), warn (w), or ignore (.)
  #         (Fields with ? depend on context)
  #   name: Field name
  #   def:  How to compute value
  lenâ€¿typâ€¿errâ€¿nameâ€¿def â‡ <Ë˜â‰>âŸ¨
    4â€¿'c'â€¿'e'â€¿"chunkID"      â€¿âŸ¨"RIFF"âŸ©
    4â€¿'i'â€¿'.'â€¿"chunkSize"    â€¿âŸ¨20++Â´,"subchunk1Size","subchunk2Size"âŸ©
    4â€¿'c'â€¿'e'â€¿"format"       â€¿âŸ¨"WAVE"âŸ©
    4â€¿'c'â€¿'e'â€¿"subchunk1ID"  â€¿âŸ¨"fmt "âŸ©
    4â€¿'i'â€¿'?'â€¿"subchunk1Size"â€¿âŸ¨16âŸ©
    2â€¿'i'â€¿'.'â€¿"audioFormat"  â€¿âŸ¨âŸ©
    2â€¿'i'â€¿'.'â€¿"numChannels"  â€¿âŸ¨âŸ©
    4â€¿'i'â€¿'.'â€¿"sampleRate"   â€¿âŸ¨âŸ©
    4â€¿'i'â€¿'w'â€¿"byteRate"     â€¿âŸ¨Ã—Â´Ã·8Ë™,"sampleRate","numChannels","bitsPerSample"âŸ©
    2â€¿'i'â€¿'w'â€¿"blockAlign"   â€¿âŸ¨Ã—Â´Ã·8Ë™,"numChannels","bitsPerSample"âŸ©
    2â€¿'i'â€¿'.'â€¿"bitsPerSample"â€¿âŸ¨âŸ©
    4â€¿'c'â€¿'?'â€¿"subchunk2ID"  â€¿âŸ¨"data"âŸ©
    4â€¿'i'â€¿'.'â€¿"subchunk2Size"â€¿âŸ¨âŸ©
  âŸ©
  def â†© nameâŠ¸âŠâŒ¾(1âŠ¸â†“)âŸ(1<â‰ )Â¨ def

  # Topological order for field definitions
  order â‡ {{ğ•ŠâŸ(l>â—‹â‰ âŠ¢)âŸœ(ğ•©âˆ¾Â·/ğ•¨âŠ¸<)ğ•¨âˆ¨âˆ§Â´âˆ˜âŠâŸœğ•¨Â¨l}âŸœ/0Â¨lâ†ğ•©} 1â†“Â¨def

  # Then fill blank definitions with a self-reference
  def â†© â†•âˆ˜â‰ âŠ¸({âŠ‘â€¿ğ•¨âŸ(0=â‰ )ğ•©}Â¨) def

  # Turn list of values into namespace
  makeNS â‡ â€¢BQN "{"âˆ¾(1â†“âˆ¾"â€¿"âŠ¸âˆ¾Â¨name)âˆ¾"â‡ğ•©}"
}

_be_ â† {1(-âŠ¸â†“-ğ•—Ã—â†“)âŒŠâˆ˜Ã·âŸœğ•—âŸ(â†•1+ğ•˜)}  # Base expansion

# Return an undoable (â¼) function to convert bytes to PCM data.
_audioConvert â† {
  audioFormatâ€¿bitsPerSample â† ğ•—
  "Bits per sample must be a multiple of 8" ! 0=8|bitsPerSample
  "Bits per sample cannot exceed 64" ! bitsPerSample â‰¤ 64
  l â† bitsPerSampleÃ·8
  _withInv_ â† {F _ğ•£_ G: {ğ•Š:Fğ•© ; ğ•Šâ¼:Gğ•©}}
  # Convert ğ•—-byte sequences to ints
  bitcast â† â€¢BQNâŠ0 "â€¢bit._cast"
  _int â† {
    0â‰¢bitcast ? âŠ‘ğ•—âˆŠ1â€¿2â€¿4 ?
      âŸ¨8,'c'âŸ©â€¿âŸ¨8Ã—ğ•—,'i'âŸ© _bitcast
    ;
      b â† 256
      (+âŸœ(bâŠ¸Ã—)ËËœâŸœ(-(bÃ·2)â‰¤Â¯1âŠ¸âŠ)Â·â‰âŒŠâ€¿ğ•—â¥ŠâŠ¢) _withInv_ (â¥Šâˆ˜â‰âˆ˜> b _be_ ğ•—) -âŸœ@
  }
  # Convert int to float
  _float â† {eâ€¿mâ€¿bâ†ğ•—  # exponent and mantissa length in bits; bias
    maxvalâ†(1-2â‹†-m+1)Ã—2â‹†(2â‹†e)-b+1
    {
      ğ•© Ã—â†© 2â‹†-m
      pâ€¿s â† (2â‹†e) (| â‹ˆ âŒŠâˆ˜Ã·Ëœ) âŒŠğ•©
      p +â†© Â¬nâ†0<p
      (Â¯1â‹†s)Ã—(2â‹†p-b) Ã— n+1|ğ•©
    }_withInv_{
      sâ†ğ•©<0 â‹„ ğ•©â†©maxvalâŒŠ|ğ•©
      pâ†0âŒˆb+âŒŠ2â‹†â¼ğ•© â‹„ hâ†p+sÃ—2â‹†e
      p +â†© Â¬nâ†0<p
      âŒŠ0.5 + (2â‹†m) Ã— h + n-Ëœğ•©Ã—2â‹†b-p
    }
  }
  # Look up the appropriate function
  {
  1:
    l _int ;
  3:
    "Float formats other than 32-bit are not supported" ! 4=l
    8â€¿23â€¿127 _float 4 _int ;
  ğ•©:
    0 !Ëœ "Unsupported audio format: " âˆ¾ â€¢Repr audioFormat
  }audioFormat
}

# ğ•¨ is audioFormatâ€¿bitsPerSample.
# Force ğ•© to fit in format ğ•¨, emitting approprate warnings.
ForceFormat â† { fâ€¿b ğ•Š pcm:
  Dither â† {
    â€¢OutâŸo.warn_dither "Signal is non-integral; dithering..."
    o.Dither ğ•©
  }
  Clip â† {
    â€¢OutâŸo.warn_clip "Signal out of bounds; clipping..."
    max âŒŠ min âŒˆ ğ•©
  }
  minâ€¿max â† (-â‰-âŸœ1) 2â‹†b-1
  (ClipâŸ(minâŠ¸> âˆ¨â—‹(âˆ¨Â´â¥Š) >âŸœmax) Ditherâˆ˜âŠ£âŸâ‰¢âŸœâŒŠ)âŸ(f=1) pcm
}

Decode â† {
  If â† {ğ•âŸğ•@}Â´
  While â† {ğ•¨{ğ•Šâˆ˜ğ”¾âŸğ”½ğ•©}ğ•©@}Â´
  # Integer from little-endian unsigned bytes
  ToInt â† 256âŠ¸Ã—âŠ¸+ËœÂ´ -âŸœ@

  hdrtâ€¿dat â† wh.len +Â´âŠ¸(â†‘â‹ˆâ†“) ğ•©

  # Assign field values to field names.
  hdr â† ('i'=wh.typ) ToIntâˆ˜âŠ¢âŸâŠ£Â¨ wh.len /âŠ¸âŠ” hdrt
  subchunk1Sizeâ€¿subchunk2Sizeâ€¿subchunk2IDâ€¿audioFormatâ€¿bitsPerSampleâ€¿sampleRateâ€¿numChannels â† wh.MakeNS hdr
  # Handle extensible format
  "subchunk1Size is invalid" ! âŠ‘ 0â€¿2â€¿24 âˆŠËœ seâ†subchunk1Size-16
  ScHdr â† 4 (â†‘ â‹ˆ ToIntâˆ˜â†“) âŠ¢  # Parse a new subchunk header
  If (se>0)â€¿{ğ•¤
    ! se = 2 + ToInt 2â†‘subchunk2ID
    extâ†@ â‹„ extâ€¿dat â†© se (â†‘â‹ˆâ†“) dat
    subchunk2IDâ€¿subchunk2Size â†© ScHdr ext Â« Â¯8 â†‘ hdrt
    If (se>2)â€¿{ğ•¤
      If (audioFormat = 65534)â€¿{ğ•¤â‹„ audioFormat â†© ToInt 4â†‘ext }
    }
  }
  # Ignore remaining subchunks
  While {ğ•¤â‹„"data"â‰¢subchunk2ID}â€¿{ğ•¤
    (subchunk2IDâ€¿subchunk2Size)â€¿dat â†© 8 (ScHdrâˆ˜â†‘ â‹ˆ â†“) subchunk2Size â†“ dat
  }
  # Check that fields match their definitions
  e â† hdr â‰¢âŸœ(âŠ‘{ğ•ğ•©âŠhdr}1âŠ¸â†“)Â¨ wh.def
  Msg â† "Values for fields " âˆ¾ (âˆ¾âˆ¾âŸœ" "Â¨) âˆ¾ "are incorrect"Ë™
  _alert â† {(ğ”½âˆ˜Msg /âŸœ(wh.name))âŸ(âˆ¨Â´) e âˆ§ wh.errâŠ¸âˆŠ}
  !âŸœ0 _alert "e"âˆ¾(se<0)/"?"
  (â€¢Out "Warning: "âˆ¾âŠ¢) _alert "w"

  fmt â† audioFormatâ€¿bitsPerSample
  Cvt â† fmt _audioConvert
  âŸ¨sampleRate, fmt, â‰ âŒŠâ€¿numChannels â¥Š CvtâŠ(Cvt subchunk2SizeâŠ¸â†‘) datâŸ©
}

Encode â† { rateâ€¿fmtâ€¿pcm:
  ! 2 â‰¥ =pcm
  pcm â¥ŠâŸœ0âŠ¸â†“Ëœâ†© 2
  dat â† fmt _audioConvertâ¼ fmt ForceFormat â¥Šâ‰pcm
  inameâ€¿ival â† <Ë˜â‰âˆ˜â€¿2â¥ŠâŸ¨
    "sampleRate"   , rate
    "numChannels"  , â‰ pcm
    "subchunk2Size", â‰ dat
    "audioFormat"  , 0âŠ‘fmt
    "bitsPerSample", 1âŠ‘fmt
  âŸ©
  val â† def â† (â¥Šâˆ˜<Â¨ival)âŒ¾((wh.nameâŠiname)âŠ¸âŠ) wh.def

  { val â†© (âŠ‘{ğ•ğ•©âŠval}1âŠ¸â†“)âŒ¾(ğ•©âŠ¸âŠ‘) val }Â¨ wh.order

  hdr â† âˆ¾ (wh.lenÃ—wh.typ='i') 256{@+ğ•—_be_ğ•¨ ğ•©}âŸ(>âŸœ0)Â¨ val
  hdr âˆ¾ dat
}

ReadFull â† Decodeâˆ˜{ o.FBytes ğ•© }
Read  â† { Â¯1âŠ¸âŠ‘âŸ(âŸ¨o.freq,o.fmtâŸ© â‰¡ 2âŠ¸â†‘) ReadFull ğ•© }
Write â† { ğ•© o.FBytes Encode(âŸ¨o.freq,o.fmtâŸ©âˆ¾<)âŸ(1â‰¥â‰¡) ğ•¨ }

# Read, setting o.freq and o.fmt as a side effect.
Read_set â† { tâ†ReadFull ğ•© â‹„ o.Set Â¯1â†“t â‹„ Â¯1âŠ‘t }

# Read, resampling to fit current frequency, using options.Resample
Read_coerce â† { ((o.freqâˆ¾Ëœ0âŠ¸âŠ‘) o.Resample Â¯1âŠ¸âŠ‘) ReadFull ğ•© }