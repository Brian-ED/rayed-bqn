âŸ¨
  âŸ¨ReadI32 â‹„ ReadI8âŸ©â‡low
  rfâ‡raylib
  âŸ¨
    GetShaderLocation â‹„ SetShaderValueRaw â‹„ SetShaderValue
    MemAlloc â‹„ MemFree
    âŸ¨ SHADER_UNIFORM_INT â‹„ SHADER_UNIFORM_VEC3 â‹„ SHADER_UNIFORM_Vec4
    âŸ©â‡shaderUniformDataType
  âŸ©â‡raylib
  âŸ¨blackâ‹„whiteâ‹„raywhiteâŸ©â‡color
  keyâ‹„mouse
âŸ© â† rl â† â€¢Import "../../rayed.bqn"

shaderIndex â† { # Shader
  id   â‡ 0 # u     # Shader program id
  locs â‡ 1 # "*"âˆ¾i # Shader locations array (RL_MAX_SHADER_LOCATIONS)
}
# A few good julia sets
pointsOfInterest â† [
    Â¯0.348827â€¿0.607167
    Â¯0.786268â€¿0.169728
    Â¯0.8â€¿0.156
     0.285â€¿0.0
    Â¯0.835â€¿Â¯0.2321
    Â¯0.70176â€¿Â¯0.3842
]

screenWidth â† 800
screenHeight â† 450
offsetSpeedMul â† 2

startingZoom â† 0.75

{ğ•¤
  # Load julia set shader
  shader â† rf.LoadShader â€¢file.RealPathÂ¨ "shaders/glsl330"âŠ¸â€¢file.AtÂ¨ "default.vs"â€¿"julia_set.fs"

  # Get some required shader locations
  veiwPos â† rf.GetShaderLocation shaderâ€¿"viewPos"
  {
    locsPtr â† shaderIndex.locsâŠ‘shader
    rf.shaderLocationIndex.shader_loc_vector_view locsPtr.Write veiwPos
  }

  # Create a RenderTexture2D to be used for render to texture
  target â† rf.LoadRenderTexture rl.window.GetSize@

  # c constant to use in z^2 + c
  c â† âŠpointsOfInterest

  # Offset and zoom to draw the julia set at. (centered on screen and default size)
  offset â† 0â€¿0
  zoom â† startingZoom

  # Get variable (uniform) locations on the shader to connect with the program
  # NOTE: If uniform variable could not be found in the shader, function returns -1
  cLoc      â† GetShaderLocation shaderâ€¿"c"
  zoomLoc   â† GetShaderLocation shaderâ€¿"zoom"
  offsetLoc â† GetShaderLocation shaderâ€¿"offset"
# Report to dzaima: &ref seem to accept pointer objects

  cv2 â† (rf.MemAlloc 8).Cast "f32"
  (â†•2)cv2.WriteÂ¨c

  zoomFloat â† (rf.MemAlloc 4).Cast "f32"
  zoomFloat.Write zoom

  offsetV2 â† (rf.MemAlloc 8).Cast "f32"
  (â†•2)offsetV2.WriteÂ¨offset

    (â†•2)cv2.WriteÂ¨c

  # Upload the shader uniform values!
  rf.SetShaderValueâŸ¨shader, cLoc     , cv2     , rf.shaderUniformDataType.shader_uniform_vec2 âŸ©
  rf.SetShaderValueâŸ¨shader, zoomLoc  , zoomFloat , rf.shaderUniformDataType.shader_uniform_floatâŸ©
  rf.SetShaderValueâŸ¨shader, offsetLoc, offsetV2, rf.shaderUniformDataType.shader_uniform_vec2 âŸ©

  incrementSpeed â† 0 # Multiplier of speed to change c value
  showControls â† 1   # Show controls

lightIndex â‡ {
  type        â‡ 0
  enabled     â‡ 1
  position    â‡ 2
  target      â‡ 3
  color       â‡ 4
  attenuation â‡ 5

  # Shader locations
  enabledLoc     â‡ 6
  typeLoc        â‡ 7
  positionLoc    â‡ 8
  targetLoc      â‡ 9
  colorLoc       â‡ 10
  attenuationLoc â‡ 11
}



  # Main game loop
  incrementâ†0
  {ğ•Š:

    {ğ•Š:
      (â†•2)cv2.WriteÂ¨ğ•©
      SetShaderValueâŸ¨shader, cLoc, cv2, rf.shaderUniformDataType.shader_uniform_vec2âŸ©
    }Ë˜pointsOfInterest/Ëœkey.IsPressedÂ¨key.one+â†•6

    # If "R" is pressed, reset zoom and offset.
    {
        zoomFloat.Write zoom
        (â†•2)offsetV2.WriteÂ¨offsetâ†©0â€¿0
        (â†•2)zoomFloat.WriteÂ¨startingZoom
        SetShaderValueâŸ¨shader, zoomLoc  , zoomFloat , rf.shaderUniformDataType.shader_uniform_floatâŸ©
        SetShaderValueâŸ¨shader, offsetLoc, offsetV2, rf.shaderUniformDataType.shader_uniform_vec2 âŸ©
    }âŸkey.IsPressed key.r

    incrementSpeed Ã—â†© Â¬key.IsPressed key.space # Pause animation (c change)
    showControls   â‰ â†©  key.IsPressed key.f1    # Toggle whether or not to show controls

    increment +â†© key.right-â—‹key.IsPressed key.left

    # If either left or right button is pressed, zoom in/out.
    {
      # Change zoom. If Mouse left -> zoom in. Mouse right -> zoom out.
      zoom Ã—â†© â‹†0.01Ã—-Â´mouse.IsButtonDown mouse.button.leftâ€¿mouse.button.right
      mousePos â† mouse.GetPos@
      # Find the velocity at which to change the camera. Take the distance of the mouse
      # from the center of the screen as the direction, and adjust magnitude based on
      # the current zoom.
      offsetVelocity â† (0.5-ËœmousePosÃ·rl.window.GetSize@)Ã—offsetSpeedMulÃ·zoom

      # Apply move velocity to camera
      offset +â†© offsetVelocityÃ·rf.GetFrameTimeâŸ¨âŸ©

      # Update the shader uniform values!
      zoomFloat.Write zoom
      (â†•2)offsetV2.WriteÂ¨offsetâ†©0â€¿0

      SetShaderValueâŸ¨shader, zoomLoc, zoomfloat,    rf.shaderUniformDataType.shader_uniform_floatâŸ©
      SetShaderValueâŸ¨shader, offsetLoc, offsetV2, rf.shaderUniformDataType.shader_uniform_vec2âŸ©
    }âŸrl.mouse.IsButtonDown mouse.button.right

    SetShaderValueâŸ¨shader, cLoc, cv2, rf.shaderUniformDataType.shader_uniform_vec2âŸ©
    #----------------------------------------------------------------------------------

    # Draw the saved texture and rendered julia set with shader
    # NOTE: We do not invert texture on Y, already considered inside shader
    rf.BeginShaderMode shader
      # WARNING: If FLAG_WINDOW_HIGHDPI is enabled, HighDPI monitor scaling should be considered
      # when rendering the RenderTexture2D to fit in the HighDPI scaled Window
      texture â† 1
      rf.DrawTextureExâŸ¨textureâŠ‘target, 0â€¿0, 0, 1, whiteâŸ©
    rf.EndShaderModeâŸ¨âŸ©

    {rf.DrawText ğ•¨â€¿10â€¿ğ•©â€¿30â€¿raywhite}Â¨âŸœ(30Ã—1+â†•âˆ˜â‰ )âŸshowControls âŸ¨
      "Press Mouse buttons right/left to zoom in/out and move"
      "Press KEY_F1 to toggle these controls"
      "Press KEYS [1 - 6] to change point of interest"
      "Press KEY_LEFT | KEY_RIGHT to change speed"
      "Press KEY_SPACE to stop movement animation"
      "Press KEY_R to recenter the camera"
    âŸ©
  }rl.draw._withCanvas_ black â€¢_while_ (Â¬rl.window.ShouldClose)@
  # De-Initialization
  #--------------------------------------------------------------------------------------
  rf.UnloadShader shader              # Unload shader
  rf.UnloadRenderTexture target        # Unload render texture

} rl.window._openAs "raylib [shaders] example - basic lighting"
