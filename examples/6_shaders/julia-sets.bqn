âŸ¨
  âŸ¨ReadI32 â‹„ ReadI8âŸ©â‡low
  rfâ‡raylib
  âŸ¨
    GetShaderLocation â‹„ SetShaderValue
    MemAlloc â‹„ MemFree
  âŸ©â‡raylib
  âŸ¨blackâ‹„whiteâ‹„raywhiteâŸ©â‡color
  keyâ‹„mouse
âŸ© â† rl â† â€¢Import "../../rayed.bqn"

shaderIndex â† { # Shader
  id   â‡ 0 # u     # Shader program id
  locs â‡ 1 # "*"âˆ¾i # Shader locations array (RL_MAX_SHADER_LOCATIONS)
}
# A few good julia sets
pointsOfInterest â† [
    Â¯0.348827â€¿0.607167
    Â¯0.786268â€¿0.169728
    Â¯0.8â€¿0.156
     0.285â€¿0.0
    Â¯0.835â€¿Â¯0.2321
    Â¯0.70176â€¿Â¯0.3842
]

offsetSpeedMul â† 2

startingZoom â† 0.75
zoomSpeed â† 1.01

{ğ•¤
  # Load julia set shader
  shader â† rf.LoadShader â€¢file.RealPathÂ¨ "shaders/glsl330"âŠ¸â€¢file.AtÂ¨ "default.vs"â€¿"julia_set.fs"

  # Get some required shader locations
  veiwPos â† rf.GetShaderLocation shaderâ€¿"viewPos"
  {
    locsPtr â† shaderIndex.locsâŠ‘shader
    rf.shaderLocationIndex.shader_loc_vector_view locsPtr.Write veiwPos
  }

  # Create a RenderTexture2D to be used for render to texture
  target â† rf.LoadRenderTexture rl.window.GetSize@

  # c constant to use in z^2 + c
  c â† âŠpointsOfInterest

  # Offset and zoom to draw the julia set at. (centered on screen and default size)
  offset â† 0â€¿0
  zoom â† startingZoom

  # Get variable (uniform) locations on the shader to connect with the program
  # NOTE: If uniform variable could not be found in the shader, function returns -1
  cLoc      â† GetShaderLocation shaderâ€¿"c"
  zoomLoc   â† GetShaderLocation shaderâ€¿"zoom"
  offsetLoc â† GetShaderLocation shaderâ€¿"offset"

  cv2 â† (rf.MemAlloc 8).Cast "f32"
  (â†•2)cv2.WriteÂ¨c

  zoomFloat â† (rf.MemAlloc 4).Cast "f32"
  zoomFloat.Write zoom

  offsetV2 â† (rf.MemAlloc 8).Cast "f32"
  (â†•2)offsetV2.WriteÂ¨offset

  # Upload the shader uniform values!
  rf.SetShaderValueâŸ¨shader, cLoc     , cv2      , rf.shaderUniformDataType.shader_uniform_vec2 âŸ©
  rf.SetShaderValueâŸ¨shader, zoomLoc  , zoomFloat, rf.shaderUniformDataType.shader_uniform_floatâŸ©
  rf.SetShaderValueâŸ¨shader, offsetLoc, offsetV2 , rf.shaderUniformDataType.shader_uniform_vec2 âŸ©

  incrementSpeed â† 0 # Multiplier of speed to change c value
  showControls â† 1   # Show controls



  # Main game loop
  incrementâ†0
  {ğ•Š:
    {ğ•Š:
      (â†•2)cv2.WriteÂ¨ğ•©
      SetShaderValueâŸ¨shader, cLoc, cv2, rf.shaderUniformDataType.shader_uniform_vec2âŸ©
    }Ë˜pointsOfInterest/Ëœkey.IsPressedÂ¨key.one+â†•6

    # If "R" is pressed, reset zoom and offset.
    {ğ•Š:
      zoomFloat.Write zoomâ†©startingZoom
      (â†•2)offsetV2.WriteÂ¨offsetâ†©0â€¿0
      SetShaderValueâŸ¨shader, zoomLoc  , zoomFloat, rf.shaderUniformDataType.shader_uniform_floatâŸ©
      SetShaderValueâŸ¨shader, offsetLoc, offsetV2 , rf.shaderUniformDataType.shader_uniform_vec2 âŸ©
    }âŸkey.IsPressed key.r

    incrementSpeed Ã—â†© Â¬key.IsPressed key.space # Pause animation (c change)
    showControls   â‰ â†©  key.IsPressed key.f1    # Toggle whether or not to show controls

    incrementSpeed +â†© -Â´key.IsPressed key.rightâ€¿key.left


    # If either left or right button is pressed, zoom in/out
    {ğ•Š:
      # Change zoom. If Mouse left -> zoom in. Mouse right -> zoom out
      zoom Ã—â†© {mouse.button.IsDown mouse.button.left ? zoomSpeed ; Ã·zoomSpeed}
      zoomFloat.Write zoom

      mousePos â† mouse.GetPos@

      # Find the velocity at which to change the camera. Take the distance of the mouse
      # from the center of the screen as the direction, and adjust magnitude based on the current zoom
      offsetVelocity â† (Â¯0.5+mousePosÃ·rl.window.GetSize@)Ã—offsetSpeedMulÃ—Ã·zoom

      # Apply move velocity to camera
      offset +â†© offsetVelocityÃ—rf.GetFrameTimeâŸ¨âŸ©
      (â†•2)offsetV2.WriteÂ¨offset

      # Update the shader uniform values!
      SetShaderValueâŸ¨shader, zoomLoc, zoomfloat,    rf.shaderUniformDataType.shader_uniform_floatâŸ©
      SetShaderValueâŸ¨shader, offsetLoc, offsetV2, rf.shaderUniformDataType.shader_uniform_vec2âŸ©
    }âŸâŠ¢ âˆ¨Â´mouse.button.IsDown mouse.button.leftâ€¿mouse.button.right

    # Increment c value with time
    dc â† (rf.GetFrameTimeâŸ¨âŸ©)Ã—incrementSpeedÃ—0.0005
    c +â†© dc
    (â†•2)cv2.WriteÂ¨c
    SetShaderValueâŸ¨shader, cLoc, cv2, rf.shaderUniformDataType.shader_uniform_vec2âŸ©
    #----------------------------------------------------------------------------------

    # Draw
    #----------------------------------------------------------------------------------
    # Using a render texture to draw Julia set
    {ğ•Š:
      # Draw the saved texture and rendered julia set with shader
      # NOTE: We do not invert texture on Y, already considered inside shader
      {ğ•Š:
        # WARNING: If FLAG_WINDOW_HIGHDPI is enabled, HighDPI monitor scaling should be considered
        # when rendering the RenderTexture2D to fit in the HighDPI scaled Window
        texture â† 1
        rf.DrawTextureExâŸ¨textureâŠ‘target, 0â€¿0, 0, 1, whiteâŸ©
      } rl.draw._withShader shader

      {rf.DrawText ğ•¨â€¿10â€¿ğ•©â€¿30â€¿raywhite}Â¨âŸœ(30Ã—1+â†•âˆ˜â‰ )âŸshowControls âŸ¨
        "Press Mouse buttons right/left to zoom in/out and move"
        "Press KEY_F1 to toggle these controls"
        "Press KEYS [1 - 6] to change point of interest"
        "Press KEY_LEFT | KEY_RIGHT to change speed"
        "Press KEY_SPACE to stop movement animation"
        "Press KEY_R to recenter the camera"
      âŸ©
    } rl.draw._withCanvasâŸœblack @

  } â€¢_while_ (Â¬rl.window.ShouldClose)@
  # De-Initialization
  #--------------------------------------------------------------------------------------
  rf.UnloadShader shader              # Unload shader
  rf.UnloadRenderTexture target       # Unload render texture
  MemFreeÂ¨ cv2â€¿zoomFloatâ€¿offsetV2

} rl.window._openAs "raylib [shaders] example - basic lighting"
