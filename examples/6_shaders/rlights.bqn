âŸ¨
  âŸ¨ReadI32 â‹„ ReadI8âŸ©â‡low
  rfâ‡rayffi
  âŸ¨
    GetShaderLocation â‹„ SetShaderValueRaw â‹„ SetShaderValue
    MemAlloc â‹„ MemFree
    âŸ¨
      SHADER_UNIFORM_INT â‹„ SHADER_UNIFORM_VEC3 â‹„ SHADER_UNIFORM_Vec4
    âŸ©â‡shaderUniformDataType
  âŸ©â‡rayffi
âŸ© â† rl â† â€¢Import "../../raylib.bqn"

# Light data
light â‡ '{'âˆ¾'}'Â«âˆ¾','âˆ¾Â¨âŸ¨
  "i32"    # type
  "i8"     # enabled
  "[3]f32" # position
  "[3]f32" # target
  "[4]u8"  # color
  "f32"    # attenuation
  
  # Shader locations
  "i32" # enabledLoc
  "i32" # typeLoc
  "i32" # positionLoc
  "i32" # targetLoc
  "i32" # colorLoc
  "i32" # attenuationLoc
âŸ©
lightIndex â‡ {
  type        â‡ 0
  enabled     â‡ 1
  position    â‡ 2
  target      â‡ 3
  color       â‡ 4
  attenuation â‡ 5
  
  # Shader locations
  enabledLoc     â‡ 6
  typeLoc        â‡ 7
  positionLoc    â‡ 8
  targetLoc      â‡ 9
  colorLoc       â‡ 10
  attenuationLoc â‡ 11
}


# Light type
lighttype â‡ {
  light_directional â‡ 0,
  light_point â‡ 1
}

CreateLight â‡ # Create a light and get shader locations
UpdateLightValues â‡ # Send light properties to shader

max_lights  â‡ 4    # Max dynamic lights supported by shader
lightsCount â† 0    # Current amount of created lights

# Create a light and get shader locations
CreateLight â† {ğ•Štypeâ€¿positionâ€¿targetâ€¿colorâ€¿shader: # i v3 v3 Color Shader
  ("You can't have more than "âˆ¾(â€¢Repr maxLights)âˆ¾" lights")!lightsCount<maxLights

  GetShaderLoc â† GetShaderLocation shaderâ‹ˆ"lights["âˆ¾(â€¢Repr lightsCount)âˆ¾"]."âˆ¾âŠ¢

  {ğ•Š:lightsCount+â†©1}âŠ¸âŠ¢ shaderâŠ¸UpdateLightValuesâŠ¸âŠ¢âŸ¨
    type     # type
    1        # enabled
    position # position
    target   # target
    color    # color
    0        # attenuation
  
    # Shader locations
    # NOTE: Lighting shader naming must be the provided ones
    GetShaderLoc "enabled"
    GetShaderLoc "type"
    GetShaderLoc "position"
    GetShaderLoc "target"
    GetShaderLoc "color"
    0 # attenuationLoc
  âŸ©
}

# Send light properties to shader
# NOTE: Light shader locations should be available 

UpdateLightValues â† {shaderğ•ŠâŸ¨
    # Send to shader light enabled state and type
    type
    enabled
    position
    target
    color
    attenuation
    enabledLoc
    typeLoc
    positionLoc
    targetLoc
    colorLoc
    attenuationLoc
  âŸ©:

  F32ToI8 â† (@â€¢FFI"*:i8"â€¿"memcpy"â€¿"&i8"â€¿"*f32"â€¿"u64"){1âŠ‘ğ”½âŸ¨(4Ã—â‰ ğ•©)â¥Š0, ğ•©, 4Ã—â‰ ğ•©âŸ©}
  {
    ptr â† MemAlloc 4
    âŸ¨typeâŸ© ReadI32 ptr
    rf.SetShaderValueâŸ¨shader, typeLoc    ,ptr , SHADER_UNIFORM_INT âŸ©
  }
  {
    ptr â† MemAlloc 1
    âŸ¨enabledâŸ© Readi8 ptr
    SetShaderValueâŸ¨shader, enabledLoc ,ptr , SHADER_UNIFORM_INT âŸ©
  }
  {
    # [3]f32
    ptr â† MemAlloc 4Ã—3 
    (F32ToI8 position) ReadI8 ptr
    SetShaderValueâŸ¨shader, positionLoc, ptr, SHADER_UNIFORM_VEC3âŸ© # Send to shader light position values
  }
  {
    ptr â† MemAlloc 4Ã—3
    (F32ToI8 target) ReadI8 ptr
    SetShaderValueâŸ¨shader, targetLoc, ptr, SHADER_UNIFORM_VEC3âŸ© # Send to shader light target position values
  }
  {
    ptr â† MemAlloc 4Ã—4
    (F32ToI8 colorÃ·255) ReadI8 ptr
    SetShaderValueâŸ¨shader, colorLoc, ptr, SHADER_UNIFORM_VEC4âŸ© # Send to shader light color values
  }
  âŸ¨
    # Send to shader light enabled state and type
    type
    enabled
    position
    target
    color
    attenuation
    enabledLoc
    typeLoc
    positionLoc
    targetLoc
    colorLoc
    attenuationLoc
  âŸ©
}