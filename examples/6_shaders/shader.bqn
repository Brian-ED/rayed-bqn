# /*******************************************************************************************
# *
# *   raylib [shaders] example - basic lighting
# *
# *   NOTE: This example requires raylib OpenGL 3.3 or ES2 versions for shaders support,
# *         OpenGL 1.1 does not support shaders, recompile raylib to OpenGL 3.3 version.
# *
# *   NOTE: Shaders used in this example are #version 330 (OpenGL 3.3).
# *
# *   Example originally created with raylib 3.0, last time updated with raylib 4.2
# *
# *   Example contributed by Chris Camacho (@codifies) and reviewed by Ramon Santamaria (@raysan5)
# *
# *   Example licensed under an unmodified zlib/libpng license, which is an OSI-certified,
# *   BSD-like license that allows static linking with closed source software
# *
# *   Copyright (c) 2019-2024 Chris Camacho (@codifies) and Ramon Santamaria (@raysan5)
# *
# ********************************************************************************************/

P â† â€¢term.Flushâˆ˜@âˆ˜â€¢ShowâŠ¸âŠ¢

# depending on rlgl version, you can set this to 100, 120, and 330
glslVersion â† 330

âŸ¨
  color, window, draw, low, key
  rfâ‡rayffi, rmâ‡raymath
âŸ© â† rl â† â€¢Import "../../raylib.bqn"
rlights â† â€¢Import "rlights.bqn"

cameraIndex â† {
  position   â‡ 0 # Camera position
  target     â‡ 1 # Camera target it looks-at
  up         â‡ 2 # Camera up vector (rotation over its axis)
  fovy       â‡ 3 # Camera field-of-view aperture in Y (degrees) in perspective, used as near plane width in orthographic
  projection â‡ 4 # Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
}

shaderIndex â† { # Shader
  id   â‡ 0 # u     # Shader program id
  locs â‡ 1 # "*"âˆ¾i # Shader locations array (RL_MAX_SHADER_LOCATIONS)
}

modelIndex â† { # Model, meshes, materials and animation data
  transform     â‡ 0 # matrix         # Local transform matrix
  meshCount     â‡ 1 # i              # Number of meshes
  materialCount â‡ 2 # i              # Number of materials
  meshes        â‡ 3 # "*"âˆ¾mesh       # Meshes array
  materials     â‡ 4 # "*"âˆ¾material   # Materials array
  meshMaterial  â‡ 5 # "*"âˆ¾i          # Mesh material number
  boneCount     â‡ 6 # i              # Number of bones
  bones         â‡ 7 # "*"âˆ¾boneInfo   # Bones information (skeleton)
  bindPose      â‡ 8 # "*"âˆ¾transform  # Bones base transformation (pose)
}

materialIndex â‡ âŸ¨ # Material, includes shader and maps
  shader â‡ 0 # shader          # Material shader
  maps   â‡ 1 # "*"âˆ¾materialMap # Material maps array (MAX_MATERIAL_MAPS)
  params â‡ 2 # "[4]"âˆ¾f         # Material generic parameters (if required)
âŸ©

#------------------------------------------------------------------------------------
# Program main entry point
#--------------------------------------------------------------------------------------

rf.SetConfigFlags rf.configFlags.flag_msaa_4x_hint  # Enable Multi Sampling Anti Aliasing 4x (if available)

# sets window size to half the monitor size
window.SetSize 0.5

{ğ•¤
  # Define the camera to look into our 3d world
  camera â† âŸ¨
    2â€¿4  â€¿6 # Camera position
    0â€¿0.5â€¿0 # Camera looking at point
    0â€¿1  â€¿0 # Camera up vector (rotation towards target)
    45      # Camera field-of-view Y
    rf.cameraProjection.camera_perspective # Camera projection type
  âŸ©

  # Load plane model from a generated mesh
  model â† rf.LoadModelFromMesh rf.GenMeshPlane 10â€¿10â€¿3â€¿3
  cube  â† rf.LoadModelFromMesh rf.GenMeshCube  2 â€¿4 â€¿2

  # Load basic lighting shader
  shader â† rf.LoadShader "vs"â€¿"fs"âˆ¾ËœÂ¨<"shaders/glsl"âˆ¾(â€¢Repr glslVersion)âˆ¾"/lighting."

  # Get some required shader locations
  {
    locsPtr â† shaderIndex.locsâŠ‘shader
    movedPtr â† rf.shaderLocationIndex.shader_loc_vector_view low.MovePtr ğ•©
    movedPtr low.ReadI32 â‹ˆrf.GetShaderLocation shaderâ€¿"viewPos"
  }
  # Ambient light level (some basic lighting)
  ambientLoc â† rf.GetShaderLocation shaderâ€¿"ambient"
  
  F32ToI8 â† (@â€¢FFI"*:i8"â€¿"memcpy"â€¿"&i8"â€¿"*f32"â€¿"u64"){1âŠ‘ğ”½âŸ¨(4Ã—â‰ ğ•©)â¥Š0, ğ•©, 4Ã—â‰ ğ•©âŸ©}
  {
    ptr â† rf.MemAlloc 4Ã—4
    (F32ToI8 4â¥Š1) low.ReadI8 ptr
    rf.SetShaderValueâŸ¨shader, ambientLoc, ptr, rf.shaderUniformDataType.shader_uniform_vec4âŸ©
  }

  # Assign out lighting shader to model
  {
    matsPtr â† modelIndex.materialsâŠ‘model
    firstMatPtr â† 0 low.MovePtr matsPtr
    # write each shader value
    âŸ¨(2â‹†32){ğ•¨âŠ¸|âŒ¾((ğ•¨Ã·2)âŠ¸+)ğ•©} shaderIndex.idâŠ‘shaderâŸ© low.ReadI32 firstMatPtr
    atLocsPtr â† 8 low.MovePtr firstMatPtr
    
    shaderPtr â† shaderIndex.locsâŠ‘shader
    shaderPtr low.ReadI8 atLocsPtr
  }
  {
    matsPtr â† modelIndex.materialsâŠ‘cube
    firstMatPtr â† 0 low.MovePtr matsPtr
    âŸ¨(2â‹†32){ğ•¨âŠ¸|âŒ¾((ğ•¨Ã·2)âŠ¸+)ğ•©} shaderIndex.idâŠ‘shaderâŸ© low.ReadI32 firstMatPtr
    atLocsPtr â† 8 low.MovePtr firstMatPtr
    
    shaderPtr â† shaderIndex.locsâŠ‘shader
    shaderPtr low.ReadI8 atLocsPtr
  }

  # Create lights
  lights â† rlights.CreateLightÂ¨âŸ¨
    âŸ¨rlights.lightType.light_point, Â¯2â€¿1â€¿Â¯2, 0â€¿0â€¿0, color.yellow, shaderâŸ©
    âŸ¨rlights.lightType.light_point,  2â€¿1â€¿ 2, 0â€¿0â€¿0, color.red   , shaderâŸ©
    âŸ¨rlights.lightType.light_point, Â¯2â€¿1â€¿ 2, 0â€¿0â€¿0, color.green , shaderâŸ©
    âŸ¨rlights.lightType.light_point,  2â€¿1â€¿Â¯2, 0â€¿0â€¿0, color.blue  , shaderâŸ©
  âŸ©
  #--------------------------------------------------------------------------------------

  # Main game loop
  {ğ•¤
    # Update
    #----------------------------------------------------------------------------------
    âŸ¨âŸ¨cameraâŸ©âŸ© â†© rf.UpdateCameraRef âŸ¨â‹ˆcameraâ‹„rf.cameraMode.camera_orbitalâŸ©

    # Update the shader with the camera view vector (points towards { 0.0f, 0.0f, 0.0f })
    cameraPos â† cameraIndex.positionâŠ‘camera
    âŸ¨locâŸ© â† 1 low.MakeI32 (4Ã—rf.shaderLocationIndex.shader_loc_vector_view)low.MovePtr shaderIndex.locsâŠ‘shader

    rf.SetShaderValueRawâŸ¨shader, loc, F32ToI8 cameraPos, rf.shaderUniformDataType.shader_uniform_vec3âŸ©

    # Check key inputs to enable/disable lights
    lights {
      (rf.IsKeyPressed ğ•©) Â¬âŒ¾(rlights.lightIndex.enabledâŠ¸âŠ‘)âˆ˜âŠ¢âŸâŠ£ğ•¨
    }Â¨â†© âŸ¨  key.y â‹„ key.r â‹„ key.g â‹„ key.b âŸ©
    
    # Update light values (actually, only enable/disable them)
    shaderâŠ¸rlights.UpdateLightValuesÂ¨ lights
    #----------------------------------------------------------------------------------

    # Draw
    #----------------------------------------------------------------------------------
    {ğ•¤
      {ğ•¤
        rf.DrawModelâŸ¨model, 0â€¿0â€¿0, 1, color.whiteâŸ©
        rf.DrawModelâŸ¨cube , 0â€¿0â€¿0, 1, color.whiteâŸ©

        # Draw spheres to show where the lights are
        {rlights.lightIndex.enabledâŠ‘ğ•©?
          rf.DrawSphereEx   âŸ¨rlights.lightIndex.positionâŠ‘ğ•©, 0.2, 8, 8, rlights.lightIndex.colorâŠ‘ğ•©âŸ©
        ; rf.DrawSphereWiresâŸ¨rlights.lightIndex.positionâŠ‘ğ•©, 0.2, 8, 8, âŒˆ0.3âŠ¸Ã—âŒ¾(3âŠ¸âŠ‘)rlights.lightIndex.colorâŠ‘ğ•©âŸ©
        }Â¨lights
        rf.DrawGrid 10â€¿1
      } rl.draw._in3D camera

      rf.DrawFPS 10â€¿10

      rf.DrawTextâŸ¨"Use keys [Y][R][G][B] to toggle lights", 10, 40, 20, color.darkgrayâŸ©

    } draw._withCanvas_ color.raywhite @
    #----------------------------------------------------------------------------------
  } â€¢_While_(Â¬window.ShouldClose) @

  # De-Initialization
  #--------------------------------------------------------------------------------------
  rf.UnloadModel  model    # Unload the model
  rf.UnloadModel  cube     # Unload the model
  rf.UnloadShader shader   # Unload shader

} window._openAs "raylib [shaders] example - basic lighting"

