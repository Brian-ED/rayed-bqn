
# SPDX-License-Identifier: AGPL-3.0-or-later
# SPDX-FileCopyrightText: 2022 Rampoina <rampoina@protonmail.com>
#
# Sokobqn
# The level is a 2d matrix of lists (tiles)
# Each list contains the objects of the game:
# 0: floor, 1: player, 2: box, 3: goal, 4: wall
# 4: player on goal, 5: box on goal
#
# Example:                              ASCII:
# â”Œâ”€                                    â”Œâ”€
# â•µ âŸ¨ 4 âŸ© âŸ¨ 4 âŸ©   âŸ¨ 4 âŸ©   âŸ¨ 4 âŸ© âŸ¨ 4 âŸ©   â•µ"#####
#   âŸ¨ 4 âŸ© âŸ¨ 1 0 âŸ© âŸ¨ 2 0 âŸ© âŸ¨ 0 âŸ© âŸ¨ 4 âŸ©     #@*.#
#   âŸ¨ 4 âŸ© âŸ¨ 4 âŸ©   âŸ¨ 4 âŸ©   âŸ¨ 4 âŸ© âŸ¨ 4 âŸ©     #####"
#                                     â”˜         â”˜
movesâ†âŸ¨0â€¿0âŸ© # list of moves, each move is a direction, we start without moving
charsâ†" @$.+*#" # legal characters


SplitOnEmptyâ†{ğ•©âŠ”Ëœ(âŠ¢-Ëœ+`Ã—Â¬)0=â‰ Â¨ğ•©}
Ascii2Matrixâ†{(âŠ‘charsâŠğ•©)âŠ‘âŸ¨â‰0,1â€¿0,2â€¿0,â‰3,1â€¿3,2â€¿3,â‰6âŸ©}Â¨(âŠ¢â†‘ËÂ·â‰âŸœÂ¬2+â‰¢)

# ğ•¨ Tiles ğ•© | ğ•©: object coordinate (3â€¿1) |  ğ•¨: direction vector (Â¯1â€¿0)
# result: âŸ¨ âŸ¨ 3 1 âŸ© âŸ¨ 2 1 âŸ© âŸ¨ 1 1 âŸ© âŸ©
# returns 3 tiles in the specified direction from the
Tilesâ†{âŸ¨ğ•©,ğ•©+ğ•¨,ğ•©+2Ã—ğ•¨âŸ©} # given object (including itself)

Playerâ†{âŠ‘/â—‹â¥ŠâŸœ(â†•â‰¢)1â·âŠ‘Â¨ğ•©} # Player ğ•© | ğ•©:level | returns the coordinate of the [P]layer

# Move ğ•© | ğ•©: âŸ¨âŸ¨1,0âŸ©,âŸ¨0âŸ©âŸ© (2 tiles) | result: âŸ¨âŸ¨0âŸ©,âŸ¨1,0âŸ©âŸ©
# Move the first object in the first tile to the second tile. 
# Only move Player/Box -> Floor/Goal
# the second tile can't be a box because we moved it previously
# if it is it means that the box was unmovable (next to a wall) so we do nothing
Moveâ†{aâ€¿b:âŸ¨1â†“a,(âŠ‘a)âˆ¾bâŸ©}âŸ{âˆ¨Â´(â¥Š1â€¿2â‰âŒœ0â€¿3)â‰¡âŒœ<âŠ‘Â¨ğ•©}

# Push ğ•© | ğ•©: âŸ¨âŸ¨1,0âŸ©,âŸ¨2,0âŸ©,âŸ¨0,0)âŸ© (3 tiles) | result: âŸ¨âŸ¨0âŸ©,âŸ¨1,0âŸ©,âŸ¨2,0)âŸ©
# Given 3 tiles try to [P]ush the second tile (possible box) 
# and afterwards try to move the first one (player) if possible
Pushâ†MoveâŒ¾(2â†‘âŠ¢)MoveâŒ¾(1â†“âŠ¢) 

Sâ†{PushâŒ¾((ğ•¨ Tiles Player ğ•© )âŠ¸âŠ‘)ğ•©} # ğ•¨ S ğ•© | ğ•¨: direction | ğ•©:level | Step the game
Drawâ†{charsâŠËœ+Â´Â¨ğ•¨ SÂ´ âŒ½ğ•©} # ğ•¨ Draw ğ•© | ğ•¨: levels | ğ•©: moves | Draw the game in ASCII
Wâ†{(2â‰¡Â¨âŠ‘Â¨ğ•©) =â—‹(+Â´â¥Š) (<2â€¿3)â‰¡Â¨ğ•©} # W ğ•© | ğ•©: level | [W]in condition
Nâ†{movesâ†©movesâˆ¾<ğ•©}
Undoâ†{ğ•Š:movesâ†©(-1<â‰ )âŠ¸â†“moves}
While â† {ğ•¨{ğ•Šâˆ˜ğ”¾âŸğ”½ğ•©}ğ•©@}Â´

# Main loop
levelsâ†Ascii2MatrixÂ¨>Â¨SplitOnEmptyâ€¢FLines "levels.txt" # Load file containing levels
currentLevelâ†0
â€¢term.RawMode 1 # set terminal to raw mode
â€¢Out "[?25l[2J[H" # Cursor to origin, hide it and clear screen
clearâ†""
While {ğ•¤â‹„currentLevel<â‰ levels}â€¿{ğ•¤ # Loop until the user wins
  â€¢Out "[H" # Cursor to origin
  â€¢Out "Level: "âˆ¾â€¢Repr 1+currentLevel
  â€¢Out "7"  # Save cursor position
  â€¢Out "Controls: (hjkl) to move, u to undo, r to reset level"
  â€¢OutË˜ (currentLevelâŠ‘levels) Draw moves
  keyâ†â€¢term.CharB @
  {ğ•¤â‹„N âŠ‘("hjkl"=key)/âŸ¨0â€¿Â¯1,1â€¿0,Â¯1â€¿0,0â€¿1âŸ©}âŸ(âŠ‘keyâˆŠ"hjkl")@
  {ğ•¤â‹„Undo @}âŸ(key='u')@
  {ğ•¤â‹„â€¢Out "[?12l[?25h"â‹„â€¢Exit 0}âŸ(key='q')@
  {ğ•¤â‹„movesâ†©âŸ¨0â€¿0âŸ©}âŸ(key='r')@
  {ğ•¤â‹„clearâ†©"[2J"}âŸ(((1âŠ¸+>â—‹(âŒŠ1+10â‹†â¼1âŒˆâŠ¢)âŠ¢)Â¯1+â‰ moves)âˆ§key='u')@
  â€¢Out "8" # Restore cursor position
  {ğ•¤â‹„â€¢Out clearâˆ¾"Controls: (hjkl) to move, u to undo, r to reset level"}âŸ(âŠ‘keyâˆŠ"hjkluqr")@
  {ğ•¤â‹„â€¢Out "Invalid key: (hjkl) to move, u to undo, r to reset level"}âŸ(Â¬âŠ‘keyâˆŠ"hjkluqr")@
  â€¢OutË˜ (currentLevelâŠ‘levels) Draw moves
  â€¢Out "Moves: "âˆ¾â€¢Repr Â¯1+â‰ moves
  {ğ•¤â‹„â€¢Out "[H"â‹„currentLevelâ†©currentLevel+1â‹„movesâ†©âŸ¨0â€¿0âŸ©}âŸ(W (currentLevelâŠ‘levels) SÂ´âŒ½moves)@
}
â€¢Out "Well played, you win!"
â€¢Out "[?12l[?25h"
