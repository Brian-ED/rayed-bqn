âŸ¨
  GetCameraMatrix2D â‹„ GetWorldToScreenEx â‹„ GetWorldToScreen
âŸ©â‡
âŸ¨MP â‹„ Rot2Dâ‡MatrixRotate2DâŸ© â† rm â† â€¢Import "raymath.bqn"
rf â† â€¢Import "../ffi/raylib.bqn"
âŸ¨NeedsWindowâŸ© â† â€¢Import "global.bqn"
âŸ¨rlgl â‹„ âŸ¨perspectiveâ‹„orthographicâŸ©â‡cameraProjectionâŸ© â† â€¢Import "constants.bqn"

# Get camera 2d transform matrix
  # The camera in world-space is set by
  #   1. Move it to target
  #   2. Rotate by -rotation and scale by (1/zoom)
  #      When setting higher scale, it's more intuitive for the world to become bigger (= camera become smaller),
  #      not for the camera getting bigger, hence the invert. Same deal with rotation.
  #   3. Move it by (-offset);
  #      Offset defines target transform relative to screen, but since we're effectively "moving" screen (camera)
  #      we need to do it into opposite direction (inverse transform)
    
  # Having camera transform in world-space, inverse of it gives the modelview transform.
  # Since (A*B*C)' = C'*B'*A', the modelview is
  #   1. Move to offset
  #   2. Rotate and Scale
  #   3. Move by -target

# Get camera 2d transform matrix
GetCameraMatrix2D â† {ğ•Šoffsetâ€¿targetâ€¿rotationâ€¿zoom: # camera2d
  translationâ€¿origin â† rm.MatrixTranslateÂ¨âˆ¾âŸœ0Â¨offsetâ‹ˆ-target
  origin MP translation MPËœ rm._ToDim_ 4 zoomÃ—Rot2D rm.deg2radÃ—rotation
}

# Get the screen space position from a 3d world space position
GetWorldToScreen â† {ğ•Špositionâ€¿camera: # v3â€¿cam3d
  NeedsWindow@
  screenPos â† GetWorldToScreenExâŸ¨position, camera, rf.GetScreenWidthâŸ¨âŸ©, rf.GetScreenHeightâŸ¨âŸ©âŸ©
}

# Get size position for a 3d world space position (useful for texture drawing)
# ScreenSize is optional, if not given it's calculated automatically
GetWorldToScreenEx â† {posâ€¿âŸ¨positionâ‹„targetâ‹„upâ‹„fovyâ‹„projectionâŸ©â€¿widthâ€¿height:

  # Calculate projection matrix (from perspective instead of frustum
  matProj â† {
    0: # perspective
      # Calculate projection matrix from perspective
      rm.MatrixPerspectiveâŸ¨fovyÃ—rm.deg2rad, widthÃ·height, rlgl.cull_distance_near, rlgl.cull_distance_farâŸ©
  ;
    1: # orthographic
      top â† fovyÃ·2
      right â† topÃ—widthÃ·height

      # Calculate projection matrix from orthographic
      rm.MatrixOrthoâŸ¨-right, right, -top, top, rlgl.cull_distance_near, rlgl.cull_distance_farâŸ©
  } projection

  # Calculate view matrix from camera look at
  matView â† rm.MatrixLookAtâŸ¨position, target, upâŸ©

  # Transform world position to view then Transform result to projection (clip space position)
  worldPos â† matProj MPËœ matView MPËœ posâˆ¾1

  # Calculate normalized device coordinates (inverted y)
  # Calculate 2d screen position vector
  widthâ€¿heightÃ—2Ã·Ëœ1+-âŒ¾(1âŠ¸âŠ‘)2â†‘worldPos
}


