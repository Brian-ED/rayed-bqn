âŸ¨
  # generation
  GenGradientLinear â‹„ GenGradientSquare
  GenGradientRadial â‹„ GenChecked
  GenColor
  
  # Raylib image format functions
  _AsRayImg â‹„ Copy â‹„ ToArr
  LoadFromArr â‹„ Unload
  GetPixelDataSize # pixel size of the raylib format

  # Miscellaneous
  GetAlphaBorder
  FromFile
  FromTexture
  Crop
  CropAlpha
âŸ©â‡

# No function unloads or mutates input image, except Unload

âŸ¨pixelFormatâŸ© â† â€¢Import "constants.bqn"
âŸ¨NeedsWindowâŸ© â† â€¢Import "global.bqn"
raylib â† â€¢Import "../ffi/raylib.bqn"
low    â† â€¢Import "low.bqn"

allFormats â† (â€¢ns.GetÂ¨â‹âŠ¸âŠâŠ¢)âŸœâ€¢ns.Keys pixelFormat

# Get pixel data size in bytes for certain format
# NOTE: Size can be requested for Image or Texture data
# image.GetPixelDataSize
GetPixelDataSize â† {formatğ•Šsize:
  bpp â† { # Bits per pixel
    ğ•©â‰¡pixelFormat.uncompressed_grayscale? 8;
    âŠ‘ğ•©âˆŠâŸ¨pixelFormat.uncompressed_gray_alpha
        pixelFormat.uncompressed_r5g6b5
        pixelFormat.uncompressed_r5g5b5a1
        pixelFormat.uncompressed_r4g4b4a4 âŸ©? 16;
    ğ•©â‰¡pixelFormat.uncompressed_r8g8b8a8     ? 32;
    ğ•©â‰¡pixelFormat.uncompressed_r8g8b8       ? 24;
    ğ•©â‰¡pixelFormat.uncompressed_r32          ? 32;
    ğ•©â‰¡pixelFormat.uncompressed_r32g32b32    ? 32Ã—3;
    ğ•©â‰¡pixelFormat.uncompressed_r32g32b32a32 ? 32Ã—4;
    ğ•©â‰¡pixelFormat.uncompressed_r16          ? 16;
    ğ•©â‰¡pixelFormat.uncompressed_r16g16b16    ? 16Ã—3;
    ğ•©â‰¡pixelFormat.uncompressed_r16g16b16a16 ? 16Ã—4;
    âŠ‘ğ•©âˆŠâŸ¨pixelFormat.compressed_dxt1_rgb
        pixelFormat.compressed_dxt1_rgba
        pixelFormat.compressed_etc1_rgb
        pixelFormat.compressed_etc2_rgb
        pixelFormat.compressed_pvrt_rgb
        pixelFormat.compressed_pvrt_rgbaâŸ©? 4;
    âŠ‘ğ•©âˆŠâŸ¨pixelFormat.compressed_dxt3_rgba
        pixelFormat.compressed_dxt5_rgba
        pixelFormat.compressed_etc2_eac_rgba
        pixelFormat.compressed_astc_4x4_rgbaâŸ©? 8;
    ğ•©â‰¡pixelFormat.compressed_astc_8x8_rgba   ? 2;
    0
  }format

  dataSize â† 8Ã·ËœbppÃ—size  # Total data size in bytes

  # Most compressed formats works on 4x4 blocks,
  # if texture is smaller, minimum dataSize is 8 or 16
  datasizeâ€¿8â€¿16â€¿datasizeâŠ‘ËœâŠ‘formatâ‹ËœâŸ¨
    pixelFormat.compressed_dxt1_rgb
    pixelformat.compressed_dxt3_rgba
    pixelformat.compressed_astc_8x8_rgba
  âŸ©
}

# Copy a raylib image to a new image
# image.Copy
Copy â† {ğ•ŠdataPtrâ€¿oldWidthâ€¿oldHeightâ€¿mipmapsâ€¿format:
  # 1âŒˆ is security check for NPOT textures
  mapSizes â† Ã—Â´Â¨1âŒˆâŒŠâˆ˜Ã·âŸœ2âŸ(â†•mipmaps) oldHeightâ€¿oldWidth
  size â† +Â´formatâŠ¸GetPixelDataSizeÂ¨mapSizes
  ptr â† (raylib.MemAlloc size).Cast "i8"
  ptr.Write (dataPtr.Cast "i8").Read size
  ptrâ€¿oldWidthâ€¿oldHeightâ€¿mipmapsâ€¿format
}
# image.ToArr
ToArr â† {ğ•ŠraylibImg:
  changeFormatâ†pixelFormat.uncompressed_r8g8b8a8â‰¢4âŠ‘ğ•©
  dataptrâ€¿widthâ€¿hightâ€¿Â·â€¿format â† {
    âŠ‘âŠ‘raylib.ImageFormatRef âŸ¨Copy ğ•©âŸ©â€¿pixelFormat.uncompressed_r8g8b8a8
  }âŸchangeFormat ğ•©
  "Invalid image format"!Ã—format
  bqnImg â† hightâ€¿widthâ€¿4(âŠ£â¥Š256|Ã—Â´âŠ¸low.Make)dataPtr     # 256|ğ•© is converting from int to uint 
  raylib.MemFreeâŸchangeFormat dataPtr
  bqnImg
}
# image.LoadFromArr
LoadFromArr â† {ğ•Šimg:
  NeedsWindow@
  l low.Read ptrâ†raylib.MemAllocâ‰ lâ†Â¯128+256|128+â¥Šâ‰ğ•© # TODO this transpose here might be wrong
  ptr<âŠ¸âˆ¾(âŒ½âˆ¾âŸœ4â¼â‰¢ğ•©)âˆ¾1â€¿pixelFormat.uncompressedr8g8b8a8
}
# image.Unload
Unload â† {ğ•Šimg:
  imgDataIndex â† 0
  raylib.MemFree imgDataIndexâŠ‘ğ•©
  @
}
# image.FromFile
FromFile â† {ğ•ŠstrPath:
  NeedsWindow@
  !â€¢file.Existsğ•©
  (UnloadâŠ¢ToArr) raylib.LoadImageğ•©
}

GifToImages â† {ğ•Šchars:
  "GIF"â‰¡3â†‘ğ•©?
    imageâ€¿âŸ¨framesâŸ© â† raylib.LoadImageAnimFromMemoryRef âŸ¨".gif"â‹„charsâ‹„â‰ charsâ‹„âŸ¨0âŸ©âŸ© # fileType fileData dataSize frames # Load image sequence from memory buffer
    dataptrâ€¿widthâ€¿hightâ€¿Â·â€¿formatâ†image
    widthâ€¿hightâ€¿4â€¿frames(âŠ£â¥Š256|Ã—Â´âŠ¸low.Make)dataPtr     # 256|ğ•© is converting from int to uint 
  ;
  @
}

# image._asRayImg
_asRayImg â† {(UnloadâŠ¢ğ”½)LoadFromArr}

#----------------------------------------------------------------------------------
# Image generation
#----------------------------------------------------------------------------------

# image.GenColor
GenColor â† âˆ¾âŸœ4âŠ¸â¥ŠËœ

# image.GenChecked
GenChecked â† {ğ•¨âŠËœâ‰ âŒœÂ´2|â†•Â¨ğ•©}

# Generate image: linear gradient
# The direction value specifies the direction of the gradient as unit vector
# image.GenGradientLinear
GenGradientLinear â† {[startâ‹„end]ğ•Šsizeâ€¿dir:
  â‰start+âŒŠ(end-start)Ã—âŒœ+âŒœËœÂ´(â†•Â¨size)Ã—dirÃ·0âŠ¸=âŠ¸+Â¯1+Â´dirÃ—size
}

# Generate image: square gradient
# image.GenGradientSquare
GenGradientSquare â† {[innerâ‹„outer]ğ•Šsize:
  # past impl  â‰âŒŠ((outerÃ—âŒœâŠ¢)+innerÃ—âŒœÂ¬) âŒˆË|1+(2Ã·Ëœ0âŠ¸=âŠ¸+1-size)Ã·Ëœâ‰â¼>â†•size
  â‰inner + âŒŠ(outer-inner)Ã—âŒœ âŒˆâŒœÂ´ |Â¯1+ (â†•Â¨size) Ã· 0âŠ¸=âŠ¸+ 2Ã·Ëœsize-1 # dzaima helped a lot :)
}

# Generate image: radial gradient
# image.GenGradientRadial
GenGradientRadial â† {[innerâ‹„outer]ğ•Šsizeâ€¿density:
  r â† 2Ã·ËœâŒŠÂ´size
  radial â† +âŒœÂ´âŒ¾(Ã—Ëœ)(sizeÃ·2)-Ëœâ†•Â¨size # make circle
  radial-â†© rÃ—density                # resize center
  radialÃ·â†© 0âŠ¸=âŠ¸+rÃ—Â¬density          # add blur
  â‰inner + âŒŠ(outer-inner)Ã—âŒœ 1âŒŠ0âŒˆ radial # coloring 
}

#----------------------------------------------------------------------------------
# Image conversions
#----------------------------------------------------------------------------------

# Encode image data in arrays by using encode to encode into binary data by an input format,
# along with also acounting for luminocity.

# TODOs
# remember to normalize not only by gray but by all colors, depending on their bytes 
# after aproximating, turn leftover data into other colors to keep brightness the same 
# calculate leftovers (that come from shortening bit-lengths and therefore loosing information and brightness) and add them in other colors
# using _Base_, improve efficienty of images stored as ints to split it to bit components to save space.
# support compressed formats

# pixel formats for images suported:
# (kinda means it's supported but not space efficient)
# yes    : uncompressed_grayscale    â‡ 1   # 8 bit per pixel (no alpha)   
# yes    : uncompressed_gray_alpha   â‡ 2   # 8*2 bpp (2 channels)         
# kinda  : uncompressed_r5g6b5       â‡ 3   # 16 bpp                       
# yes    : uncompressed_r8g8b8       â‡ 4   # 24 bpp                       
# kinda  : uncompressed_r5g5b5a1     â‡ 5   # 16 bpp (1 bit alpha)         
# yes    : uncompressed_r4g4b4a4     â‡ 6   # 16 bpp (4 bit alpha)         
# yes    : uncompressed_r8g8b8a8     â‡ 7   # 32 bpp                       
# yes    : uncompressed_r32          â‡ 8   # 32 bpp (1 channel - float)   
# yes    : uncompressed_r32g32b32    â‡ 9   # 32*3 bpp (3 channels - float)
# yes    : uncompressed_r32g32b32a32 â‡ 10  # 32*4 bpp (4 channels - float)
# no     : compressed_dxt1_rgb       â‡ 11  # 4 bpp (no alpha)             
# no     : compressed_dxt1_rgba      â‡ 12  # 4 bpp (1 bit alpha)          
# no     : compressed_dxt3_rgba      â‡ 13  # 8 bpp                        
# no     : compressed_dxt5_rgba      â‡ 14  # 8 bpp                        
# no     : compressed_etc1_rgb       â‡ 15  # 4 bpp                        
# no     : compressed_etc2_rgb       â‡ 16  # 4 bpp                        
# no     : compressed_etc2_eac_rgba  â‡ 17  # 8 bpp                        
# no     : compressed_pvrt_rgb       â‡ 18  # 4 bpp                        
# no     : compressed_pvrt_rgba      â‡ 19  # 4 bpp                        
# no     : compressed_astc_4x4_rgba  â‡ 20  # 8 bpp                        
# no     : compressed_astc_8x8_rgba  â‡ 21  # 2 bpp                        

formatKeys â† "r"â€¿"g"â€¿"b"â€¿"a"â€¿"grayscale"
luminocityMat â† [
# r     g     b      a
  1    â€¿0    â€¿0     â€¿0  # r
  0    â€¿1    â€¿0     â€¿0  # g
  0    â€¿0    â€¿1     â€¿0  # b
  0    â€¿0    â€¿0     â€¿1  # a
  0.299â€¿0.587â€¿0.114 â€¿0  # grayscale
]

# image.FromTexture
FromTexture â‡ {ğ•Štexture:
  (UnloadâŠ¢ToArr) raylib.LoadImageFromTexture ğ•©
}

# image.Crop
Crop â† {[x1â€¿y1â‹„x2â€¿y2]ğ•Šimg:ğ•¨âŒŠËâŠ¸â†“ğ•¨âŒˆËâŠ¸â†‘ğ•©}

# Get image alpha border rectangle
# NOTE: Threshold is defined as a percentage: 0 â†’ 1
# image.GetAlphaBorder
GetAlphaBorder â† {thresholdğ•Šimage:
  (âˆ¾âŸœ4â¼â‰¢ğ•©)âŠ¸-âŒ¾(1âŠ¸âŠ)âŒŠÂ´Â¨+ËÂ¨âˆ§`Â¨â‰âˆ˜âŒ½âŸ[0â€¿1â‹„2â€¿3](ğ•¨Ã—255)â‰¥3âŠË˜Ë˜ğ•©
}

# Crop image depending on alpha value
# NOTE: Threshold is defined as a percentage: 0.0f -> 1.0f
# image.CropAlpha
CropAlpha â† {thresholdğ•Šimage:
  ğ•© CropËœ ğ•¨ GetAlphaBorder ğ•©
}

#TODO
# genImageWhiteNoise
# genImagePerlinNoise
# genImageCellular
# genImageText
# imageText
# imageTextEx
# imageToPOT
# imageAlphaClear
# imageAlphaMask
# imageAlphaPremultiply
# imageBlurGaussian
# imageKernelConvolution
# imageResize
# imageResizeNN
# imageResizeCanvas
# imageMipmaps
# imageDither
# imageFlipVertical
# imageFlipHorizontal
# imageRotate
# imageRotateCW
# imageRotateCCW
# imageColorTint
# imageColorInvert
# imageColorGrayscale
# imageColorContrast
# imageColorBrightness
# imageColorReplace
# loadImagePalette
# unloadImagePalette
# getImageAlphaBorder
# getImageColor
# imageClearBackground
# imageDrawPixel
# imageDrawPixelV
# imageDrawLine
# imageDrawLineV
# imageDrawCircle
# imageDrawCircleV
# imageDrawCircleLines
# imageDrawCircleLinesV
# imageDrawRectangle
# imageDrawRectangleV
# imageDrawRectangleRec
# imageDrawRectangleLines
# imageDraw
# imageDrawText
# imageDrawTextEx
# 
# exportImage
# exportImageToMemory
# exportImageAsCode
# 


#TESTING
#âŸ¨câ‡color,wâ‡window,dâ‡draw,mâ‡mouseâŸ©â†râ†â€¢Import "/home/brian/rayed-bqn/rayed.bqn"
#
#PerFrame â† {tex1â€¿tex2â€¿tex3â€¿fontğ•Šscrolled:
#  c.whiteâ€¿fontâ€¿30 d.Text 20â€¿20â‹ˆâ€¢Reprâˆ˜w.fps.GetâŠ¸âˆ¾" FPS"
#  {d.TextureâŸœm.GetPos c.whiteâ€¿tex1âˆ¾ğ•©âˆ¾ËœÃ·5}Â¨ğ•©+90Ã—â†•4
#  {d.TextureâŸœ(0â€¿700+m.GetPos) c.whiteâ€¿tex2âˆ¾ğ•©âˆ¾ËœÃ·5}Â¨ğ•©+90Ã—â†•4
#  {d.TextureâŸœ(0â€¿450+m.GetPos) c.whiteâ€¿tex1âˆ¾ğ•©âˆ¾ËœÃ·5}Â¨ğ•©+90Ã—â†•4
#  90|m.WheelMovedâŠ¸+ğ•©
#} d._withCanvas_ c.black
#
#r.window.SetSize 0.5â€¿0
#
#{ğ•¤
#  r.window.SetPos 1000â€¿0
#  font â† r.font.LoadBQN@
#  size â† 1000â€¿1000
#
#  img1 â† @
#  â€¢Show {img1â†©r.raylib.GenImageGradientSquareğ•©}â€¢_Timed sizeâˆ¾âŸ¨0, 255â€¿0â€¿0â€¿255, 4â¥Š255âŸ©
#  img2 â† @
#  â€¢Show {img2â†©GenGradientSquareğ•©} â€¢_Timed âŸ¨size, 255â€¿0â€¿0â€¿255, 4â¥Š255âŸ©
#  img2 LoadFromArrâ†©
#  img3 â† Copy img1
#
#  tâ€¿lâ€¿p â† r.raylib.LoadTextureFromImageÂ¨ img1â€¿img2â€¿img3
#  r.image.UnloadÂ¨img1â€¿img2â€¿img3
#
#  lâ€¿tâ€¿pâ€¿font PerFrameâ€¢_While_(Â¬w.ShouldClose) 0
#  r.texture.UnloadÂ¨tâ€¿l
#  r.font.Unload font
#} w._openAs "test"