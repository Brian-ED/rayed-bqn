# Tests are very undeveloped.
# This file may be turned into a testing directory when it gets bigger.
# Catagories are seperated by 2 newlines.

# all tests successful as of june 13. 2023

# Raymath:
Round â† {âŒŠâˆ˜+âŸœ0.5âŒ¾((10â‹†ğ•¨)âŠ¸Ã—)ğ•©}

eâ†""

!100.2131â‰¡4 Round 100.21312344123

âŸ¨MatrixRotateâŸ© â† â€¢Import "raymath.bqn"
eâ†©"MatrixRotate"
e!(â€¢Repr 5 Round MatrixRotate 0 â€¿0â€¿1â‹ˆÂ¯21) â‰¡ "4â€¿4â¥ŠÂ¯0.54773â€¿0.83666â€¿0â€¿0â€¿Â¯0.83666â€¿Â¯0.54773â€¿0â€¿0â€¿0â€¿0â€¿1â€¿0â€¿0â€¿0â€¿0â€¿1"
e!(â€¢Repr 5 Round MatrixRotate 0 â€¿1â€¿0â‹ˆ 45) â‰¡ "4â€¿4â¥Š0.52532â€¿0â€¿0.8509â€¿0â€¿0â€¿1â€¿0â€¿0â€¿Â¯0.8509â€¿0â€¿0.52532â€¿0â€¿0â€¿0â€¿0â€¿1"
e!(â€¢Repr 5 Round MatrixRotate 21â€¿3â€¿4â‹ˆ 45) â‰¡ "4â€¿4â¥Š0.97453â€¿Â¯0.0935â€¿0.20382â€¿0â€¿0.22184â€¿0.53449â€¿Â¯0.81554â€¿0â€¿Â¯0.03269â€¿0.83999â€¿0.54162â€¿0â€¿0â€¿0â€¿0â€¿1"


# raylib.bqn

âŸ¨âŸ¨_FromCenterâŸ©â‡utilsâŸ©â†â€¢Import "../raylib.bqn"
eâ†©"_FromCenter"
e!(â€¢Repr 5 Round 2âŠ¸Ã—_FromCenter[10â€¿15â‹„15â€¿20â‹„20â€¿25]) â‰¡ "3â€¿2â¥Š7.5â€¿17.5â€¿12.5â€¿22.5â€¿17.5â€¿27.5"
e!(â€¢Repr 5 Round 2âŠ¸Ã—_FromCenter[10â€¿15â€¿15â‹„15â€¿20â€¿20]) â‰¡ "2â€¿3â¥Š6.66667â€¿16.66667â€¿16.66667â€¿11.66667â€¿21.66667â€¿21.66667"





# testing (moved later to testing.bqn)
#â€¢Show 1â€¿2â€¿3 Vector3OrthoNormalize 4â€¿5â€¿6

#â€¢Show (-5+â†•4) QuaternionEquals 5+â†•4
#â€¢Show (-4+â†•4) QuaternionEquals 5+â†•4

# raylib additions
# in MatrixOrtho please put x+b in the same order as x-b
# QuaternionToAxisAngle use epsilon
# reorder MatrixRotateXYZ's z y x to x y z at the top
# in quaternioninvert it seems the first index shouldn't be negated
# useless fabsf in QuaternionSlerp

# 1âŠ¸-âŒ¾(Ã—Ëœ) â†’ (Sin Cosâ¼)
# -âŸœ1âŒ¾(Ã—Ëœ) â†’ (Cos Sinâ¼)
#Sinâ€¿Cosâ†â€¢math
#â€¢Show (Cos Sinâ¼)âŸ â€¢Show â€¢math.Cos 1
#â€¢Show â€¢math.Sin 2
#â€¢Show 1âŠ¸-âŒ¾(Ã—Ëœ)
#Sin Cosâ¼


"
for the entire message, i define   fâ¼ to be  f^-1. 
the variables f, g, and h are always functions, the rest are values

First, you define an inverse for as many primitives as you can. for example define âˆšâ¼x to be xâ‹†2 and such. with this in mind, we can deduce the inverse of functions just based on the primitives used in its code.

F(G(x)) inverted is Gâ¼(Fâ¼(x))
F(G(x, y, ...)) inverted with respect to x is Gâ¼(Fâ¼(x), y, ...)
F(G(x), G(y), ...)	inverted with respect to x is Gâ¼(Fâ¼(x, G(y), G(z), ...))
Gâ¼(F(G(x), G(y), ...))  inverted with respect to x is  Gâ¼(Fâ¼(G(x), G(y), ...))

this may be obvious, but note, if function is defined for multiple inputs like lets say f(x), and f(x, y), inverting f is still allowed and just applies to both versions.



  Also have inverses of operators (functions taking functions)

i define map(f, x, y, z...) to be [f(x1,y1,z1, ...), f(x2,y2,z2, ...), f(x3,y3,z3, ...)...] 

define f(x, y, ...) = map(g, x, y, ...)
then the inverse is  fâ¼(x, y, ...) = [gâ¼(x1, y1, ...), gâ¼(x2, y2, ...), ...]



Mod 	Inverse 	Requirements
âŸn 	âŸ(-n) 	Atomic number n; no check, like â¼

ğ”¾(ğ•©, ğ”½(ğ•¨)) 	{ğ•¨ğ”½âŠ¸(ğ”¾â¼)ğ•©}
ğ”¾(ğ•©, k) 	{kâŠ¸(ğ”¾â¼)ğ•©}

ğ•¨ğ”½âŸœğ”¾ğ•©  {ğ•¨ğ”¾â¼ğ”½â¼ğ•©} 	Dyadic case


ğ”½âŸœk 	kğ”½Ëœâ¼âŠ¢ 	Monadic case, constant k
kğ”½ğ”¾ 	ğ”¾â¼{ğ•¨ğ”½ğ”¾ğ•©}(kğ”½â¼âŠ¢) 	Constant k
ğ”½ğ”¾K 	ğ”½â¼kğ”¾Ëœâ¼âŠ¢ 	Constant k
"