# Command line variables
inFileName â† "../src/raylib.h"
outFileName â† "raylib_api.txt"
apiDefine â† "RLAPI"       # Functions define (i.e. RLAPI for raylib.h, RMDEF for raymath.h, etc.)
truncAfter â† ""           # Truncate marker (i.e. "RLGL IMPLEMENTATION" for rlgl.h)

"
    raylib API parser

    This parser scans raylib.h to get API information about defines, structs, aliases, enums, callbacks and functions.
    All data is divided into pieces, usually as strings. The following types are used for data:

     - struct DefineInfo
     - struct StructInfo
     - struct AliasInfo
     - struct EnumInfo
     - struct FunctionInfo

    CONSTRAINTS:

    This parser is specifically designed to work with raylib.h, so, it has some constraints:

     - Functions are expected as a single line with the following structure:

       <retType> <name>(<paramType[0]> <paramName[0]>, <paramType[1]> <paramName[1]>);  <desc>

       Be careful with functions broken into several lines, it breaks the process!

     - Structures are expected as several lines with the following form:

       <desc>
       typedef struct <name> {
           <fieldType[0]> <fieldName[0]>;  <fieldDesc[0]>
           <fieldType[1]> <fieldName[1]>;  <fieldDesc[1]>
           <fieldType[2]> <fieldName[2]>;  <fieldDesc[2]>
       } <name>;

     - Enums are expected as several lines with the following form:

       <desc>
       typedef enum {
           <valueName[0]> = <valueInteger[0]>, <valueDesc[0]>
           <valueName[1]>,
           <valueName[2]>, <valueDesc[2]>
           <valueName[3]>  <valueDesc[3]>
       } <name>;

       NOTE: Multiple options are supported for enums:
          - If value is not provided, (<valueInteger[i -1]> + 1) is assigned
          - Value description can be provided or not

    OTHER NOTES:

     - This parser could work with other C header files if mentioned constraints are followed.
     - This parser does not require <string.h> library, all data is parsed directly from char buffers.

    LICENSE: zlib/libpng

    raylib-parser is licensed under an unmodified zlib/libpng license, which is an OSI-certified,
    BSD-like license that allows static linking with closed source software:

    Copyright (c) 2021-2023 Ramon Santamaria (@raysan5)

**********************************************************************************************/
"
max_defines_to_parse    â† 2048 # Maximum number of defines to parse
max_structs_to_parse    â†   64 # Maximum number of structures to parse
max_aliases_to_parse    â†   64 # Maximum number of aliases to parse
max_enums_to_parse      â†   64 # Maximum number of enums to parse
max_callbacks_to_parse  â†   64 # Maximum number of callbacks to parse
max_funcs_to_parse      â† 1024 # Maximum number of functions to parse
max_line_length         â†  512 # Maximum length of one line (including comments)
max_struct_fields       â†   64 # Maximum number of struct fields
max_enum_values         â†  512 # Maximum number of enum values
max_function_parameters â†   12 # Maximum number of function parameters

If      â† {ğ•âŸğ•@}Â´                 # Also Repeat
IfElse  â† {câ€¿Tâ€¿F: câ—¶Fâ€¿T@}
While   â† {ğ•©â€¢_while_ğ•¨@}Â´          # While 1â€¿{... to run forever
DoWhile â† {ğ•@ â‹„ While ğ•¨â€¿ğ•©}Â´
For     â† {Iâ€¿Câ€¿Pâ€¿A: I@ â‹„ WhileâŸ¨C,Pâˆ˜AâŸ©}

# Switch/case statements have many variations; these are a few
Match   â† {ğ•ğ•¨}Â´
Select  â† {(âŠ‘ğ•©)â—¶(1â†“ğ•©)@}
Switch  â† {câ†âŠ‘ğ•© â‹„ [m,a]â†â‰âˆ˜â€¿2â¥Š1â†“ğ•© â‹„ (mâŠ¸âŠâŒ¾<C)â—¶a@}
Test    â† {fnâ†{Câ€¿Ağ•Še:Câ—¶Aâ€¿E}Â´ğ•©â‹„Fn@}

tabâ†9+@

#----------------------------------------------------------------------------------
# Types and Structures Definition
#----------------------------------------------------------------------------------

# Type of parsed define
âŸ¨
    unknown
    macro
    guard
    int
    int_math
    long
    long_math
    float
    float_math
    double
    double_math
    char
    string
    coloR
âŸ© â† â†•14

# Struct info data
structInfo â† âŸ¨
    0â€¿64 â¥Š""  # name       # Struct name
    0â€¿128â¥Š""  # desc       # Struct type description
    â†•0        # fieldCount # Number of fields in the struct
    0â€¿max_struct_fieldsâ€¿64 â¥Š""  # fieldType  # Field type
    0â€¿max_struct_fieldsâ€¿64 â¥Š""  # fieldName  # Field name
    0â€¿max_struct_fieldsâ€¿128â¥Š""  # fieldDesc  # Field description
âŸ©

# Alias info data
aliasInfo â† âŸ¨
    0â€¿64 â¥Š"" # type # Alias type
    0â€¿64 â¥Š"" # name # Alias name
    0â€¿128â¥Š"" # desc # Alias description
âŸ©

# Enum info data
enumInfo â† âŸ¨
    0â€¿64 â¥Š"" # name       # Enum name
    0â€¿128â¥Š"" # desc       # Enum description
    â†•0     # valueCount # Number of values in enumerator
    0â€¿max_enum_valuesâ€¿64â¥Š""  # valueName    # Value name definition
    0â€¿max_enum_valuesâ¥Šâ†•0     # valueInteger # Value integer
    0â€¿max_enum_valuesâ€¿128â¥Š"" # valueDesc    # Value description
âŸ©

# Function info data
FunctionInfo â† âŸ¨
    0â€¿64 â¥Š"" # name        # Function name
    0â€¿128â¥Š"" # desc        # Function description (comment at the end)
    0â€¿32 â¥Š"" # retType     # Return value type
    â†•0       # paramCount  # Number of function parameters
    0â€¿max_function_parametersâ€¿32 â¥Š""paramType # Parameters type
    0â€¿max_function_parametersâ€¿32 â¥Š""paramName # Parameters name
    0â€¿max_function_parametersâ€¿128â¥Š""paramDesc # Parameters description
âŸ©

#----------------------------------------------------------------------------------
# Global Variables Definition
#----------------------------------------------------------------------------------
defineCount â† 0
structCount â† 0
aliasCount â† 0
enumCount â† 0
callbackCount â† 0
funcCount â† 0
defines â† @
structs â† @
aliases â† @
enums â† @
callbacks â† @
funcs â† @

#----------------------------------------------------------------------------------
# Module Functions Definition
#----------------------------------------------------------------------------------

# Get data type and name from a string containing both
# NOTE: Useful to parse function parameters and struct fields
static void GetDataTypeAndName(const char *typeName, int typeNameLen, char *type, char *name)
{
    for (int k = typeNameLen; k > 0; k--)
    {
        if ((typeName[k] == ' ') && (typeName[k - 1] != ','))
        {
            # Function name starts at this point (and ret type finishes at this point)
            MemoryCopy(type, typeName, k);
            MemoryCopy(name, typeName + k + 1, typeNameLen - k - 1);
            break;
        }
        else if (typeName[k] == '*')
        {
            MemoryCopy(type, typeName, k + 1);
            MemoryCopy(name, typeName + k + 1, typeNameLen - k - 1);
            break;
        }
        else if ((typeName[k] == '.') && (typeNameLen == 3)) # Handle varargs ...);
        {
            MemoryCopy(type, "...", 3);
            MemoryCopy(name, "args", 4);
            break;
        }
    }
}

# Get comment from a line, do nothing if no comment in line
static void GetDescription{ğ•Šline: # str â†’ description (str)
    c â† 0
    descStart â† Â¯1
    lastSlash â† Â¯2
    isValid â† 0
    
    {isValid âˆ§ (descStart=Â¯1) âˆ§ ğ•©â‰ ' '?
        descStart â†© c
    ;'/'=ğ•©?
        isValid â†© lastSlash=c-1
        lastSlash â†© c
    ;@
    }Â¨line
    ""âŸ(descStartâ‰ Â¯1) (c-descStart)â†‘descStartâ†“line
}

# Move array size from name to type
MoveArraySizeâ†{ğ•Šnameâ€¿type:
    int nameLength = TextLength(name);
    if (name[nameLength - 1] == ']')
    {
        for (int k = nameLength; k > 0; k--)
        {
            if (name[k] == '[')
            {
                int sizeLength = nameLength - k;
                MemoryCopy(&type[TextLength(type)], &name[k], sizeLength);
                name[k] â†© @
            }
        }
    }
}

# Compare two text strings, requires number of characters to compare
IsTextEqual{ğ•Štext1â€¿text2â€¿count:
    â‰¡Â´countâ†‘Â¨text1â€¿text2
}

# Find first text occurrence within a string
TextFindIndex â† âŠ‘Â¯1âˆ¾Ëœ/âˆ˜â·

# Get string of define type
StrDefineType â† âŠ‘âŸœâŸ¨
    "UNKNOWN"
    "GUARD"
    "MACRO"
    "INT"
    "INT_MATH"
    "LONG"
    "LONG_MATH"
    "FLOAT"
    "FLOAT_MATH"
    "DOUBLE"
    "DOUBLE_MATH"
    "CHAR"
    "STRING"
    "COLOR"
âŸ©

# Export parsed data in json
ExportParsedData â† {ğ•Šfilename:
    fileNameâŠ¸â€¢FLines âˆ¾âŸ¨ğ•Šdef:
        "{"

        # Print defines info
        "  ""defines"": ["
        Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âˆ¾{ğ•Šdef:âˆ¾âŸ¨
            â‹ˆ"    {"
            â‹ˆ"      ""name"": """âˆ¾def.nameâˆ¾""","
            â‹ˆ"      ""type"": """âˆ¾(StrDefineType def.type)âˆ¾""","
            {def.isHex? # INT or LONG
                "      ""value"": "âˆ¾(Strtol def.valueâ€¿NULLâ€¿16)âˆ¾","
            ;âˆ¨Â´def.type = INTâ€¿LONGâ€¿FLOATâ€¿DOUBLEâ€¿STRING?
                "      ""value"": "âˆ¾def.valueâˆ¾','
            ;
                "      ""value"": """âˆ¾def.valueâˆ¾""","
            }
            â‹ˆ"      ""description"": """âˆ¾def.descâˆ¾""""
            â‹ˆ"    },"
        âŸ©}Â¨defines
        "  ],"
        # Print structs info
        "  ""structs"": ["
        Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âˆ¾{ğ•Šstruct:âŸ¨
            â‹ˆ"    {"
            â‹ˆ"      ""name"": """âˆ¾struct.nameâˆ¾""","
            â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes struct.desc)âˆ¾""","
            â‹ˆ"      ""fields"": ["
            âˆ¾Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘){ğ•Šf:âŸ¨
                "        {"
                "          ""type"": """âˆ¾struct.fieldType[f]âˆ¾""","
                "          ""name"": """âˆ¾struct.fieldName[f]âˆ¾""","
                "          ""description"": """âˆ¾(EscapeBackslashes struct.fieldDesc[f])âˆ¾""""
                "        },"
            âŸ©}Â¨â†•struct.fieldCount
            â‹ˆ"      ]"
            â‹ˆ"    },"
        âŸ©}Â¨structs
        "  ],"

        # Print aliases info
        "  ""aliases"": ["
        Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âˆ¾{ğ•Šalias:âŸ¨
            "    {"
            "      ""type"": """âˆ¾alias.typeâˆ¾""","
            "      ""name"": """âˆ¾alias.nameâˆ¾""","
            "      ""description"": """âˆ¾alias.descâˆ¾'"'
            "    },"
        âŸ©}Â¨aliases
        â‹ˆ"  ],"

        # Print enums info
        â‹ˆ"  ""enums"": ["
        Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âˆ¾{ğ•Šenum:
            âˆ¾âŸ¨
                â‹ˆ"    {"
                â‹ˆ"      ""name"": """âˆ¾enum.nameâˆ¾""","
                â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes enum.desc)âˆ¾""","
                â‹ˆ"      ""values"": ["
                Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âˆ¾{ğ•Še:
                    âŸ¨
                        "        {"
                        "          ""name"": """âˆ¾enum.valueName[e]âˆ¾""","
                        "          ""value"": "âˆ¾enum.valueInteger[e]âˆ¾","
                        "          ""description"": """âˆ¾(EscapeBackslashes enum.valueDesc[e])âˆ¾'"'
                        "        },"
                    âŸ©
                }Â¨â†•enum.valueCount
                â‹ˆ"      ]"
                â‹ˆ"    },"
            âŸ©
        }â†•enums
        â‹ˆ"  ],"

        # Print callbacks info
        â‹ˆ"  ""callbacks"": ["
        for (int i = 0; i < callbackCount; i++)
        Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âˆ¾{ğ•Šcallback:âˆ¾âŸ¨
            â‹ˆ"    {"
            â‹ˆ"      ""name"": """âˆ¾callback.nameâˆ¾""","
            â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes callback.desc)âˆ¾""",",
            â‹ˆ"      ""returnType"": """âˆ¾callback.retTypeâˆ¾""","
            â‹ˆ"      ""params"": ["
            Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âˆ¾{ğ•Šp:
                "        {"
                "          ""type"": """âˆ¾callback.paramType[p]âˆ¾"""," 
                "          ""name"": """âˆ¾callback.paramName[p]âˆ¾""""  
                "        },"
            }Â¨â†•callback.paramCount
            â‹ˆ"      ]"
            â‹ˆ"    },"
        âŸ©}Â¨callbacks
        "  ],"

        # Print functions info
        â‹ˆ"  ""functions"": ["
        Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âˆ¾{ğ•Šfunc: âˆ¾âŸ¨
            â‹ˆ"    {"
            â‹ˆ"      ""name"": """âˆ¾func.nameâˆ¾""","
            â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes func.desc)âˆ¾""","
            â‹ˆ"      ""returnType"": """âˆ¾func.retTypeâˆ¾""","
            âˆ¾âŸ¨
                "      ""params"": ["
                âˆ¾{typeğ•Šname:âŸ¨
                    "        {"
                    "          ""type"": """âˆ¾typeâˆ¾""","
                    "          ""name"": """âˆ¾nameâˆ¾'"'
                    "        }"
                    ","
                âŸ©}Â¨Â´func.paramTypeâ€¿func.paramName
                â‹ˆ"      ]"
            âŸ©
            "    },"
        âŸ©}Â¨funcs
        â‹ˆ"  ]"
        â‹ˆ"}"
    âŸ©
}

#----------------------------------------------------------------------------------
# Program main entry point
#----------------------------------------------------------------------------------

# Preprocess buffer to get separate lines
# NOTE: GetTextLines() also removes leading spaces/tabs
lines â† â€¢FLines inFileName
linesCount â† â‰ lines

# Truncate lines
{ğ•¤
    int newCount = -1;
    For (iâ†0)â€¿{ğ•Š:i<linesCount}â€¿{ğ•Š:i+â†©1}â€¿{
        newCount>Â¯1? free(lines[i]);
        TextFindIndex(lines[i], truncAfter)>Â¯1? newCount â†© i;
        ;0
    }
    {ğ•Š:linesCountâ†©newCount}âŸâŠ¢newCount > -1
    "Number of truncated text lines: "âˆ¾â€¢ParseFloat linesCount
}âŸâŠ¢0<â‰ truncAfter

# Defines line indices
int *defineLines = (int *)malloc(MAX_DEFINES_TO_PARSE*sizeof(int));

# Structs line indices
int *structLines = (int *)malloc(MAX_STRUCTS_TO_PARSE*sizeof(int));

# Aliases line indices
int *aliasLines = (int *)malloc(MAX_ALIASES_TO_PARSE*sizeof(int));

# Enums line indices
int *enumLines = (int *)malloc(MAX_ENUMS_TO_PARSE*sizeof(int));

# Callbacks line indices
int *callbackLines = (int *)malloc(MAX_CALLBACKS_TO_PARSE*sizeof(int));

# Function line indices
int *funcLines = (int *)malloc(MAX_FUNCS_TO_PARSE*sizeof(int));

# Prepare required lines for parsing
#----------------------------------------------------------------------------------

# Read struct lines
# Find structs
# starting with "typedef struct ... {" or "typedef struct ... ; \n struct ... {"
# ending with "} ... ;"
# i.e. excluding "typedef struct rAudioBuffer rAudioBuffer;" -> Typedef and forward declaration only
structLines â† /{
    [m1,m2]â†"typedef struct"â€¿"struct"(âŠ£â‰¡â‰ âŠ¸â†‘)âŒœğ•©
    m1âˆ§m2Â«âŠ¸âˆ¨<Â´âˆ˜âŠâŸœ"{;"Â¨ğ•©
} lines

# Read alias lines
# Find aliases (lines with "typedef ... ...;")
aliasLines â† ("typedef"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨âˆ§2=(+Â´Â¨' 'âŠ¸=>âˆ¨`Â¨âˆ˜âˆŠâŸœ";("))lines

# Read enum lines
# Read enum line
# Keep the line position in the array of lines,
# so, we can scan that position and following lines
# ignore inline enums
enumLines â† ("typedef enum {"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)âˆ§âˆ¨Â´âˆ˜=âŸœ';')Â¨lines

# Read callback lines
callbackLines â† {
    # Find callbacks (lines with "typedef ... (* ... )( ... );")
    m1â†"typedef"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨lines
    m1âˆ§{(");"âŠ¸â‰¡Ë˜âˆ¨`âŠ¸<")("âŠ¸â‰¡Ë˜âˆ§"(*"âŠ¸â‰¡Ë˜)2â†•ğ•©}Â¨lines
}

# Read function lines
# Read function line (starting with `define`, i.e. for raylib.h "RLAPI")
funcLines â† apiDefineâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨lines

# At this point we have all raylib defines, structs, aliases, enums, callbacks, functions lines data to start parsing

# Parsing raylib data
#----------------------------------------------------------------------------------

# Define info data
defineIndicies â† {nameâ€¿typeâ€¿valueâ€¿descâ€¿isHexâ†â†•5}

defMacro â† "#define"

CheckHex â† Â¬Â·âˆ¨Â´âˆŠâŸœ(âˆ¾âŸ¨'0'+â†•10â‹„'a'+â†•6â‹„'A'+â†•6â‹„"xL.+-"âŸ©)

defines â† {
    linePtrs â† â†“âŸœlinesÂ¨/defMacroâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨âˆ¨`âˆ˜âˆŠâŸœ' 'â€¿tâŠ¸/Â¨lines
    loopedOver â† linePtrs
    
    # Skip duplicates
    âˆŠâˆ˜{defineIndicies.nameâŠ‘ğ•©}âŠ¸/definesâŠ£{ğ•ŠlinePtr:
        defineOut â† âŸ¨
            "" # str  # Define name
            @  # int  # Define type
            "" # str  # Define value
            "" # str  # Define description
            0  # bool # Define is hex number (for types INT, LONG)
        âŸ©
        LS â† {âˆ¨`Â¬ğ•©âˆŠ' 'â€¿tab} # leading spacing
        nameAndArgs â† RSâŠ¸/{ğ”½defMacroâˆ¾â¼ğ”½}linePtr # Skip spaces and tabs, then defMacro, then spaces and tabs again

        # Extract name
        defineNameStart â† linePtr-â—‹â‰ nameAndArgs
        
        openBraces â† +`-Ë"()"=âŒœnameAndArgs
        â€¢SHow (1+âŠâŸœ')')âŠ¸(â†‘â‹ˆâ†“)"hell)oo"
        
        nameLen â† defineNameEnd â† (âŒŠÂ´âˆ˜âŠâŸœ' 'â€¿tabâ‰¤Â·âŠ‘âŠâŸœ'(')â—¶âŸ¨
            1+âŠâŸœ')'
            âŒŠÂ´âŠâŸœ' 'â€¿tab
        âŸ© nameAndArgs

        nameâ€¿args â† nameLen(â†‘â‹ˆLSâŠ¸/âˆ˜â†“)nameAndArgs

        # Determine type
        {ğ•Š:defineOut macroâŒ¾(defineIndicies.typeâŠ¸âŠ‘)â†©}âŸâŠ¢')'=Â¯1âŠ‘name
        {ğ•Š:defineOut guardâŒ¾(defineIndicies.typeâŠ¸âŠ‘)â†©}âŸâŠ¢(0=â‰ args)âˆ¨'/'=âŠ‘args

        {'"'=âŠ‘args? defineOut stringâŒ¾(defineIndicies.typeâŠ¸âŠ‘)â†©
        ;args=â—‹âŠ‘"'"? defineOut charâŒ¾(defineIndicies.typeâŠ¸âŠ‘)â†©
        ;"CLITERAL(Color)"â‰¡15â†‘args? defineOut colorâŒ¾(defineIndicies.typeâŠ¸âŠ‘)â†©
        ;âŠ‘argsâŠ‘âŠ¸âˆŠ'0'+â†•10? # Parsing numbers
            isFloatâ€¿isNumberâ€¿isHex â† âŸ¨
                âŠ‘âˆŠâŸœ'.'
                âŠ‘âˆŠâŸœ'x'
                CheckHex
            âŸ©{ğ•ğ•©}Â¨<mâ†âˆ§`âˆ˜Â¬âˆ˜âˆŠâŸœ' 'â€¿tabâŠ¸/args
            {ğ•Š:isFloat?
                defineOut (doubleâ€¿floatâŠ‘Ëœ'f'=Â¯1âŠ‘m)âŒ¾(defineIndicies.typeâŠ¸âŠ‘)â†©
            ;
                defineOut (intâ€¿longâŠ‘Ëœ'L'=Â¯1âŠ‘m)âŒ¾(defineIndicies.typeâŠ¸âŠ‘)â†©
                defineOut isHexâŒ¾(defineIndicies.isHexâŠ¸âŠ‘)â†©
            }âŸâŠ¢isNumber
        }

        # Extracting value
        fullValue â† âˆ¨`âŒ¾âŒ½âˆ˜Â¬âˆ˜âˆŠâŸœtabâ€¿' 'âŠ¸/args/ËœÂ¬âˆ¨`0âˆ¾Ëœ"//"â·args
        value â† fullValueâ†“Ëœ-âŠ‘defineOut.typeâˆŠlongâ€¿float # Remove number postfix
        
        defineOut valueâŒ¾(defineIndicies.valueâŠ¸âŠ‘)â†©

        # Extracting description
        argsâ†"diw // dwa"
        desc â† âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/argsâ†“Ëœ2+âŠ‘/"//"â·args
        defineOut descâŒ¾(defineIndicies.descâŠ¸âŠ‘)â†©

        # Parse defines of type UNKNOWN to find calculated numbers
        breakHappenedâ†0â¥ŠËœâ‰ defineOut.value
        {ğ•¤
            largestType â† unknown
            isMath â† 1

            {ğ•Šc:
                ch â† câŠ‘value

                # Skip operators and whitespace
                Â¬âŠ‘châˆŠ"()+-*/ "âˆ¾tab?
                    {châˆŠ'0'+â†•10? # Read number operand
                        isNumberâ€¿isFloat â† 1â€¿0
                        breakâ†1
                        While {ğ•Š:breakâˆ§CheckHex ch}â€¿{
                            {ğ•Š:isFloatâ†©1}âŸâŠ¢ch='.'
                            CheckHex ch?
                                isNumber â†© 0
                                breakâ†©0
                            ;
                            c+â†©1
                            châ†©câŠ‘value
                        }
                        isNumberâ—¶{ğ•¤
                            isMath = false;
                            break;
                        }â€¿{
                            # Found a valid number -> update largestType
                            int numberType;
                            if (isFloat) numberType = (value[c - 1] == 'f')? FLOAT_MATH : DOUBLE_MATH;
                            else numberType = (value[c - 1] == 'L')? LONG_MATH : INT_MATH;

                            if (numberType > largestType) largestType = numberType;
                        }
                    ; # Read string operand
                        int operandStart = c;
                        while (!((ch == '\0') ||
                                    (ch == ' ') ||
                                    (ch == '(') ||
                                    (ch == ')') ||
                                    (ch == '+') ||
                                    (ch == '-') ||
                                    (ch == '*') ||
                                    (ch == '/')))
                        {
                            c++;
                            ch = value[c];
                        }
                        int operandEnd = c;
                        int operandLength = operandEnd - operandStart;

                        # Search previous defines for operand
                        bool foundOperand = false;
                        for (int previousDefineIndex = 0; previousDefineIndex < defineIndex; previousDefineIndex++)
                        {
                            if (IsTextEqual(defines[previousDefineIndex].name, &value[operandStart], operandLength))
                            {
                                if ((defines[previousDefineIndex].type >= INT) && (defines[previousDefineIndex].type <= DOUBLE_MATH))
                                {
                                    # Found operand and it's a number -> update largestType
                                    if (defines[previousDefineIndex].type > largestType) largestType = defines[previousDefineIndex].type;
                                    foundOperand = true;
                                }
                                break;
                            }
                        }
                        if (!foundOperand)
                        {
                            isMath = false;
                            breakHappened 1âŒ¾(câŠ¸âŠ‘)â†© 
                        }
                    }
                ;@
            }Â¨â†•â‰ defineOut.value

            if (isMath)
            {
                # Define is a calculated number -> update type
                if (largestType == INT) largestType = INT_MATH;
                else if (largestType == LONG) largestType = LONG_MATH;
                else if (largestType == FLOAT) largestType = FLOAT_MATH;
                else if (largestType == DOUBLE) largestType = DOUBLE_MATH;
                defineOut.type = largestType;
            }
        }âŸâŠ¢defineOut.type=unknown

        defineOut
    }Â¨loopedOver
}
defineCount â† â‰ defines

# Structs info data
structs = (StructInfo *)calloc(MAX_STRUCTS_TO_PARSE, sizeof(StructInfo));

for (int i = 0; i < structCount; i++)
{
    char **linesPtr = &lines[structLines[i]];

    # Parse struct description
    GetDescription(linesPtr[-1], structs[i].desc);

    # Get struct name: typedef struct name {
    const int TDS_LEN = 15; # length of "typedef struct "
    for (int c = TDS_LEN; c < 64 + TDS_LEN; c++)
    {
        if ((linesPtr[0][c] == '{') || (linesPtr[0][c] == ' '))
        {
            int nameLen = c - TDS_LEN;
            while (linesPtr[0][TDS_LEN + nameLen - 1] == ' ') nameLen--;
            MemoryCopy(structs[i].name, &linesPtr[0][TDS_LEN], nameLen);
            break;
        }
    }

    # Get struct fields and count them -> fields finish with ;
    int l = 1;
    while (linesPtr[l][0] != '}')
    {
        # WARNING: Some structs have empty spaces and comments -> OK, processed
        if ((linesPtr[l][0] != ' ') && (linesPtr[l][0] != '\0'))
        {
            # Scan one field line
            char *fieldLine = linesPtr[l];
            int fieldEndPos = 0;
            while (fieldLine[fieldEndPos] != ';') fieldEndPos++;

            if ((fieldLine[0] != '/') && !IsTextEqual(fieldLine, "struct", 6)) # Field line is not a comment and not a struct declaration
            {
                #printf("Struct field: %s_\n", fieldLine);     # OK!

                # Get struct field type and name
                GetDataTypeAndName(fieldLine, fieldEndPos, structs[i].fieldType[structs[i].fieldCount], structs[i].fieldName[structs[i].fieldCount]);

                # Get the field description
                GetDescription(&fieldLine[fieldEndPos], structs[i].fieldDesc[structs[i].fieldCount]);

                structs[i].fieldCount++;

                # Split field names containing multiple fields (like Matrix)
                int additionalFields = 0;
                int originalIndex = structs[i].fieldCount - 1;
                for (unsigned int c = 0; c < TextLength(structs[i].fieldName[originalIndex]); c++)
                {
                    if (structs[i].fieldName[originalIndex][c] == ',') additionalFields++;
                }

                if (additionalFields > 0)
                {
                    int originalLength = -1;
                    int lastStart;
                    for (unsigned int c = 0; c < TextLength(structs[i].fieldName[originalIndex]) + 1; c++)
                    {
                        char v = structs[i].fieldName[originalIndex][c];
                        bool isEndOfString = (v == '\0');
                        if ((v == ',') || isEndOfString)
                        {
                            if (originalLength == -1)
                            {
                                # Save length of original field name
                                # Don't truncate yet, still needed for copying
                                originalLength = c;
                            }
                            else
                            {
                                # Copy field data from original field
                                int nameLength = c - lastStart;
                                MemoryCopy(structs[i].fieldName[structs[i].fieldCount], &structs[i].fieldName[originalIndex][lastStart], nameLength);
                                MemoryCopy(structs[i].fieldType[structs[i].fieldCount], &structs[i].fieldType[originalIndex][0], TextLength(structs[i].fieldType[originalIndex]));
                                MemoryCopy(structs[i].fieldDesc[structs[i].fieldCount], &structs[i].fieldDesc[originalIndex][0], TextLength(structs[i].fieldDesc[originalIndex]));
                                structs[i].fieldCount++;
                            }
                            if (!isEndOfString)
                            {
                                # Skip comma and spaces
                                c++;
                                while (structs[i].fieldName[originalIndex][c] == ' ') c++;

                                # Save position for next field
                                lastStart = c;
                            }
                        }
                    }
                    # Set length of original field to truncate the first field name
                    structs[i].fieldName[originalIndex][originalLength] = '\0';
                }

                # Split field types containing multiple fields (like MemNode)
                additionalFields = 0;
                originalIndex = structs[i].fieldCount - 1;
                for (unsigned int c = 0; c < TextLength(structs[i].fieldType[originalIndex]); c++)
                {
                    if (structs[i].fieldType[originalIndex][c] == ',') additionalFields++;
                }

                if (additionalFields > 0)
                {
                    # Copy original name to last additional field
                    structs[i].fieldCount += additionalFields;
                    MemoryCopy(structs[i].fieldName[originalIndex + additionalFields], &structs[i].fieldName[originalIndex][0], TextLength(structs[i].fieldName[originalIndex]));

                    # Copy names from type to additional fields
                    int fieldsRemaining = additionalFields;
                    int nameStart = -1;
                    int nameEnd = -1;
                    for (int k = TextLength(structs[i].fieldType[originalIndex]); k > 0; k--)
                    {
                        char v = structs[i].fieldType[originalIndex][k];
                        if ((v == '*') || (v == ' ') || (v == ','))
                        {
                            if (nameEnd != -1) {
                                # Don't copy to last additional field
                                if (fieldsRemaining != additionalFields)
                                {
                                    nameStart = k + 1;
                                    MemoryCopy(structs[i].fieldName[originalIndex + fieldsRemaining], &structs[i].fieldType[originalIndex][nameStart], nameEnd - nameStart + 1);
                                }
                                nameEnd = -1;
                                fieldsRemaining--;
                            }
                        }
                        else if (nameEnd == -1) nameEnd = k;
                    }

                    # Truncate original field type
                    int fieldTypeLength = nameStart;
                    structs[i].fieldType[originalIndex][fieldTypeLength] = '\0';

                    # Set field type and description of additional fields
                    for (int j = 1; j <= additionalFields; j++)
                    {
                        MemoryCopy(structs[i].fieldType[originalIndex + j], &structs[i].fieldType[originalIndex][0], fieldTypeLength);
                        MemoryCopy(structs[i].fieldDesc[originalIndex + j], &structs[i].fieldDesc[originalIndex][0], TextLength(structs[i].fieldDesc[originalIndex]));
                    }
                }
            }
        }

        l++;
    }

    # Move array sizes from name to type
    for (int j = 0; j < structs[i].fieldCount; j++)
    {
        MoveArraySize(structs[i].fieldName[j], structs[i].fieldType[j]);
    }
}
free(structLines);

# Alias info data
aliases = (AliasInfo *)calloc(MAX_ALIASES_TO_PARSE, sizeof(AliasInfo));

for (int i = 0; i < aliasCount; i++)
{
    # Description from previous line
    GetDescription(lines[aliasLines[i] - 1], aliases[i].desc);

    char *linePtr = lines[aliasLines[i]];

    # Skip "typedef "
    int c = 8;

    # Type
    int typeStart = c;
    while(linePtr[c] != ' ') c++;
    int typeLen = c - typeStart;
    MemoryCopy(aliases[i].type, &linePtr[typeStart], typeLen);

    # Skip space
    c++;

    # Name
    int nameStart = c;
    while(linePtr[c] != ';') c++;
    int nameLen = c - nameStart;
    MemoryCopy(aliases[i].name, &linePtr[nameStart], nameLen);

    # Description
    GetDescription(&linePtr[c], aliases[i].desc);
}
free(aliasLines);

# Enum info data
enums = (EnumInfo *)calloc(MAX_ENUMS_TO_PARSE, sizeof(EnumInfo));

for (int i = 0; i < enumCount; i++)
{

    # Parse enum description
    # NOTE: This is not necessarily from the line immediately before,
    # some of the enums have extra lines between the "description"
    # and the typedef enum
    for (int j = enumLines[i] - 1; j > 0; j--)
    {
        char *linePtr = lines[j];
        if ((linePtr[0] != '/') || (linePtr[2] != ' '))
        {
            GetDescription(&lines[j + 1][0], enums[i].desc);
            break;
        }
    }

    for (int j = 1; j < MAX_ENUM_VALUES*2; j++)   # Maximum number of lines following enum first line
    {
        char *linePtr = lines[enumLines[i] + j];

        if ((linePtr[0] >= 'A') && (linePtr[0] <= 'Z'))
        {
            # Parse enum value line, possible options:
            #ENUM_VALUE_NAME,
            #ENUM_VALUE_NAME
            #ENUM_VALUE_NAME     = 99
            #ENUM_VALUE_NAME     = 99,
            #ENUM_VALUE_NAME     = 0x00000040,   # Value description

            # We start reading the value name
            int c = 0;
            while ((linePtr[c] != ',') &&
                    (linePtr[c] != ' ') &&
                    (linePtr[c] != '=') &&
                    (linePtr[c] != '\0'))
            {
                enums[i].valueName[enums[i].valueCount][c] = linePtr[c];
                c++;
            }

            # After the name we can have:
            #  '='  -> value is provided
            #  ','  -> value is equal to previous + 1, there could be a description if not '\0'
            #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
            #  '\0' -> value is equal to previous + 1

            # Let's start checking if the line is not finished
            if ((linePtr[c] != ',') && (linePtr[c] != '\0'))
            {
                # Two options:
                #  '='  -> value is provided
                #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
                bool foundValue = false;
                while ((linePtr[c] != '\0') && (linePtr[c] != '/'))
                {
                    if (linePtr[c] == '=')
                    {
                        foundValue = true;
                        break;
                    }
                    c++;
                }

                if (foundValue)
                {
                    if (linePtr[c + 1] == ' ') c += 2;
                    else c++;

                    # Parse integer value
                    int n = 0;
                    char integer[16] = { 0 };

                    while ((linePtr[c] != ',') && (linePtr[c] != ' ') && (linePtr[c] != '\0'))
                    {
                        integer[n] = linePtr[c];
                        c++; n++;
                    }

                    if (integer[1] == 'x') enums[i].valueInteger[enums[i].valueCount] = (int)strtol(integer, NULL, 16);
                    else enums[i].valueInteger[enums[i].valueCount] = atoi(integer);
                }
                else enums[i].valueInteger[enums[i].valueCount] = (enums[i].valueInteger[enums[i].valueCount - 1] + 1);
            }
            else enums[i].valueInteger[enums[i].valueCount] = (enums[i].valueInteger[enums[i].valueCount - 1] + 1);

            # Parse value description
            GetDescription(&linePtr[c], enums[i].valueDesc[enums[i].valueCount]);

            enums[i].valueCount++;
        }
        else if (linePtr[0] == '}')
        {
            # Get enum name from typedef
            int c = 0;
            while (linePtr[2 + c] != ';')
            {
                enums[i].name[c] = linePtr[2 + c];
                c++;
            }

            break;  # Enum ended, break for() loop
        }
    }
}
free(enumLines);

# Callback info data
callbacks = (FunctionInfo *)calloc(MAX_CALLBACKS_TO_PARSE, sizeof(FunctionInfo));

for (int i = 0; i < callbackCount; i++)
{
    char *linePtr = lines[callbackLines[i]];

    # Skip "typedef "
    unsigned int c = 8;

    # Return type
    int retTypeStart = c;
    while(linePtr[c] != '(') c++;
    int retTypeLen = c - retTypeStart;
    while(linePtr[retTypeStart + retTypeLen - 1] == ' ') retTypeLen--;
    MemoryCopy(callbacks[i].retType, &linePtr[retTypeStart], retTypeLen);

    # Skip "(*"
    c += 2;

    # Name
    int nameStart = c;
    while(linePtr[c] != ')') c++;
    int nameLen = c - nameStart;
    MemoryCopy(callbacks[i].name, &linePtr[nameStart], nameLen);

    # Skip ")("
    c += 2;

    # Params
    int paramStart = c;
    for (; c < MAX_LINE_LENGTH; c++)
    {
        if ((linePtr[c] == ',') || (linePtr[c] == ')'))
        {
            # Get parameter type + name, extract info
            int paramLen = c - paramStart;
            GetDataTypeAndName(&linePtr[paramStart], paramLen, callbacks[i].paramType[callbacks[i].paramCount], callbacks[i].paramName[callbacks[i].paramCount]);
            callbacks[i].paramCount++;
            paramStart = c + 1;
            while(linePtr[paramStart] == ' ') paramStart++;
        }
        if (linePtr[c] == ')') break;
    }

    # Description
    GetDescription(&linePtr[c], callbacks[i].desc);

    # Move array sizes from name to type
    for (int j = 0; j < callbacks[i].paramCount; j++)
    {
        MoveArraySize(callbacks[i].paramName[j], callbacks[i].paramType[j]);
    }
}
free(callbackLines);

# Functions info data
funcs = (FunctionInfo *)calloc(MAX_FUNCS_TO_PARSE, sizeof(FunctionInfo));

for (int i = 0; i < funcCount; i++)
{
    char *linePtr = lines[funcLines[i]];

    int funcParamsStart = 0;
    int funcEnd = 0;

    # Get return type and function name from func line
    for (int c = 0; (c < MAX_LINE_LENGTH) && (linePtr[c] != '\n'); c++)
    {
        if (linePtr[c] == '(')     # Starts function parameters
        {
            funcParamsStart = c + 1;

            # At this point we have function return type and function name
            char funcRetTypeName[128] = { 0 };
            int dc = TextLength(apiDefine) + 1;
            int funcRetTypeNameLen = c - dc;     # Substract `define` ("RLAPI " for raylib.h)
            MemoryCopy(funcRetTypeName, &linePtr[dc], funcRetTypeNameLen);

            GetDataTypeAndName(funcRetTypeName, funcRetTypeNameLen, funcs[i].retType, funcs[i].name);
            break;
        }
    }

    # Get parameters from func line
    for (int c = funcParamsStart; c < MAX_LINE_LENGTH; c++)
    {
        if (linePtr[c] == ',')     # Starts function parameters
        {
            # Get parameter type + name, extract info
            char funcParamTypeName[128] = { 0 };
            int funcParamTypeNameLen = c - funcParamsStart;
            MemoryCopy(funcParamTypeName, &linePtr[funcParamsStart], funcParamTypeNameLen);

            GetDataTypeAndName(funcParamTypeName, funcParamTypeNameLen, funcs[i].paramType[funcs[i].paramCount], funcs[i].paramName[funcs[i].paramCount]);

            funcParamsStart = c + 1;
            if (linePtr[c + 1] == ' ') funcParamsStart += 1;
            funcs[i].paramCount++;      # Move to next parameter
        }
        else if (linePtr[c] == ')')
        {
            funcEnd = c + 2;

            # Check if previous word is void
            if ((linePtr[c - 4] == 'v') && (linePtr[c - 3] == 'o') && (linePtr[c - 2] == 'i') && (linePtr[c - 1] == 'd')) break;

            # Get parameter type + name, extract info
            char funcParamTypeName[128] = { 0 };
            int funcParamTypeNameLen = c - funcParamsStart;
            MemoryCopy(funcParamTypeName, &linePtr[funcParamsStart], funcParamTypeNameLen);

            GetDataTypeAndName(funcParamTypeName, funcParamTypeNameLen, funcs[i].paramType[funcs[i].paramCount], funcs[i].paramName[funcs[i].paramCount]);

            funcs[i].paramCount++;      # Move to next parameter
            break;
        }
    }

    # Get function description
    GetDescription(&linePtr[funcEnd], funcs[i].desc);

    # Move array sizes from name to type
    for (int j = 0; j < funcs[i].paramCount; j++)
    {
        MoveArraySize(funcs[i].paramName[j], funcs[i].paramType[j]);
    }
}
free(funcLines);

for (int i = 0; i < linesCount; i++) free(lines[i]);
free(lines);

# At this point, all raylib data has been parsed!
#----------------------------------------------------------------------------------
# defines[]   -> We have all the defines decomposed into pieces for further analysis
# structs[]   -> We have all the structs decomposed into pieces for further analysis
# aliases[]   -> We have all the aliases decomposed into pieces for further analysis
# enums[]     -> We have all the enums decomposed into pieces for further analysis
# callbacks[] -> We have all the callbacks decomposed into pieces for further analysis
# funcs[]     -> We have all the functions decomposed into pieces for further analysis
â€¢Out""
â€¢Out"Input file:       "âˆ¾inFileName
â€¢Out"Output file:      "âˆ¾outFileName

ExportParsedData(outFileName);