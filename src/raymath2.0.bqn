# GOAL make raylib functions work on arbitrary vectors and matricies
# ALSO try make arbitrary matricies aswell as switch from raylib's collumn model to leading axis model

âŸ¨MPâ‹„MatrixLookAt
 MatrixScaleâ‹„MatrixRotate
 GetCameraMatrix2D
 MatrixRotateXâ‹„MatrixRotateYâ‹„MatrixRotateZ
 Vector2Transform
âŸ©â‡

Sinâ€¿Cosâ†â€¢math

âŸ¨MPâŸ© â† â€¢Import "imports/bqn-libs/matrix.bqn"

# Get camera look-at matrix (view matrix)
# returns Matrix
MatrixLookAt â† {ğ•Šeyeâ€¿targetâ€¿up: # v3 v3 v3
  vz â† {ğ•©Ã·1âŸ(0=âŠ¢)+Â´âŒ¾(â‹†âŸœ2)ğ•©} eye-target
  vx â† {ğ•©Ã·1âŸ(0=âŠ¢)+Â´âŒ¾(â‹†âŸœ2)ğ•©} -Â´Ã—Â´Ë˜1â€¿Â¯1âŒ½âŒœupâ€¿vz
  vy â† -Â´Ã—Â´Ë˜1â€¿Â¯1âŒ½âŒœvzâ€¿vx

  [
    âŸ¨vx.x â‹„ vy.x â‹„ vz.x â‹„ 0âŸ©
    âŸ¨vx.y â‹„ vy.y â‹„ vz.y â‹„ 0âŸ©
    âŸ¨vx.z â‹„ vy.z â‹„ vz.z â‹„ 0âŸ©
    1âˆ¾Ëœ-eyeâŠ¸Ã—Â¨vxâ€¿vyâ€¿vz
  ]
}


# Get translation matrix
MatrixTranslate â† {ğ•Šxâ€¿yâ€¿z:[# v3 â†’ Matrix
  1â€¿0â€¿0â€¿x
  0â€¿1â€¿0â€¿y
  0â€¿0â€¿1â€¿z
  0â€¿0â€¿0â€¿1
]}

# Get scaling matrix
MatrixScale â† {ğ•Šxâ€¿yâ€¿z:(ğ•©âˆ¾1)âŒ¾(0â€¿0âŠ¸â‰)4â€¿4â¥Š0}

# Create rotation matrix from axis and angle
# NOTE: Angle should be provided in radians
MatrixRotate â† {ğ•Šaxisâ€¿angle: # v3 f
  xâ€¿yâ€¿z â† (+Â´axisâ‹†2)Ã·âŸœâˆšËœâŸ(âˆ§Â´2â†•âŠ¸â‰ âŠ£)axis

  sinres â† â€¢math.Sin angle
  cosres â† â€¢math.Cos angle
  m â† ((Â¬cosres)Ã—Ã—âŒœËœxâ€¿yâ€¿z)+(cosresÂ¨âŒ¾(0â€¿0âŠ¸â‰)3â€¿3â¥Šsinres)Ã—[
    âŸ¨ 1 â‹„-z â‹„ yâŸ©
    âŸ¨ z â‹„ 1 â‹„-xâŸ©
    âŸ¨-y â‹„ x â‹„ 1âŸ©
  ]
  âˆ¾[ m â‹„3â¥Š0
    3â¥Š0â‹„1  ]
}

# NOTE: Angle must be provided in radians
MatrixRotateXâ€¿MatrixRotateYâ€¿MatrixRotateZ â† {
    _RotMat â† {cut2x2OfMat On2x2Arr _ğ•£ degrees:
        (ğ”½(â‹ˆâŸœ-Â´â‰âŒ½)(â€¢math.Cosâˆ¾â€¢math.Sin)ğ•©)âŒ¾(ğ•¨âŠ¸âŠË˜ğ•¨âŠ¸âŠ)=âŒœËœâ†•4
    }
    âŸ¨1â€¿2 â‰_RotMat âŠ¢
     0â€¿2 âŠ¢_RotMat âŠ¢
     0â€¿1 â‰_RotMat âŠ¢âŸ©
}

### rcore.c functions

# Get camera 2d transform matrix
GetCameraMatrix2D â† {ğ•Šcamera: # camera2d
  # The camera in world-space is set by
  #   1. Move it to target
  #   2. Rotate by -rotation and scale by (1/zoom)
  #      When setting higher scale, it's more intuitive for the world to become bigger (= camera become smaller),
  #      not for the camera getting bigger, hence the invert. Same deal with rotation.
  #   3. Move it by (-offset);
  #      Offset defines target transform relative to screen, but since we're effectively "moving" screen (camera)
  #      we need to do it into opposite direction (inverse transform)
    
  # Having camera transform in world-space, inverse of it gives the modelview transform.
  # Since (A*B*C)' = C'*B'*A', the modelview is
  #   1. Move to offset
  #   2. Rotate and Scale
  #   3. Move by -target
  origin      â† MatrixTranslate-(1âŠ‘camera)âˆ¾0
  rotation    â† MatrixRotate 0â€¿0â€¿1â‹ˆ Ï€Ã·180Ã—2âŠ‘camera
  scale       â† MatrixScale 1âˆ¾Ëœ2â¥Š3âŠ‘camera
  translation â† MatrixTranslate 0âˆ¾ËœâŠ‘camera
  matTransform â† originâ€¿scaleâ€¿rotation MPÂ´âŠ¸MP translation
}






###############################################################################################
#
#   raymath v1.5 - Math functions to work with Vector2, Vector3, Matrix and Quaternions
#
#   CONVENTIONS:
#     - Matrix structure is defined as row-major (memory layout) but parameters naming AND all
#       math operations performed by the library consider the structure as it was column-major
#       It is like transposed versions of the matrices are used for all the maths
#       It benefits some functions making them cache-friendly and also avoids matrix
#       transpositions sometimes required by OpenGL
#       Example: In memory order, row0 is [m0 m4 m8 m12] but in semantic math row0 is [m0 m1 m2 m3]
#     - Functions are always self-contained, no function use another raymath function inside,
#       required code is directly re-implemented inside
#     - Functions input parameters are always received by value (2 unavoidable exceptions)
#     - Functions use always a "result" variable for return
#     - Functions are always defined inline
#     - Angles are always in radians (DEG2RAD/RAD2DEG macros provided for convenience)
#
###############################################################################################

#----------------------------------------------------------------------------------
# removed from raylib
#----------------------------------------------------------------------------------

# Too simple:
#  Clamp, Vector2Clamp â†’ maxâŒŠminâŒˆx
Vector2Zero â† 2â¥Š0Ë™
Vector2One  â† 2â¥Š1Ë™
Vector2Add     â† Vector2AddValue â† +
Vector2Multiply â† Vector2Scale â† Ã—
Vector2Subtract â† Vector2SubtractValue â† Vector2Negate â† Vector3Negate â† -
Vector2Divide â† Vector2Invert â† Vector3Divide â† Vector3Invert â† Ã·
Vector3DistanceSqr â† Vector2DistanceSqr â† Vector3LengthSqr â† 2â‹†ËœVectorDistance

Vector2Length     â† Vector3Length     â† VectorLength
Vector2LengthSqr  â†                     VectorLengthSqr
Vector2DotProduct â† Vector3DotProduct â† VectorDotProduct 
Vector2Distance   â† Vector3Distance   â† VectorDistance
Vector2Lerp       â† Vector3Lerp       â† VectorLerp
Vector2Transform  â† Vector3Transform  â† VectorTransform
Vector2ClampValue â† Vector3ClampValue â† VectorClampValue
Vector2Equals     â† Vector3Equals     â† VectorEquals
Vector2Normalize  â† Vector3Normalize  â† VectorNormalize


#----------------------------------------------------------------------------------
# Defines
#----------------------------------------------------------------------------------

epsilon â† 1eÂ¯6
deg2rad â† Ï€Ã·180
rad2deg â† 180Ã·Ï€

#----------------------------------------------------------------------------------
# Types and Structures Definition
#----------------------------------------------------------------------------------

# Vector2 type
typedef struct Vector2 {
    float x;
    float y;
} Vector2;

# Vector3 type
typedef struct Vector3 {
    float x;
    float y;
    float z;
} Vector3;

# Vector4 type
typedef struct Vector4 {
    float x;
    float y;
    float z;
    float w;
} Vector4;

# Quaternion type
typedef Vector4 Quaternion;

# Matrix type (OpenGL style 4x4 - right handed, column major)
typedef struct Matrix {
    float m0, m4, m8, m12;      # Matrix first row (4 components)
    float m1, m5, m9, m13;      # Matrix second row (4 components)
    float m2, m6, m10, m14;     # Matrix third row (4 components)
    float m3, m7, m11, m15;     # Matrix fourth row (4 components)
} Matrix;

âŸ¨Sin, Cos, Tan, Atan2âŸ©â†â€¢math

#----------------------------------------------------------------------------------
# Module Functions Definition - Utils math
#----------------------------------------------------------------------------------

# Calculate linear interpolation between two floats
Lerp â† {ğ•Šstartâ€¿endâ€¿amount:
  start + amount Ã— end - start
}

# Normalize input value within input range
Normalize â† {ğ•Švalueâ€¿startâ€¿end:
  Ã·Â´valueâ€¿end-start
}

# Remap input value within input range to output range
Remap â† {ğ•Švalueâ€¿inputStartâ€¿inputEndâ€¿outputStartâ€¿outputEnd:
  {ğ•©Ã—Ã·Â´valueâ€¿inputEnd-inputStart}âŒ¾(-âŸœoutputEnd) outputStart
}

# Wrap input value from min to max
Wrap â† {ğ•Švalueâ€¿minâ€¿max:
  (value - maxâŠ¸- Ã— valueâŠ¸- âŒŠâˆ˜Ã· maxâŠ¸-) min
}

# Check whether two given floats are almost equal
FloatEquals â† {ğ•Šxâ€¿y:
  (|x-y) â‰¤ epsilonÃ—1âŒˆxâŒˆâ—‹|y
}

#----------------------------------------------------------------------------------
# Module Functions Definition - Vector2 math
#----------------------------------------------------------------------------------

# Calculate vector length
VectorLength â† +Â´âŒ¾(Ã—Ëœ)

# ğ•¨ğ•Šğ•©: Calculate two vectors dot product
#  ğ•Šğ•©: Calculate vector square length
VectorDotProductÂ â† VectorLengthSqr â† +Â´Ã—Ëœ

# Calculate distance between two vectors
VectorDistance â† +Â´âŒ¾(Ã—Ëœ)-

# Calculate angle between two vectors
# NOTE: Angle is calculated from origin point (0, 0)
Vector2Angle â† Atan2Â´-

# Calculate angle defined by a two vectors line
# NOTE: Parameters need to be normalized
# Current implementation should be aligned with glm::angle
Vector2LineAngle â† Cosâ¼1âŒˆÂ¯1âŒˆ+Â´âˆ˜Ã— # start ğ•Š end

# Transforms a Vector2 by a given Matrix
VectorTransform â† {ğ•Švâ€¿matrix:
  xâ€¿yâ€¿z â† 3â†‘v
  +Ëxâ€¿yâ€¿zâ€¿1 Ã— 0â€¿1âŠ¸âŠË˜matrix
}

# Calculate linear interpolation between two vectors
VectorLerp â† {ğ•Šv1â€¿v2â€¿amount:
  amountâŠ¸Ã—âŒ¾(-âŸœv1)v2
}

# Calculate reflected vector to normal
Vector2Reflect â† {normalğ•Šv: # vector vector
  v-2Ã—normalÃ—+Â´vÃ—normal
}

# Rotate vector by angle:  angle ğ•Š vector2
Vector2Rotate â† (Cosâˆ¾Sin)âŠ¸(-Â´âˆ˜Ã—â‹ˆÂ·+Â´âŒ½âŠ¸Ã—)

# Move Vector towards target
Vector2MoveTowards â† {ğ•Švâ€¿targetâ€¿maxDistance:

  d â† dxâ€¿dy â† target - v;
  value â† +Â´Ã—Ëœd

  {
    (value = 0) âˆ¨ (maxDistance â‰¥ 0) âˆ§ value â‰¤ Ã—ËœmaxDistance?
      target
    ;
    v+maxDistanceÃ—dÃ·âˆšvalue
  }
}

# Clamp the magnitude of the vector between two min and max values
VectorClampValue â† {ğ•Švâ€¿minâ€¿max:
  length â† +Â´âˆ˜â¥ŠâŒ¾(Ã—Ëœ)v
  {lengthâ‰¤0?v;
    length < min?
      vÃ—minÃ·length;
    length > max?
      vÃ—maxÃ·length;
    v
  }
}
#â€¢Show VectorClampValue âŸ¨2â€¿2â€¿2â€¿2,10,22âŸ©

# Check whether two given vectors are almost equal
VectorEquals â† âˆ§Â´|âˆ˜-â‰¤epsilonÃ—1âŒˆâŒˆâ—‹|

#----------------------------------------------------------------------------------
# Module Functions Definition - Vector3 math
#----------------------------------------------------------------------------------

# Vector with components value 0.0f
RMAPI Vector3 Vector3Zero(void)
{
    Vector3 result = { 0.0f, 0.0f, 0.0f };

    return result;
}

# Vector with components value 1.0f
RMAPI Vector3 Vector3One(void)
{
    Vector3 result = { 1.0f, 1.0f, 1.0f };

    return result;
}

# Add two vectors
RMAPI Vector3 Vector3Add(Vector3 v1, Vector3 v2)
{
    Vector3 result = { v1.x + v2.x, v1.y + v2.y, v1.z + v2.z };

    return result;
}

# Add vector and float value
RMAPI Vector3 Vector3AddValue(Vector3 v, float add)
{
    Vector3 result = { v.x + add, v.y + add, v.z + add };

    return result;
}

# Subtract two vectors
RMAPI Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
{
    Vector3 result = { v1.x - v2.x, v1.y - v2.y, v1.z - v2.z };

    return result;
}

# Subtract vector by float value
RMAPI Vector3 Vector3SubtractValue(Vector3 v, float sub)
{
    Vector3 result = { v.x - sub, v.y - sub, v.z - sub };

    return result;
}

# Multiply vector by scalar
RMAPI Vector3 Vector3Scale(Vector3 v, float scalar)
{
    Vector3 result = { v.x*scalar, v.y*scalar, v.z*scalar };

    return result;
}

# Multiply vector by vector
RMAPI Vector3 Vector3Multiply(Vector3 v1, Vector3 v2)
{
    Vector3 result = { v1.x*v2.x, v1.y*v2.y, v1.z*v2.z };

    return result;
}

# Calculate two vectors cross product
RMAPI Vector3 Vector3CrossProduct(Vector3 v1, Vector3 v2)
{
    Vector3 result = { v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x };

    return result;
}

# Calculate one vector perpendicular vector
RMAPI Vector3 Vector3Perpendicular(Vector3 v)
{
    Vector3 result = { 0 };

    float min = (float) fabs(v.x);
    Vector3 cardinalAxis = {1.0f, 0.0f, 0.0f};

    if (fabsf(v.y) < min)
    {
        min = (float) fabs(v.y);
        Vector3 tmp = {0.0f, 1.0f, 0.0f};
        cardinalAxis = tmp;
    }

    if (fabsf(v.z) < min)
    {
        Vector3 tmp = {0.0f, 0.0f, 1.0f};
        cardinalAxis = tmp;
    }

    # Cross product between vectors
    result.x = v.y*cardinalAxis.z - v.z*cardinalAxis.y;
    result.y = v.z*cardinalAxis.x - v.x*cardinalAxis.z;
    result.z = v.x*cardinalAxis.y - v.y*cardinalAxis.x;

    return result;
}

# Calculate angle between two vectors
RMAPI float Vector3Angle(Vector3 v1, Vector3 v2)
{
    float result = 0.0f;

    Vector3 cross = { v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x };
    float len = sqrtf(cross.x*cross.x + cross.y*cross.y + cross.z*cross.z);
    float dot = (v1.x*v2.x + v1.y*v2.y + v1.z*v2.z);
    result = atan2f(len, dot);

    return result;
}

# Normalize provided vector
VectorNormalize â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))

# Orthonormalize provided vectors
# Makes vectors normalized and orthogonal to each other
# Gram-Schmidt function implementation
Vector3OrthoNormalize{v1ğ•Šv2:
  # Vector3Normalize v1
  F â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))

  # Vector3CrossProductÂ´v1â€¿v2
  G â† {(Â¯1âŒ½ğ•¨)Ã—1âŒ½ğ•©}{ğ”½Ëœ-ğ”½}
  
  v1 GËœâ—‹F v1 FâŠ¸G v2
}






# Transforms a Vector2 by a given Matrix
VectorTransform â† {ğ•Švâ€¿matrix:
  xâ€¿yâ€¿z â† 3â†‘v
  +Ëxâ€¿yâ€¿zâ€¿1 Ã— (â†•â‰ v)âŠ¸âŠË˜matrix
}

# Transform a vector by quaternion rotation
Vector3RotateByQuaternion â† {qğ•Šv: xâ€¿yâ€¿zâ€¿wâ†q
  MPâŸœv MPâŸœq[
    [ [x â‹„ -y â‹„ -z â‹„  w] â‹„ [ y â‹„ x â‹„ -w â‹„ -z] â‹„ [ z â‹„  w â‹„ x â‹„  y] ]
    [ [y â‹„  x â‹„  w â‹„  z] â‹„ [-x â‹„ y â‹„ -z â‹„  w] â‹„ [-w â‹„  z â‹„ y â‹„ -x] ]
    [ [z â‹„ -w â‹„  x â‹„ -y] â‹„ [ w â‹„ z â‹„  y â‹„  x] â‹„ [-x â‹„ -y â‹„ z â‹„  w] ]
  ]
}

# Rotates a vector around an axis
RMAPI Vector3 Vector3RotateByAxisAngle(Vector3 v, Vector3 axis, float angle)
{
    # Using Euler-Rodrigues Formula
    # Ref.: https:#en.wikipedia.org/w/index.php?title=Euler%E2%80%93Rodrigues_formula

    Vector3 result = v;

    # Vector3Normalize(axis);
    float length = sqrtf(axis.x * axis.x + axis.y * axis.y + axis.z * axis.z);
    if (length == 0.0f) length = 1.0f;
    float ilength = 1.0f / length;
    axis.x *= ilength;
    axis.y *= ilength;
    axis.z *= ilength;

    angle /= 2.0f;
    float a = sinf(angle);
    float b = axis.x * a;
    float c = axis.y * a;
    float d = axis.z * a;
    a = cosf(angle);
    Vector3 w = { b, c, d };

    # Vector3CrossProduct(w, v)
    Vector3 wv = { w.y * v.z - w.z * v.y, w.z * v.x - w.x * v.z, w.x * v.y - w.y * v.x };

    # Vector3CrossProduct(w, wv)
    Vector3 wwv = { w.y * wv.z - w.z * wv.y, w.z * wv.x - w.x * wv.z, w.x * wv.y - w.y * wv.x };

    # Vector3Scale(wv, 2 * a)
    a *= 2;
    wv.x *= a;
    wv.y *= a;
    wv.z *= a;

    # Vector3Scale(wwv, 2)
    wwv.x *= 2;
    wwv.y *= 2;
    wwv.z *= 2;

    result.x += wv.x;
    result.y += wv.y;
    result.z += wv.z;

    result.x += wwv.x;
    result.y += wwv.y;
    result.z += wwv.z;

    return result;
}

# Calculate reflected vector to normal
RMAPI Vector3 Vector3Reflect(Vector3 v, Vector3 normal)
{
    Vector3 result = { 0 };

    # I is the original vector
    # N is the normal of the incident plane
    # R = I - (2*N*(DotProduct[I, N]))

    float dotProduct = (v.x*normal.x + v.y*normal.y + v.z*normal.z);

    result.x = v.x - (2.0f*normal.x)*dotProduct;
    result.y = v.y - (2.0f*normal.y)*dotProduct;
    result.z = v.z - (2.0f*normal.z)*dotProduct;

    return result;
}

# Get min value for each pair of components
RMAPI Vector3 Vector3Min(Vector3 v1, Vector3 v2)
{
    Vector3 result = { 0 };

    result.x = fminf(v1.x, v2.x);
    result.y = fminf(v1.y, v2.y);
    result.z = fminf(v1.z, v2.z);

    return result;
}

# Get max value for each pair of components
RMAPI Vector3 Vector3Max(Vector3 v1, Vector3 v2)
{
    Vector3 result = { 0 };

    result.x = fmaxf(v1.x, v2.x);
    result.y = fmaxf(v1.y, v2.y);
    result.z = fmaxf(v1.z, v2.z);

    return result;
}

# Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c)
# NOTE: Assumes P is on the plane of the triangle
RMAPI Vector3 Vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
{
    Vector3 result = { 0 };

    Vector3 v0 = { b.x - a.x, b.y - a.y, b.z - a.z };   # Vector3Subtract(b, a)
    Vector3 v1 = { c.x - a.x, c.y - a.y, c.z - a.z };   # Vector3Subtract(c, a)
    Vector3 v2 = { p.x - a.x, p.y - a.y, p.z - a.z };   # Vector3Subtract(p, a)
    float d00 = (v0.x*v0.x + v0.y*v0.y + v0.z*v0.z);    # Vector3DotProduct(v0, v0)
    float d01 = (v0.x*v1.x + v0.y*v1.y + v0.z*v1.z);    # Vector3DotProduct(v0, v1)
    float d11 = (v1.x*v1.x + v1.y*v1.y + v1.z*v1.z);    # Vector3DotProduct(v1, v1)
    float d20 = (v2.x*v0.x + v2.y*v0.y + v2.z*v0.z);    # Vector3DotProduct(v2, v0)
    float d21 = (v2.x*v1.x + v2.y*v1.y + v2.z*v1.z);    # Vector3DotProduct(v2, v1)

    float denom = d00*d11 - d01*d01;

    result.y = (d11*d20 - d01*d21)/denom;
    result.z = (d00*d21 - d01*d20)/denom;
    result.x = 1.0f - (result.z + result.y);

    return result;
}

# Projects a Vector3 from screen space into object space
# NOTE: We are avoiding calling other raymath functions despite available
RMAPI Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
{
    Vector3 result = { 0 };

    # Calculate unprojected matrix (multiply view matrix by projection matrix) and invert it
    Matrix matViewProj = {      # MatrixMultiply(view, projection);
        view.m0*projection.m0 + view.m1*projection.m4 + view.m2*projection.m8 + view.m3*projection.m12,
        view.m0*projection.m1 + view.m1*projection.m5 + view.m2*projection.m9 + view.m3*projection.m13,
        view.m0*projection.m2 + view.m1*projection.m6 + view.m2*projection.m10 + view.m3*projection.m14,
        view.m0*projection.m3 + view.m1*projection.m7 + view.m2*projection.m11 + view.m3*projection.m15,
        view.m4*projection.m0 + view.m5*projection.m4 + view.m6*projection.m8 + view.m7*projection.m12,
        view.m4*projection.m1 + view.m5*projection.m5 + view.m6*projection.m9 + view.m7*projection.m13,
        view.m4*projection.m2 + view.m5*projection.m6 + view.m6*projection.m10 + view.m7*projection.m14,
        view.m4*projection.m3 + view.m5*projection.m7 + view.m6*projection.m11 + view.m7*projection.m15,
        view.m8*projection.m0 + view.m9*projection.m4 + view.m10*projection.m8 + view.m11*projection.m12,
        view.m8*projection.m1 + view.m9*projection.m5 + view.m10*projection.m9 + view.m11*projection.m13,
        view.m8*projection.m2 + view.m9*projection.m6 + view.m10*projection.m10 + view.m11*projection.m14,
        view.m8*projection.m3 + view.m9*projection.m7 + view.m10*projection.m11 + view.m11*projection.m15,
        view.m12*projection.m0 + view.m13*projection.m4 + view.m14*projection.m8 + view.m15*projection.m12,
        view.m12*projection.m1 + view.m13*projection.m5 + view.m14*projection.m9 + view.m15*projection.m13,
        view.m12*projection.m2 + view.m13*projection.m6 + view.m14*projection.m10 + view.m15*projection.m14,
        view.m12*projection.m3 + view.m13*projection.m7 + view.m14*projection.m11 + view.m15*projection.m15 };

    # Calculate inverted matrix -> MatrixInvert(matViewProj);
    # Cache the matrix values (speed optimization)
    float a00 = matViewProj.m0, a01 = matViewProj.m1, a02 = matViewProj.m2, a03 = matViewProj.m3;
    float a10 = matViewProj.m4, a11 = matViewProj.m5, a12 = matViewProj.m6, a13 = matViewProj.m7;
    float a20 = matViewProj.m8, a21 = matViewProj.m9, a22 = matViewProj.m10, a23 = matViewProj.m11;
    float a30 = matViewProj.m12, a31 = matViewProj.m13, a32 = matViewProj.m14, a33 = matViewProj.m15;

    float b00 = a00*a11 - a01*a10;
    float b01 = a00*a12 - a02*a10;
    float b02 = a00*a13 - a03*a10;
    float b03 = a01*a12 - a02*a11;
    float b04 = a01*a13 - a03*a11;
    float b05 = a02*a13 - a03*a12;
    float b06 = a20*a31 - a21*a30;
    float b07 = a20*a32 - a22*a30;
    float b08 = a20*a33 - a23*a30;
    float b09 = a21*a32 - a22*a31;
    float b10 = a21*a33 - a23*a31;
    float b11 = a22*a33 - a23*a32;

    # Calculate the invert determinant (inlined to avoid double-caching)
    float invDet = 1.0f/(b00*b11 - b01*b10 + b02*b09 + b03*b08 - b04*b07 + b05*b06);

    Matrix matViewProjInv = {
        (a11*b11 - a12*b10 + a13*b09)*invDet,
        (-a01*b11 + a02*b10 - a03*b09)*invDet,
        (a31*b05 - a32*b04 + a33*b03)*invDet,
        (-a21*b05 + a22*b04 - a23*b03)*invDet,
        (-a10*b11 + a12*b08 - a13*b07)*invDet,
        (a00*b11 - a02*b08 + a03*b07)*invDet,
        (-a30*b05 + a32*b02 - a33*b01)*invDet,
        (a20*b05 - a22*b02 + a23*b01)*invDet,
        (a10*b10 - a11*b08 + a13*b06)*invDet,
        (-a00*b10 + a01*b08 - a03*b06)*invDet,
        (a30*b04 - a31*b02 + a33*b00)*invDet,
        (-a20*b04 + a21*b02 - a23*b00)*invDet,
        (-a10*b09 + a11*b07 - a12*b06)*invDet,
        (a00*b09 - a01*b07 + a02*b06)*invDet,
        (-a30*b03 + a31*b01 - a32*b00)*invDet,
        (a20*b03 - a21*b01 + a22*b00)*invDet };

    # Create quaternion from source point
    Quaternion quat = { source.x, source.y, source.z, 1.0f };

    # Multiply quat point by unprojecte matrix
    Quaternion qtransformed = {     # QuaternionTransform(quat, matViewProjInv)
        matViewProjInv.m0*quat.x + matViewProjInv.m4*quat.y + matViewProjInv.m8*quat.z + matViewProjInv.m12*quat.w,
        matViewProjInv.m1*quat.x + matViewProjInv.m5*quat.y + matViewProjInv.m9*quat.z + matViewProjInv.m13*quat.w,
        matViewProjInv.m2*quat.x + matViewProjInv.m6*quat.y + matViewProjInv.m10*quat.z + matViewProjInv.m14*quat.w,
        matViewProjInv.m3*quat.x + matViewProjInv.m7*quat.y + matViewProjInv.m11*quat.z + matViewProjInv.m15*quat.w };

    # Normalized world points in vectors
    result.x = qtransformed.x/qtransformed.w;
    result.y = qtransformed.y/qtransformed.w;
    result.z = qtransformed.z/qtransformed.w;

    return result;
}

# Get Vector3 as float array
RMAPI float3 Vector3ToFloatV(Vector3 v)
{
    float3 buffer = { 0 };

    buffer.v[0] = v.x;
    buffer.v[1] = v.y;
    buffer.v[2] = v.z;

    return buffer;
}

# Compute the direction of a refracted ray where v specifies the
# normalized direction of the incoming ray, n specifies the
# normalized normal vector of the interface of two optical media,
# and r specifies the ratio of the refractive index of the medium
# from where the ray comes to the refractive index of the medium
# on the other side of the surface
RMAPI Vector3 Vector3Refract(Vector3 v, Vector3 n, float r)
{
    Vector3 result = { 0 };

    float dot = v.x*n.x + v.y*n.y + v.z*n.z;
    float d = 1.0f - r*r*(1.0f - dot*dot);

    if (d >= 0.0f)
    {
        d = sqrtf(d);
        v.x = r*v.x - (r*dot + d)*n.x;
        v.y = r*v.y - (r*dot + d)*n.y;
        v.z = r*v.z - (r*dot + d)*n.z;

        result = v;
    }

    return result;
}

#----------------------------------------------------------------------------------
# Module Functions Definition - Matrix math
#----------------------------------------------------------------------------------

# Compute matrix determinant
RMAPI float MatrixDeterminant(Matrix mat)
{
    float result = 0.0f;

    # Cache the matrix values (speed optimization)
    float a00 = mat.m0, a01 = mat.m1, a02 = mat.m2, a03 = mat.m3;
    float a10 = mat.m4, a11 = mat.m5, a12 = mat.m6, a13 = mat.m7;
    float a20 = mat.m8, a21 = mat.m9, a22 = mat.m10, a23 = mat.m11;
    float a30 = mat.m12, a31 = mat.m13, a32 = mat.m14, a33 = mat.m15;

    result = a30*a21*a12*a03 - a20*a31*a12*a03 - a30*a11*a22*a03 + a10*a31*a22*a03 +
             a20*a11*a32*a03 - a10*a21*a32*a03 - a30*a21*a02*a13 + a20*a31*a02*a13 +
             a30*a01*a22*a13 - a00*a31*a22*a13 - a20*a01*a32*a13 + a00*a21*a32*a13 +
             a30*a11*a02*a23 - a10*a31*a02*a23 - a30*a01*a12*a23 + a00*a31*a12*a23 +
             a10*a01*a32*a23 - a00*a11*a32*a23 - a20*a11*a02*a33 + a10*a21*a02*a33 +
             a20*a01*a12*a33 - a00*a21*a12*a33 - a10*a01*a22*a33 + a00*a11*a22*a33;

    return result;
}

# Get the trace of the matrix (sum of the values along the diagonal)
RMAPI float MatrixTrace(Matrix mat)
{
    float result = (mat.m0 + mat.m5 + mat.m10 + mat.m15);

    return result;
}

# Transposes provided matrix
RMAPI Matrix MatrixTranspose(Matrix mat)
{
    Matrix result = { 0 };

    result.m0 = mat.m0;
    result.m1 = mat.m4;
    result.m2 = mat.m8;
    result.m3 = mat.m12;
    result.m4 = mat.m1;
    result.m5 = mat.m5;
    result.m6 = mat.m9;
    result.m7 = mat.m13;
    result.m8 = mat.m2;
    result.m9 = mat.m6;
    result.m10 = mat.m10;
    result.m11 = mat.m14;
    result.m12 = mat.m3;
    result.m13 = mat.m7;
    result.m14 = mat.m11;
    result.m15 = mat.m15;

    return result;
}

# Invert provided matrix
RMAPI Matrix MatrixInvert(Matrix mat)
{
    Matrix result = { 0 };

    # Cache the matrix values (speed optimization)
    float a00 = mat.m0, a01 = mat.m1, a02 = mat.m2, a03 = mat.m3;
    float a10 = mat.m4, a11 = mat.m5, a12 = mat.m6, a13 = mat.m7;
    float a20 = mat.m8, a21 = mat.m9, a22 = mat.m10, a23 = mat.m11;
    float a30 = mat.m12, a31 = mat.m13, a32 = mat.m14, a33 = mat.m15;

    float b00 = a00*a11 - a01*a10;
    float b01 = a00*a12 - a02*a10;
    float b02 = a00*a13 - a03*a10;
    float b03 = a01*a12 - a02*a11;
    float b04 = a01*a13 - a03*a11;
    float b05 = a02*a13 - a03*a12;
    float b06 = a20*a31 - a21*a30;
    float b07 = a20*a32 - a22*a30;
    float b08 = a20*a33 - a23*a30;
    float b09 = a21*a32 - a22*a31;
    float b10 = a21*a33 - a23*a31;
    float b11 = a22*a33 - a23*a32;

    # Calculate the invert determinant (inlined to avoid double-caching)
    float invDet = 1.0f/(b00*b11 - b01*b10 + b02*b09 + b03*b08 - b04*b07 + b05*b06);

    result.m0 = (a11*b11 - a12*b10 + a13*b09)*invDet;
    result.m1 = (-a01*b11 + a02*b10 - a03*b09)*invDet;
    result.m2 = (a31*b05 - a32*b04 + a33*b03)*invDet;
    result.m3 = (-a21*b05 + a22*b04 - a23*b03)*invDet;
    result.m4 = (-a10*b11 + a12*b08 - a13*b07)*invDet;
    result.m5 = (a00*b11 - a02*b08 + a03*b07)*invDet;
    result.m6 = (-a30*b05 + a32*b02 - a33*b01)*invDet;
    result.m7 = (a20*b05 - a22*b02 + a23*b01)*invDet;
    result.m8 = (a10*b10 - a11*b08 + a13*b06)*invDet;
    result.m9 = (-a00*b10 + a01*b08 - a03*b06)*invDet;
    result.m10 = (a30*b04 - a31*b02 + a33*b00)*invDet;
    result.m11 = (-a20*b04 + a21*b02 - a23*b00)*invDet;
    result.m12 = (-a10*b09 + a11*b07 - a12*b06)*invDet;
    result.m13 = (a00*b09 - a01*b07 + a02*b06)*invDet;
    result.m14 = (-a30*b03 + a31*b01 - a32*b00)*invDet;
    result.m15 = (a20*b03 - a21*b01 + a22*b00)*invDet;

    return result;
}

# Get identity matrix
RMAPI Matrix MatrixIdentity(void)
{
    Matrix result = { 1.0f, 0.0f, 0.0f, 0.0f,
                      0.0f, 1.0f, 0.0f, 0.0f,
                      0.0f, 0.0f, 1.0f, 0.0f,
                      0.0f, 0.0f, 0.0f, 1.0f };

    return result;
}

# Add two matrices
RMAPI Matrix MatrixAdd(Matrix left, Matrix right)
{
    Matrix result = { 0 };

    result.m0 = left.m0 + right.m0;
    result.m1 = left.m1 + right.m1;
    result.m2 = left.m2 + right.m2;
    result.m3 = left.m3 + right.m3;
    result.m4 = left.m4 + right.m4;
    result.m5 = left.m5 + right.m5;
    result.m6 = left.m6 + right.m6;
    result.m7 = left.m7 + right.m7;
    result.m8 = left.m8 + right.m8;
    result.m9 = left.m9 + right.m9;
    result.m10 = left.m10 + right.m10;
    result.m11 = left.m11 + right.m11;
    result.m12 = left.m12 + right.m12;
    result.m13 = left.m13 + right.m13;
    result.m14 = left.m14 + right.m14;
    result.m15 = left.m15 + right.m15;

    return result;
}

# Subtract two matrices (left - right)
RMAPI Matrix MatrixSubtract(Matrix left, Matrix right)
{
    Matrix result = { 0 };

    result.m0 = left.m0 - right.m0;
    result.m1 = left.m1 - right.m1;
    result.m2 = left.m2 - right.m2;
    result.m3 = left.m3 - right.m3;
    result.m4 = left.m4 - right.m4;
    result.m5 = left.m5 - right.m5;
    result.m6 = left.m6 - right.m6;
    result.m7 = left.m7 - right.m7;
    result.m8 = left.m8 - right.m8;
    result.m9 = left.m9 - right.m9;
    result.m10 = left.m10 - right.m10;
    result.m11 = left.m11 - right.m11;
    result.m12 = left.m12 - right.m12;
    result.m13 = left.m13 - right.m13;
    result.m14 = left.m14 - right.m14;
    result.m15 = left.m15 - right.m15;

    return result;
}

# Get translation matrix
MatrixTranslate â† {ğ•Šxâ€¿yâ€¿z:
  [
    1â€¿0â€¿0â€¿x
    0â€¿1â€¿0â€¿y
    0â€¿0â€¿1â€¿z
    0â€¿0â€¿0â€¿1
  ]
}

# Create rotation matrix from axis and angle
# NOTE: Angle should be provided in radians
MatrixRotate â† {angleğ•Šaxis: xâ€¿yâ€¿zâ†axis
  {axisÃ·â†©ğ•©}âŸ(âˆ§Â´â‰ âŸœ0â€¿1)+Â´âŒ¾(Ã—Ëœ)axis

  sinres â† Sin angle
  cosres â† Cos angle
  t â† 1 - cosres

  râ†[
    âŸ¨  cosres â‹„ -zÃ—sinres â‹„  yÃ—sinresâŸ©
    âŸ¨zÃ—sinres â‹„    cosres â‹„ -xÃ—sinresâŸ©
    âŸ¨zÃ—sinres â‹„    cosres â‹„ -xÃ—sinresâŸ©
  ]+tÃ—Ã—âŒœËœaxis
  
  âˆ¾[
    râ‹ˆlâ†3â¥Š0
    lâ‹ˆ1
  ]
}

# Get x-rotation matrix
# NOTE: Angle must be provided in radians
RMAPI Matrix MatrixRotateX(float angle)
{
    Matrix result = { 1.0f, 0.0f, 0.0f, 0.0f,
                      0.0f, 1.0f, 0.0f, 0.0f,
                      0.0f, 0.0f, 1.0f, 0.0f,
                      0.0f, 0.0f, 0.0f, 1.0f }; # MatrixIdentity()

    float cosres = cosf(angle);
    float sinres = sinf(angle);

    result.m5 = cosres;
    result.m6 = sinres;
    result.m9 = -sinres;
    result.m10 = cosres;

    return result;
}

# Get y-rotation matrix
# NOTE: Angle must be provided in radians
RMAPI Matrix MatrixRotateY(float angle)
{
    Matrix result = { 1.0f, 0.0f, 0.0f, 0.0f,
                      0.0f, 1.0f, 0.0f, 0.0f,
                      0.0f, 0.0f, 1.0f, 0.0f,
                      0.0f, 0.0f, 0.0f, 1.0f }; # MatrixIdentity()

    float cosres = cosf(angle);
    float sinres = sinf(angle);

    result.m0 = cosres;
    result.m2 = -sinres;
    result.m8 = sinres;
    result.m10 = cosres;

    return result;
}

# Get z-rotation matrix
# NOTE: Angle must be provided in radians
RMAPI Matrix MatrixRotateZ(float angle)
{
    Matrix result = { 1.0f, 0.0f, 0.0f, 0.0f,
                      0.0f, 1.0f, 0.0f, 0.0f,
                      0.0f, 0.0f, 1.0f, 0.0f,
                      0.0f, 0.0f, 0.0f, 1.0f }; # MatrixIdentity()

    float cosres = cosf(angle);
    float sinres = sinf(angle);

    result.m0 = cosres;
    result.m1 = sinres;
    result.m4 = -sinres;
    result.m5 = cosres;

    return result;
}


# Get xyz-rotation matrix
# NOTE: Angle must be provided in radians
RMAPI Matrix MatrixRotateXYZ(Vector3 angle)
{
    Matrix result = { 1.0f, 0.0f, 0.0f, 0.0f,
                      0.0f, 1.0f, 0.0f, 0.0f,
                      0.0f, 0.0f, 1.0f, 0.0f,
                      0.0f, 0.0f, 0.0f, 1.0f }; # MatrixIdentity()

    float cosz = cosf(-angle.z);
    float sinz = sinf(-angle.z);
    float cosy = cosf(-angle.y);
    float siny = sinf(-angle.y);
    float cosx = cosf(-angle.x);
    float sinx = sinf(-angle.x);

    result.m0 = cosz*cosy;
    result.m1 = (cosz*siny*sinx) - (sinz*cosx);
    result.m2 = (cosz*siny*cosx) + (sinz*sinx);

    result.m4 = sinz*cosy;
    result.m5 = (sinz*siny*sinx) + (cosz*cosx);
    result.m6 = (sinz*siny*cosx) - (cosz*sinx);

    result.m8 = -siny;
    result.m9 = cosy*sinx;
    result.m10= cosy*cosx;

    return result;
}

# Get zyx-rotation matrix
# NOTE: Angle must be provided in radians
RMAPI Matrix MatrixRotateZYX(Vector3 angle)
{
    Matrix result = { 0 };

    float cz = cosf(angle.z);
    float sz = sinf(angle.z);
    float cy = cosf(angle.y);
    float sy = sinf(angle.y);
    float cx = cosf(angle.x);
    float sx = sinf(angle.x);

    result.m0 = cz*cy;
    result.m4 = cz*sy*sx - cx*sz;
    result.m8 = sz*sx + cz*cx*sy;
    result.m12 = 0;

    result.m1 = cy*sz;
    result.m5 = cz*cx + sz*sy*sx;
    result.m9 = cx*sz*sy - cz*sx;
    result.m13 = 0;

    result.m2 = -sy;
    result.m6 = cy*sx;
    result.m10 = cy*cx;
    result.m14 = 0;

    result.m3 = 0;
    result.m7 = 0;
    result.m11 = 0;
    result.m15 = 1;

    return result;
}

# Get scaling matrix
RMAPI Matrix MatrixScale(float x, float y, float z)
{
    Matrix result = { x, 0.0f, 0.0f, 0.0f,
                      0.0f, y, 0.0f, 0.0f,
                      0.0f, 0.0f, z, 0.0f,
                      0.0f, 0.0f, 0.0f, 1.0f };

    return result;
}

# Get perspective projection matrix
RMAPI Matrix MatrixFrustum(double left, double right, double bottom, double top, double near, double far)
{
    Matrix result = { 0 };

    float rl = (float)(right - left);
    float tb = (float)(top - bottom);
    float fn = (float)(far - near);

    result.m0 = ((float)near*2.0f)/rl;
    result.m1 = 0.0f;
    result.m2 = 0.0f;
    result.m3 = 0.0f;

    result.m4 = 0.0f;
    result.m5 = ((float)near*2.0f)/tb;
    result.m6 = 0.0f;
    result.m7 = 0.0f;

    result.m8 = ((float)right + (float)left)/rl;
    result.m9 = ((float)top + (float)bottom)/tb;
    result.m10 = -((float)far + (float)near)/fn;
    result.m11 = -1.0f;

    result.m12 = 0.0f;
    result.m13 = 0.0f;
    result.m14 = -((float)far*(float)near*2.0f)/fn;
    result.m15 = 0.0f;

    return result;
}

# Get perspective projection matrix
# NOTE: Fovy angle must be provided in radians
RMAPI Matrix MatrixPerspective(double fovy, double aspect, double near, double far)
{
    Matrix result = { 0 };

    double top = near*tan(fovy*0.5);
    double bottom = -top;
    double right = top*aspect;
    double left = -right;

    # MatrixFrustum(-right, right, -top, top, near, far);
    float rl = (float)(right - left);
    float tb = (float)(top - bottom);
    float fn = (float)(far - near);

    result.m0 = ((float)near*2.0f)/rl;
    result.m5 = ((float)near*2.0f)/tb;
    result.m8 = ((float)right + (float)left)/rl;
    result.m9 = ((float)top + (float)bottom)/tb;
    result.m10 = -((float)far + (float)near)/fn;
    result.m11 = -1.0f;
    result.m14 = -((float)far*(float)near*2.0f)/fn;

    return result;
}

# Get orthographic projection matrix
MatrixOrtho â† {ğ•Šleftâ€¿rightâ€¿bottomâ€¿topâ€¿nearâ€¿far:
  [
    âŸ¨ 2 â‹„ 0 â‹„  0 â‹„ - right+left   âŸ©Ã·right-left
    âŸ¨ 0 â‹„ 2 â‹„  0 â‹„ -   top+bottom âŸ©Ã·  top-bottom
    âŸ¨ 0 â‹„ 0 â‹„ Â¯2 â‹„ -   far+near   âŸ©Ã·  far-near
    âŸ¨ 0 â‹„ 0 â‹„  0 â‹„ 1              âŸ©
  ]
}

# Get camera look-at matrix (view matrix)
RMAPI Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
{
    Matrix result = { 0 };

    float length = 0.0f;
    float ilength = 0.0f;

    # Vector3Subtract(eye, target)
    Vector3 vz = { eye.x - target.x, eye.y - target.y, eye.z - target.z };

    # Vector3Normalize(vz)
    Vector3 v = vz;
    length = sqrtf(v.x*v.x + v.y*v.y + v.z*v.z);
    if (length == 0.0f) length = 1.0f;
    ilength = 1.0f/length;
    vz.x *= ilength;
    vz.y *= ilength;
    vz.z *= ilength;

    # Vector3CrossProduct(up, vz)
    Vector3 vx = { up.y*vz.z - up.z*vz.y, up.z*vz.x - up.x*vz.z, up.x*vz.y - up.y*vz.x };

    # Vector3Normalize(x)
    v = vx;
    length = sqrtf(v.x*v.x + v.y*v.y + v.z*v.z);
    if (length == 0.0f) length = 1.0f;
    ilength = 1.0f/length;
    vx.x *= ilength;
    vx.y *= ilength;
    vx.z *= ilength;

    # Vector3CrossProduct(vz, vx)
    Vector3 vy = { vz.y*vx.z - vz.z*vx.y, vz.z*vx.x - vz.x*vx.z, vz.x*vx.y - vz.y*vx.x };

    result.m0 = vx.x;
    result.m1 = vy.x;
    result.m2 = vz.x;
    result.m3 = 0.0f;
    result.m4 = vx.y;
    result.m5 = vy.y;
    result.m6 = vz.y;
    result.m7 = 0.0f;
    result.m8 = vx.z;
    result.m9 = vy.z;
    result.m10 = vz.z;
    result.m11 = 0.0f;
    result.m12 = -(vx.x*eye.x + vx.y*eye.y + vx.z*eye.z);   # Vector3DotProduct(vx, eye)
    result.m13 = -(vy.x*eye.x + vy.y*eye.y + vy.z*eye.z);   # Vector3DotProduct(vy, eye)
    result.m14 = -(vz.x*eye.x + vz.y*eye.y + vz.z*eye.z);   # Vector3DotProduct(vz, eye)
    result.m15 = 1.0f;

    return result;
}

# Get float array of matrix data
RMAPI float16 MatrixToFloatV(Matrix mat)
{
    float16 result = { 0 };

    result.v[0] = mat.m0;
    result.v[1] = mat.m1;
    result.v[2] = mat.m2;
    result.v[3] = mat.m3;
    result.v[4] = mat.m4;
    result.v[5] = mat.m5;
    result.v[6] = mat.m6;
    result.v[7] = mat.m7;
    result.v[8] = mat.m8;
    result.v[9] = mat.m9;
    result.v[10] = mat.m10;
    result.v[11] = mat.m11;
    result.v[12] = mat.m12;
    result.v[13] = mat.m13;
    result.v[14] = mat.m14;
    result.v[15] = mat.m15;

    return result;
}

#----------------------------------------------------------------------------------
# Module Functions Definition - Quaternion math
#----------------------------------------------------------------------------------

# Add two quaternions
RMAPI Quaternion QuaternionAdd(Quaternion q1, Quaternion q2)
{
    Quaternion result = {q1.x + q2.x, q1.y + q2.y, q1.z + q2.z, q1.w + q2.w};

    return result;
}

# Add quaternion and float value
RMAPI Quaternion QuaternionAddValue(Quaternion q, float add)
{
    Quaternion result = {q.x + add, q.y + add, q.z + add, q.w + add};

    return result;
}

# Subtract two quaternions
RMAPI Quaternion QuaternionSubtract(Quaternion q1, Quaternion q2)
{
    Quaternion result = {q1.x - q2.x, q1.y - q2.y, q1.z - q2.z, q1.w - q2.w};

    return result;
}

# Subtract quaternion and float value
RMAPI Quaternion QuaternionSubtractValue(Quaternion q, float sub)
{
    Quaternion result = {q.x - sub, q.y - sub, q.z - sub, q.w - sub};

    return result;
}

# Get identity quaternion
RMAPI Quaternion QuaternionIdentity(void)
{
    Quaternion result = { 0.0f, 0.0f, 0.0f, 1.0f };

    return result;
}

# Computes the length of a quaternion
RMAPI float QuaternionLength(Quaternion q)
{
    float result = sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);

    return result;
}

# Normalize provided quaternion
RMAPI Quaternion QuaternionNormalize(Quaternion q)
{
    Quaternion result = { 0 };

    float length = sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);
    if (length == 0.0f) length = 1.0f;
    float ilength = 1.0f/length;

    result.x = q.x*ilength;
    result.y = q.y*ilength;
    result.z = q.z*ilength;
    result.w = q.w*ilength;

    return result;
}

# Invert provided quaternion
RMAPI Quaternion QuaternionInvert(Quaternion q)
{
    Quaternion result = q;

    float lengthSq = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w;

    if (lengthSq != 0.0f)
    {
        float invLength = 1.0f/lengthSq;

        result.x *= -invLength;
        result.y *= -invLength;
        result.z *= -invLength;
        result.w *= invLength;
    }

    return result;
}

# Calculate two quaternion multiplication
RMAPI Quaternion QuaternionMultiply(Quaternion q1, Quaternion q2)
{
    Quaternion result = { 0 };

    float qax = q1.x, qay = q1.y, qaz = q1.z, qaw = q1.w;
    float qbx = q2.x, qby = q2.y, qbz = q2.z, qbw = q2.w;

    result.x = qax*qbw + qaw*qbx + qay*qbz - qaz*qby;
    result.y = qay*qbw + qaw*qby + qaz*qbx - qax*qbz;
    result.z = qaz*qbw + qaw*qbz + qax*qby - qay*qbx;
    result.w = qaw*qbw - qax*qbx - qay*qby - qaz*qbz;

    return result;
}

# Scale quaternion by float value
RMAPI Quaternion QuaternionScale(Quaternion q, float mul)
{
    Quaternion result = { 0 };

    result.x = q.x*mul;
    result.y = q.y*mul;
    result.z = q.z*mul;
    result.w = q.w*mul;

    return result;
}

# Divide two quaternions
RMAPI Quaternion QuaternionDivide(Quaternion q1, Quaternion q2)
{
    Quaternion result = { q1.x/q2.x, q1.y/q2.y, q1.z/q2.z, q1.w/q2.w };

    return result;
}

# Calculate linear interpolation between two quaternions
RMAPI Quaternion QuaternionLerp(Quaternion q1, Quaternion q2, float amount)
{
    Quaternion result = { 0 };

    result.x = q1.x + amount*(q2.x - q1.x);
    result.y = q1.y + amount*(q2.y - q1.y);
    result.z = q1.z + amount*(q2.z - q1.z);
    result.w = q1.w + amount*(q2.w - q1.w);

    return result;
}

# Calculate slerp-optimized interpolation between two quaternions
RMAPI Quaternion QuaternionNlerp(Quaternion q1, Quaternion q2, float amount)
{
    Quaternion result = { 0 };

    # QuaternionLerp(q1, q2, amount)
    result.x = q1.x + amount*(q2.x - q1.x);
    result.y = q1.y + amount*(q2.y - q1.y);
    result.z = q1.z + amount*(q2.z - q1.z);
    result.w = q1.w + amount*(q2.w - q1.w);

    # QuaternionNormalize(q);
    Quaternion q = result;
    float length = sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);
    if (length == 0.0f) length = 1.0f;
    float ilength = 1.0f/length;

    result.x = q.x*ilength;
    result.y = q.y*ilength;
    result.z = q.z*ilength;
    result.w = q.w*ilength;

    return result;
}

# Calculates spherical linear interpolation between two quaternions
RMAPI Quaternion QuaternionSlerp(Quaternion q1, Quaternion q2, float amount)
{
    Quaternion result = { 0 };

    float cosHalfTheta = q1.x*q2.x + q1.y*q2.y + q1.z*q2.z + q1.w*q2.w;

    if (cosHalfTheta < 0)
    {
        q2.x = -q2.x; q2.y = -q2.y; q2.z = -q2.z; q2.w = -q2.w;
        cosHalfTheta = -cosHalfTheta;
    }

    if (fabsf(cosHalfTheta) >= 1.0f) result = q1;
    else if (cosHalfTheta > 0.95f) result = QuaternionNlerp(q1, q2, amount);
    else
    {
        float halfTheta = acosf(cosHalfTheta);
        float sinHalfTheta = sqrtf(1.0f - cosHalfTheta*cosHalfTheta);

        if (fabsf(sinHalfTheta) < 0.001f)
        {
            result.x = (q1.x*0.5f + q2.x*0.5f);
            result.y = (q1.y*0.5f + q2.y*0.5f);
            result.z = (q1.z*0.5f + q2.z*0.5f);
            result.w = (q1.w*0.5f + q2.w*0.5f);
        }
        else
        {
            float ratioA = sinf((1 - amount)*halfTheta)/sinHalfTheta;
            float ratioB = sinf(amount*halfTheta)/sinHalfTheta;

            result.x = (q1.x*ratioA + q2.x*ratioB);
            result.y = (q1.y*ratioA + q2.y*ratioB);
            result.z = (q1.z*ratioA + q2.z*ratioB);
            result.w = (q1.w*ratioA + q2.w*ratioB);
        }
    }

    return result;
}

# Calculate quaternion based on the rotation from one vector to another
RMAPI Quaternion QuaternionFromVector3ToVector3(Vector3 from, Vector3 to)
{
    Quaternion result = { 0 };

    float cos2Theta = (from.x*to.x + from.y*to.y + from.z*to.z);    # Vector3DotProduct(from, to)
    Vector3 cross = { from.y*to.z - from.z*to.y, from.z*to.x - from.x*to.z, from.x*to.y - from.y*to.x }; # Vector3CrossProduct(from, to)

    result.x = cross.x;
    result.y = cross.y;
    result.z = cross.z;
    result.w = 1.0f + cos2Theta;

    # QuaternionNormalize(q);
    # NOTE: Normalize to essentially nlerp the original and identity to 0.5
    Quaternion q = result;
    float length = sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);
    if (length == 0.0f) length = 1.0f;
    float ilength = 1.0f/length;

    result.x = q.x*ilength;
    result.y = q.y*ilength;
    result.z = q.z*ilength;
    result.w = q.w*ilength;

    return result;
}

# Get a quaternion for a given rotation matrix
RMAPI Quaternion QuaternionFromMatrix(Matrix mat)
{
    Quaternion result = { 0 };

    float fourWSquaredMinus1 = mat.m0 + mat.m5 + mat.m10;
    float fourXSquaredMinus1 = mat.m0 - mat.m5 - mat.m10;
    float fourYSquaredMinus1 = mat.m5 - mat.m0 - mat.m10;
    float fourZSquaredMinus1 = mat.m10 - mat.m0 - mat.m5;

    int biggestIndex = 0;
    float fourBiggestSquaredMinus1 = fourWSquaredMinus1;
    if (fourXSquaredMinus1 > fourBiggestSquaredMinus1)
    {
        fourBiggestSquaredMinus1 = fourXSquaredMinus1;
        biggestIndex = 1;
    }

    if (fourYSquaredMinus1 > fourBiggestSquaredMinus1)
    {
        fourBiggestSquaredMinus1 = fourYSquaredMinus1;
        biggestIndex = 2;
    }

    if (fourZSquaredMinus1 > fourBiggestSquaredMinus1)
    {
        fourBiggestSquaredMinus1 = fourZSquaredMinus1;
        biggestIndex = 3;
    }

    float biggestVal = sqrtf(fourBiggestSquaredMinus1 + 1.0f) * 0.5f;
    float mult = 0.25f / biggestVal;

    switch (biggestIndex)
    {
        case 0:
            result.w = biggestVal;
            result.x = (mat.m6 - mat.m9) * mult;
            result.y = (mat.m8 - mat.m2) * mult;
            result.z = (mat.m1 - mat.m4) * mult;
            break;
        case 1:
            result.x = biggestVal;
            result.w = (mat.m6 - mat.m9) * mult;
            result.y = (mat.m1 + mat.m4) * mult;
            result.z = (mat.m8 + mat.m2) * mult;
            break;
        case 2:
            result.y = biggestVal;
            result.w = (mat.m8 - mat.m2) * mult;
            result.x = (mat.m1 + mat.m4) * mult;
            result.z = (mat.m6 + mat.m9) * mult;
            break;
        case 3:
            result.z = biggestVal;
            result.w = (mat.m1 - mat.m4) * mult;
            result.x = (mat.m8 + mat.m2) * mult;
            result.y = (mat.m6 + mat.m9) * mult;
            break;
    }

    return result;
}

# Get a matrix for a given quaternion
RMAPI Matrix QuaternionToMatrix(Quaternion q)
{
    Matrix result = { 1.0f, 0.0f, 0.0f, 0.0f,
                      0.0f, 1.0f, 0.0f, 0.0f,
                      0.0f, 0.0f, 1.0f, 0.0f,
                      0.0f, 0.0f, 0.0f, 1.0f }; # MatrixIdentity()

    float a2 = q.x*q.x;
    float b2 = q.y*q.y;
    float c2 = q.z*q.z;
    float ac = q.x*q.z;
    float ab = q.x*q.y;
    float bc = q.y*q.z;
    float ad = q.w*q.x;
    float bd = q.w*q.y;
    float cd = q.w*q.z;

    result.m0 = 1 - 2*(b2 + c2);
    result.m1 = 2*(ab + cd);
    result.m2 = 2*(ac - bd);

    result.m4 = 2*(ab - cd);
    result.m5 = 1 - 2*(a2 + c2);
    result.m6 = 2*(bc + ad);

    result.m8 = 2*(ac + bd);
    result.m9 = 2*(bc - ad);
    result.m10 = 1 - 2*(a2 + b2);

    return result;
}

# Get rotation quaternion for an angle and axis
# NOTE: Angle must be provided in radians
RMAPI Quaternion QuaternionFromAxisAngle(Vector3 axis, float angle)
{
    Quaternion result = { 0.0f, 0.0f, 0.0f, 1.0f };

    float axisLength = sqrtf(axis.x*axis.x + axis.y*axis.y + axis.z*axis.z);

    if (axisLength != 0.0f)
    {
        angle *= 0.5f;

        float length = 0.0f;
        float ilength = 0.0f;

        # Vector3Normalize(axis)
        Vector3 v = axis;
        length = sqrtf(v.x*v.x + v.y*v.y + v.z*v.z);
        if (length == 0.0f) length = 1.0f;
        ilength = 1.0f/length;
        axis.x *= ilength;
        axis.y *= ilength;
        axis.z *= ilength;

        float sinres = sinf(angle);
        float cosres = cosf(angle);

        result.x = axis.x*sinres;
        result.y = axis.y*sinres;
        result.z = axis.z*sinres;
        result.w = cosres;

        # QuaternionNormalize(q);
        Quaternion q = result;
        length = sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);
        if (length == 0.0f) length = 1.0f;
        ilength = 1.0f/length;
        result.x = q.x*ilength;
        result.y = q.y*ilength;
        result.z = q.z*ilength;
        result.w = q.w*ilength;
    }
}

# Get the rotation angle and axis for a given quaternion
QuaternionToAxisAngle â† {ğ•Šxâ€¿yâ€¿zâ€¿w:
    
  
    # QuaternionNormalize(q);
    
    Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))âŸ(1<|w)ğ•©

  resAxis  â† 3â¥Š0
  resAngle â† 2*acosf(q.w);
  den      â† Sin Cosâ¼w

  if (den > 0.0001f)
  {
      resAxis.x = q.x/den;
      resAxis.y = q.y/den;
      resAxis.z = q.z/den;
  }
  else
  {
      # This occurs when the angle is zero.
      # Not a problem: just set an arbitrary normalized axis.
      resAxis.x = 1.0f;
  }

  *outAxis = resAxis;
  *outAngle = resAngle;
}

# Get the quaternion equivalent to Euler angles
# NOTE: Rotation order is ZYX
QuaternionFromEuler{pitchâ€¿yawâ€¿roll:
  aâ†Â¯1â€¿1â€¿Â¯1â€¿1Ã—Ã—Â´Ë˜(Sin Cosâ¼)âŒ¾(0â€¿0â‰âŠ¢)4âŠ¸â¥ŠË˜Cos ğ•©Ã·2
  aÃ—          Ã—Â´Ë˜(Cos Sinâ¼)âŒ¾(0â€¿0â‰âŠ¢)4âŠ¸â¥ŠË˜Sin ğ•©Ã·2
}

# Get the Euler angles equivalent to quaternion (roll, pitch, yaw)
# NOTE: Angles are returned in a Vector3 struct in radians
QuaternionToEuler â† {ğ•Šxâ€¿yâ€¿zâ€¿w:
  âŸ¨
    # Roll (x-axis rotation)
    Atan2Â´âŸ¨2Ã—(wÃ—x)+yÃ—z â‹„ 1-2Ã—+Â´Ã—Ëœxâ€¿yâŸ©

    # Pitch (y-axis rotation)
    Sinâ¼Â¯1âŒŠ1âŒˆ2Ã—-Â´Ã—Ë2â€¿2â¥Šğ•©

    # Yaw (z-axis rotation)
    Atan2Â´âŸ¨2Ã—+Â´Ã—Â´Â¨2(â†‘â‹ˆâ†“)ğ•© â‹„ 1-2Ã—+Â´Ã—Ëœyâ€¿zâŸ©
  âŸ©
}

# Transform a quaternion given a transformation matrix
QuaternionTransform{qğ•Šmat: # â†’Quaternion
  qâŠ¸Ã—Ë˜mat
}

# Check whether two given quaternions are almost equal
QuaternionEquals â† âˆ¨Â´Â·âˆ§Ë(|-â‰Ë˜+)â‰¤epsilonÃ—1âŒˆâŒˆâ—‹|




# testing (moved later to testing.bqn)
#â€¢Show 1â€¿2â€¿3 Vector3OrthoNormalize 4â€¿5â€¿6

#â€¢Show (-5+â†•4) QuaternionEquals 5+â†•4
#â€¢Show (-4+â†•4) QuaternionEquals 5+â†•4


# in MatrixOrtho please put x+b in the same order as x-b




# 1âŠ¸-âŒ¾(Ã—Ëœ) â†’ (Sin Cosâ¼)
# -âŸœ1âŒ¾(Ã—Ëœ) â†’ (Cos Sinâ¼)
#Sinâ€¿Cosâ†â€¢math
#â€¢Show (Cos Sinâ¼)âŸ â€¢Show â€¢math.Cos 1
#â€¢Show â€¢math.Sin 2
#â€¢Show 1âŠ¸-âŒ¾(Ã—Ëœ)
#Sin Cosâ¼