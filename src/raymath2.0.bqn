# GOAL make raylib functions work on arbitrary vectors and matricies
# ALSO after i finish translating everything, i will try making arbitrary matricies
# aswell as switch from raylib's collumn model to leading axis model.
# Also raylib only uses 4x4 matricies, i'm considering limiting this since it pads matricies a lot

âŸ¨MPâ‹„MatrixLookAt
 MatrixScaleâ‹„MatrixRotate
 GetCameraMatrix2D
 MatrixRotateXâ‹„MatrixRotateYâ‹„MatrixRotateZ
 Vector2Transform
âŸ©â‡

Sinâ€¿Cosâ†â€¢math

âŸ¨MP,MatrixDeterminantâ‡DeterminantâŸ© â† â€¢Import "imports/bqn-libs/matrix.bqn"

# Get camera look-at matrix (view matrix)
# returns Matrix
MatrixLookAt â† {ğ•Šeyeâ€¿targetâ€¿up: # v3 v3 v3
  vz â† {ğ•©Ã·1âŸ(0=âŠ¢)+Â´âŒ¾(â‹†âŸœ2)ğ•©} eye-target
  vx â† {ğ•©Ã·1âŸ(0=âŠ¢)+Â´âŒ¾(â‹†âŸœ2)ğ•©} -Â´Ã—Â´Ë˜1â€¿Â¯1âŒ½âŒœupâ€¿vz
  vy â† -Â´Ã—Â´Ë˜1â€¿Â¯1âŒ½âŒœvzâ€¿vx

  [
    âŸ¨vx.x â‹„ vy.x â‹„ vz.x â‹„ 0âŸ©
    âŸ¨vx.y â‹„ vy.y â‹„ vz.y â‹„ 0âŸ©
    âŸ¨vx.z â‹„ vy.z â‹„ vz.z â‹„ 0âŸ©
    1âˆ¾Ëœ-eyeâŠ¸Ã—Â¨vxâ€¿vyâ€¿vz
  ]
}


# Get translation matrix
MatrixTranslate â† {ğ•Šxâ€¿yâ€¿z:[# v3 â†’ Matrix
  1â€¿0â€¿0â€¿x
  0â€¿1â€¿0â€¿y
  0â€¿0â€¿1â€¿z
  0â€¿0â€¿0â€¿1
]}

# Get scaling matrix
MatrixScale â† {ğ•Šxâ€¿yâ€¿z:(ğ•©âˆ¾1)âŒ¾(0â€¿0âŠ¸â‰)4â€¿4â¥Š0}

# Create rotation matrix from axis and angle
# NOTE: Angle should be provided in radians
MatrixRotate â† {ğ•Šaxisâ€¿angle: # v3 f
  xâ€¿yâ€¿z â† (+Â´axisâ‹†2)Ã·âŸœâˆšËœâŸ(âˆ§Â´2â†•âŠ¸â‰ âŠ£)axis

  sinres â† â€¢math.Sin angle
  cosres â† â€¢math.Cos angle
  m â† ((Â¬cosres)Ã—Ã—âŒœËœxâ€¿yâ€¿z)+(cosresÂ¨âŒ¾(0â€¿0âŠ¸â‰)3â€¿3â¥Šsinres)Ã—[
    âŸ¨ 1 â‹„-z â‹„ yâŸ©
    âŸ¨ z â‹„ 1 â‹„-xâŸ©
    âŸ¨-y â‹„ x â‹„ 1âŸ©
  ]
  âˆ¾[ m â‹„3â¥Š0
    3â¥Š0â‹„1  ]
}

# NOTE: Angle must be provided in radians
MatrixRotateXâ€¿MatrixRotateYâ€¿MatrixRotateZ â† {
    _RotMat â† {cut2x2OfMat On2x2Arr _ğ•£ degrees:
        (ğ”½(â‹ˆâŸœ-Â´â‰âŒ½)(â€¢math.Cosâˆ¾â€¢math.Sin)ğ•©)âŒ¾(ğ•¨âŠ¸âŠË˜ğ•¨âŠ¸âŠ)=âŒœËœâ†•4
    }
    âŸ¨1â€¿2 â‰_RotMat âŠ¢
     0â€¿2 âŠ¢_RotMat âŠ¢
     0â€¿1 â‰_RotMat âŠ¢âŸ©
}

### rcore.c functions

# Get camera 2d transform matrix
GetCameraMatrix2D â† {ğ•Šcamera: # camera2d
  # The camera in world-space is set by
  #   1. Move it to target
  #   2. Rotate by -rotation and scale by (1/zoom)
  #      When setting higher scale, it's more intuitive for the world to become bigger (= camera become smaller),
  #      not for the camera getting bigger, hence the invert. Same deal with rotation.
  #   3. Move it by (-offset);
  #      Offset defines target transform relative to screen, but since we're effectively "moving" screen (camera)
  #      we need to do it into opposite direction (inverse transform)
    
  # Having camera transform in world-space, inverse of it gives the modelview transform.
  # Since (A*B*C)' = C'*B'*A', the modelview is
  #   1. Move to offset
  #   2. Rotate and Scale
  #   3. Move by -target
  origin      â† MatrixTranslate-(1âŠ‘camera)âˆ¾0
  rotation    â† MatrixRotate 0â€¿0â€¿1â‹ˆ Ï€Ã·180Ã—2âŠ‘camera
  scale       â† MatrixScale 1âˆ¾Ëœ2â¥Š3âŠ‘camera
  translation â† MatrixTranslate 0âˆ¾ËœâŠ‘camera
  matTransform â† originâ€¿scaleâ€¿rotation MPÂ´âŠ¸MP translation
}






###############################################################################################
#
#   raymath v1.5 - Math functions to work with Vector2, Vector3, Matrix and Quaternions
#
#   CONVENTIONS:
#     - Matrix structure is defined as row-major (memory layout) but parameters naming AND all
#       math operations performed by the library consider the structure as it was column-major
#       It is like transposed versions of the matrices are used for all the maths
#       It benefits some functions making them cache-friendly and also avoids matrix
#       transpositions sometimes required by OpenGL
#       Example: In memory order, row0 is [m0 m4 m8 m12] but in semantic math row0 is [m0 m1 m2 m3]
#     - Functions are always self-contained, no function use another raymath function inside,
#       required code is directly re-implemented inside
#     - Functions input parameters are always received by value (2 unavoidable exceptions)
#     - Functions use always a "result" variable for return
#     - Functions are always defined inline
#     - Angles are always in radians (DEG2RAD/RAD2DEG macros provided for convenience)
#
###############################################################################################

#----------------------------------------------------------------------------------
# removed from raylib
#----------------------------------------------------------------------------------

## Removed QuaternionToMatrix and QuaternionFromMatrix:
# they have been said to be innacurate by ray - maintainer of raylib. 
# Under "module: raymath" at https://github.com/raysan5/raylib/discussions/2952 

# Too simple:
# Clamp â† Vector2Clamp â† maxâŒŠminâŒˆx
Vector2Add         â† Vector2AddValue â† Vector3Add â† QuaternionAdd â† QuaternionAddValue â† +
Vector2Multiply    â† Vector2Scale â† QuaternionScale â† Ã—
Vector2Subtract    â† Vector2SubtractValue â† Vector2Negate â† Vector3Negate â† QuaternionSubtract â† QuaternionSubtractValue â† -
Vector2Divide      â† Vector2Invert â† Vector3Divide â† Vector3Invert â† QuaternionDivide â† Ã·
Vector3DistanceSqr â† Vector2DistanceSqr â† Ã—ËœVectorDistance
MatrixTranspose    â† â‰
MatrixIdentity     â† =âŒœËœâ†•âˆ˜4
MatrixInvert       â† matrix.Inverse
MatrixToFloatV    â† â¥Š

# extended
Vector2Length     â† Vector3Length     â† QuaternionLength â† VectorLength
Vector2LengthSqr  â† Vector3LengthSqr  â† VectorLengthSqr
Vector2DotProduct â† Vector3DotProduct â† VectorDotProduct 
Vector2Distance   â† Vector3Distance   â† VectorDistance
Vector2Lerp       â† Vector3Lerp       â† QuaternionLerp â† VectorLerp
Vector2Transform  â† Vector3Transform  â† VectorTransform
Vector2ClampValue â† Vector3ClampValue â† VectorClampValue
Vector2Equals     â† Vector3Equals     â† VectorEquals
Vector2Normalize  â† Vector3Normalize  â† QuaternionNormalize â† VectorNormalize




quaternionIdentity â† Â¯4â†‘1


Vector3AddValue
Vector3Subtract
Vector3SubtractValue
Vector3Scale
Vector3Multiply
Vector3CrossProduct


#----------------------------------------------------------------------------------
# Defines
#----------------------------------------------------------------------------------

epsilon â† 1eÂ¯6
rad2deg â† Ã·deg2rad â† Ï€Ã·180


#----------------------------------------------------------------------------------
# Types and Structures Definition
#----------------------------------------------------------------------------------

# Vector2 type
typedef struct Vector2 {
    float x;
    float y;
} Vector2;

# Vector3 type
typedef struct Vector3 {
    float x;
    float y;
    float z;
} Vector3;

# Vector4 type
typedef struct Vector4 {
    float x;
    float y;
    float z;
    float w;
} Vector4;

# Quaternion type
typedef Vector4 Quaternion;

# Matrix type (OpenGL style 4x4 - right handed, column major)
typedef struct Matrix {
    float m0, m4, m8, m12;      # Matrix first row (4 components)
    float m1, m5, m9, m13;      # Matrix second row (4 components)
    float m2, m6, m10, m14;     # Matrix third row (4 components)
    float m3, m7, m11, m15;     # Matrix fourth row (4 components)
} Matrix;

âŸ¨Sin, Cos, Tan, Atan2âŸ©â†â€¢math

#----------------------------------------------------------------------------------
# Module Functions Definition - Utils math
#----------------------------------------------------------------------------------

# Calculate linear interpolation between two floats
Lerp â† {ğ•Šstartâ€¿endâ€¿amount:
  start + amount Ã— end - start
}

# Normalize input value within input range
Normalize â† {ğ•Švalueâ€¿startâ€¿end:
  Ã·Â´valueâ€¿end-start
}

# Remap input value within input range to output range
Remap â† {ğ•Švalueâ€¿inputStartâ€¿inputEndâ€¿outputStartâ€¿outputEnd:
  {ğ•©Ã—Ã·Â´valueâ€¿inputEnd-inputStart}âŒ¾(-âŸœoutputEnd) outputStart
}

# Wrap input value from min to max
Wrap â† {ğ•Švalueâ€¿minâ€¿max:
  (value - maxâŠ¸- Ã— valueâŠ¸- âŒŠâˆ˜Ã· maxâŠ¸-) min
}

# Check whether two given floats are almost equal
FloatEquals â† {ğ•Šxâ€¿y:
  (|x-y) â‰¤ epsilonÃ—1âŒˆxâŒˆâ—‹|y
}

#----------------------------------------------------------------------------------
# Module Functions Definition - Vector2 math
#----------------------------------------------------------------------------------

# Calculate vector length
VectorLength â† +Â´âŒ¾(Ã—Ëœ)

# ğ•¨ğ•Šğ•©: Calculate two vectors dot product
#  ğ•Šğ•©: Calculate vector square length
VectorDotProductÂ â† VectorLengthSqr â† +Â´Ã—Ëœ

# Calculate distance between two vectors
VectorDistance â† +Â´âŒ¾(Ã—Ëœ)-

# Calculate angle between two vectors
# NOTE: Angle is calculated from origin point (0, 0)
Vector2Angle â† Atan2Â´-

# Calculate angle defined by a two vectors line
# NOTE: Parameters need to be normalized
# Current implementation should be aligned with glm::angle
Vector2LineAngle â† Cosâ¼1âŒˆÂ¯1âŒˆ+Â´âˆ˜Ã— # start ğ•Š end

# Transforms a Vector2 by a given Matrix
VectorTransform â† {ğ•Švâ€¿matrix:
  xâ€¿yâ€¿z â† 3â†‘v
  +Ëxâ€¿yâ€¿zâ€¿1 Ã— 0â€¿1âŠ¸âŠË˜matrix
}

# Calculate linear interpolation between two vectors
VectorLerp â† {ğ•Šv1â€¿v2â€¿amount:
  amountâŠ¸Ã—âŒ¾(-âŸœv1)v2
}

# Calculate reflected vector to normal
Vector2Reflect â† {normalğ•Šv: # vector vector
  v-2Ã—normalÃ—+Â´vÃ—normal
}

# Rotate vector by angle:  angle ğ•Š vector2
Vector2Rotate â† (Cosâˆ¾Sin)âŠ¸(-Â´âˆ˜Ã—â‹ˆÂ·+Â´âŒ½âŠ¸Ã—)

# Move Vector towards target
Vector2MoveTowards â† {ğ•Švâ€¿targetâ€¿maxDistance:

  d â† dxâ€¿dy â† target - v;
  value â† +Â´Ã—Ëœd

  {
    (value = 0) âˆ¨ (maxDistance â‰¥ 0) âˆ§ value â‰¤ Ã—ËœmaxDistance?
      target
    ;
    v+maxDistanceÃ—dÃ·âˆšvalue
  }
}

# Clamp the magnitude of the vector between two min and max values
VectorClampValue â† {ğ•Švâ€¿minâ€¿max:
  length â† +Â´âˆ˜â¥ŠâŒ¾(Ã—Ëœ)v
  {lengthâ‰¤0?v;
    length < min?
      vÃ—minÃ·length;
    length > max?
      vÃ—maxÃ·length;
    v
  }
}
#â€¢Show VectorClampValue âŸ¨2â€¿2â€¿2â€¿2,10,22âŸ©

# Check whether two given vectors are almost equal
VectorEquals â† âˆ§Â´|âˆ˜-â‰¤epsilonÃ—1âŒˆâŒˆâ—‹|

#----------------------------------------------------------------------------------
# Module Functions Definition - Vector3 math
#----------------------------------------------------------------------------------

# Calculate one vector perpendicular vector
RMAPI Vector3 Vector3Perpendicular(Vector3 v)
{
    Vector3 result = { 0 };

    float min = (float) fabs(v.x);
    Vector3 cardinalAxis = {1.0f, 0.0f, 0.0f};

    if (fabsf(v.y) < min)
    {
        min = (float) fabs(v.y);
        Vector3 tmp = {0.0f, 1.0f, 0.0f};
        cardinalAxis = tmp;
    }

    if (fabsf(v.z) < min)
    {
        Vector3 tmp = {0.0f, 0.0f, 1.0f};
        cardinalAxis = tmp;
    }

    # Cross product between vectors
    result.x = v.y*cardinalAxis.z - v.z*cardinalAxis.y;
    result.y = v.z*cardinalAxis.x - v.x*cardinalAxis.z;
    result.z = v.x*cardinalAxis.y - v.y*cardinalAxis.x;

    return result;
}

# Calculate angle between two vectors
RMAPI float Vector3Angle(Vector3 v1, Vector3 v2)
{
    float result = 0.0f;

    Vector3 cross = { v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x };
    float len = sqrtf(cross.x*cross.x + cross.y*cross.y + cross.z*cross.z);
    float dot = (v1.x*v2.x + v1.y*v2.y + v1.z*v2.z);
    result = atan2f(len, dot);

    return result;
}

# Normalize provided vector
VectorNormalize â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))

# Orthonormalize provided vectors
# Makes vectors normalized and orthogonal to each other
# Gram-Schmidt function implementation
Vector3OrthoNormalize{v1ğ•Šv2:
  # Vector3Normalize v1
  F â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))

  # Vector3CrossProductÂ´v1â€¿v2
  G â† {(Â¯1âŒ½ğ•¨)Ã—1âŒ½ğ•©}{ğ”½Ëœ-ğ”½}
  
  v1 GËœâ—‹F v1 FâŠ¸G v2
}






# Transforms a Vector2 by a given Matrix
VectorTransform â† {ğ•Švâ€¿matrix:
  xâ€¿yâ€¿z â† 3â†‘v
  +Ëxâ€¿yâ€¿zâ€¿1 Ã— (â†•â‰ v)âŠ¸âŠË˜matrix
}

# Transform a vector by quaternion rotation
Vector3RotateByQuaternion â† {qğ•Šv: xâ€¿yâ€¿zâ€¿wâ†q
  MPâŸœv MPâŸœq[
    [ [x â‹„ -y â‹„ -z â‹„  w] â‹„ [ y â‹„ x â‹„ -w â‹„ -z] â‹„ [ z â‹„  w â‹„ x â‹„  y] ]
    [ [y â‹„  x â‹„  w â‹„  z] â‹„ [-x â‹„ y â‹„ -z â‹„  w] â‹„ [-w â‹„  z â‹„ y â‹„ -x] ]
    [ [z â‹„ -w â‹„  x â‹„ -y] â‹„ [ w â‹„ z â‹„  y â‹„  x] â‹„ [-x â‹„ -y â‹„ z â‹„  w] ]
  ]
}

# Rotates a vector around an axis
RMAPI Vector3 Vector3RotateByAxisAngle(Vector3 v, Vector3 axis, float angle)
{
    # Using Euler-Rodrigues Formula
    # Ref.: https:#en.wikipedia.org/w/index.php?title=Euler%E2%80%93Rodrigues_formula

    Vector3 result = v;

    # Vector3Normalize(axis);
    float length = sqrtf(axis.x * axis.x + axis.y * axis.y + axis.z * axis.z);
    if (length == 0.0f) length = 1.0f;
    float ilength = 1.0f / length;
    axis.x *= ilength;
    axis.y *= ilength;
    axis.z *= ilength;

    angle /= 2.0f;
    float a = sinf(angle);
    float b = axis.x * a;
    float c = axis.y * a;
    float d = axis.z * a;
    a = cosf(angle);
    Vector3 w = { b, c, d };

    # Vector3CrossProduct(w, v)
    Vector3 wv = { w.y * v.z - w.z * v.y, w.z * v.x - w.x * v.z, w.x * v.y - w.y * v.x };

    # Vector3CrossProduct(w, wv)
    Vector3 wwv = { w.y * wv.z - w.z * wv.y, w.z * wv.x - w.x * wv.z, w.x * wv.y - w.y * wv.x };

    # Vector3Scale(wv, 2 * a)
    a *= 2;
    wv.x *= a;
    wv.y *= a;
    wv.z *= a;

    # Vector3Scale(wwv, 2)
    wwv.x *= 2;
    wwv.y *= 2;
    wwv.z *= 2;

    result.x += wv.x;
    result.y += wv.y;
    result.z += wv.z;

    result.x += wwv.x;
    result.y += wwv.y;
    result.z += wwv.z;

    return result;
}

# Calculate reflected vector to normal
RMAPI Vector3 Vector3Reflect(Vector3 v, Vector3 normal)
{
    Vector3 result = { 0 };

    # I is the original vector
    # N is the normal of the incident plane
    # R = I - (2*N*(DotProduct[I, N]))

    float dotProduct = (v.x*normal.x + v.y*normal.y + v.z*normal.z);

    result.x = v.x - (2.0f*normal.x)*dotProduct;
    result.y = v.y - (2.0f*normal.y)*dotProduct;
    result.z = v.z - (2.0f*normal.z)*dotProduct;

    return result;
}

# Get min value for each pair of components
RMAPI Vector3 Vector3Min(Vector3 v1, Vector3 v2)
{
    Vector3 result = { 0 };

    result.x = fminf(v1.x, v2.x);
    result.y = fminf(v1.y, v2.y);
    result.z = fminf(v1.z, v2.z);

    return result;
}

# Get max value for each pair of components
RMAPI Vector3 Vector3Max(Vector3 v1, Vector3 v2)
{
    Vector3 result = { 0 };

    result.x = fmaxf(v1.x, v2.x);
    result.y = fmaxf(v1.y, v2.y);
    result.z = fmaxf(v1.z, v2.z);

    return result;
}

# Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c)
# NOTE: Assumes P is on the plane of the triangle
RMAPI Vector3 Vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
{
    Vector3 result = { 0 };

    Vector3 v0 = { b.x - a.x, b.y - a.y, b.z - a.z };   # Vector3Subtract(b, a)
    Vector3 v1 = { c.x - a.x, c.y - a.y, c.z - a.z };   # Vector3Subtract(c, a)
    Vector3 v2 = { p.x - a.x, p.y - a.y, p.z - a.z };   # Vector3Subtract(p, a)
    float d00 = (v0.x*v0.x + v0.y*v0.y + v0.z*v0.z);    # Vector3DotProduct(v0, v0)
    float d01 = (v0.x*v1.x + v0.y*v1.y + v0.z*v1.z);    # Vector3DotProduct(v0, v1)
    float d11 = (v1.x*v1.x + v1.y*v1.y + v1.z*v1.z);    # Vector3DotProduct(v1, v1)
    float d20 = (v2.x*v0.x + v2.y*v0.y + v2.z*v0.z);    # Vector3DotProduct(v2, v0)
    float d21 = (v2.x*v1.x + v2.y*v1.y + v2.z*v1.z);    # Vector3DotProduct(v2, v1)

    float denom = d00*d11 - d01*d01;

    result.y = (d11*d20 - d01*d21)/denom;
    result.z = (d00*d21 - d01*d20)/denom;
    result.x = 1.0f - (result.z + result.y);

    return result;
}

# Projects a Vector3 from screen space into object space
# NOTE: We are avoiding calling other raymath functions despite available
RMAPI Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
{
    Vector3 result = { 0 };

    # Calculate unprojected matrix (multiply view matrix by projection matrix) and invert it
    matViewProj â† veiw MP projection

    # Calculate inverted matrix -> MatrixInvert(matViewProj);
    # Cache the matrix values (speed optimization)
    a00 â† matViewProj.m0, a01 = matViewProj.m1, a02 = matViewProj.m2, a03 = matViewProj.m3;
    a10 â† matViewProj.m4, a11 = matViewProj.m5, a12 = matViewProj.m6, a13 = matViewProj.m7;
    a20 â† matViewProj.m8, a21 = matViewProj.m9, a22 = matViewProj.m10, a23 = matViewProj.m11;
    a30 â† matViewProj.m12, a31 = matViewProj.m13, a32 = matViewProj.m14, a33 = matViewProj.m15;

    b00 = a00*a11 - a01*a10;
    b01 = a00*a12 - a02*a10;
    b02 = a00*a13 - a03*a10;
    b03 = a01*a12 - a02*a11;
    b04 = a01*a13 - a03*a11;
    b05 = a02*a13 - a03*a12;
    b06 = a20*a31 - a21*a30;
    b07 = a20*a32 - a22*a30;
    b08 = a20*a33 - a23*a30;
    b09 = a21*a32 - a22*a31;
    b10 = a21*a33 - a23*a31;
    b11 = a22*a33 - a23*a32;

    
    matViewProjInv â† Inverse matViewProj

    # Create quaternion from source point
    Quaternion quat = { source.x, source.y, source.z, 1.0f };

    # Multiply quat point by unprojecte matrix
    Quaternion qtransformed = {     # QuaternionTransform(quat, matViewProjInv)
        matViewProjInv.m0*quat.x + matViewProjInv.m4*quat.y + matViewProjInv.m8*quat.z + matViewProjInv.m12*quat.w,
        matViewProjInv.m1*quat.x + matViewProjInv.m5*quat.y + matViewProjInv.m9*quat.z + matViewProjInv.m13*quat.w,
        matViewProjInv.m2*quat.x + matViewProjInv.m6*quat.y + matViewProjInv.m10*quat.z + matViewProjInv.m14*quat.w,
        matViewProjInv.m3*quat.x + matViewProjInv.m7*quat.y + matViewProjInv.m11*quat.z + matViewProjInv.m15*quat.w };

    # Normalized world points in vectors
    result.x = qtransformed.x/qtransformed.w;
    result.y = qtransformed.y/qtransformed.w;
    result.z = qtransformed.z/qtransformed.w;

    return result;
}

# Get Vector3 as float array
RMAPI float3 Vector3ToFloatV(Vector3 v)
{
    float3 buffer = { 0 };

    buffer.v[0] = v.x;
    buffer.v[1] = v.y;
    buffer.v[2] = v.z;

    return buffer;
}

# Compute the direction of a refracted ray where v specifies the
# normalized direction of the incoming ray, n specifies the
# normalized normal vector of the interface of two optical media,
# and r specifies the ratio of the refractive index of the medium
# from where the ray comes to the refractive index of the medium
# on the other side of the surface
RMAPI Vector3 Vector3Refract(Vector3 v, Vector3 n, float r)
{
    Vector3 result = { 0 };

    float dot = v.x*n.x + v.y*n.y + v.z*n.z;
    float d = 1.0f - r*r*(1.0f - dot*dot);

    if (d >= 0.0f)
    {
        d = sqrtf(d);
        v.x = r*v.x - (r*dot + d)*n.x;
        v.y = r*v.y - (r*dot + d)*n.y;
        v.z = r*v.z - (r*dot + d)*n.z;

        result = v;
    }

    return result;
}

#----------------------------------------------------------------------------------
# Module Functions Definition - Matrix math
#----------------------------------------------------------------------------------

# Get the trace of the matrix (sum of the values along the diagonal)
MatrixTrace â† +Â´0â€¿0â‰âŠ¢

MatrixAdd

# Get translation matrix
MatrixTranslate â† {ğ•Šxâ€¿yâ€¿z:
  [
    1â€¿0â€¿0â€¿x
    0â€¿1â€¿0â€¿y
    0â€¿0â€¿1â€¿z
    0â€¿0â€¿0â€¿1
  ]
}

# Create rotation matrix from axis and angle
# NOTE: Angle should be provided in radians
MatrixRotate â† {angleğ•Šaxis: xâ€¿yâ€¿zâ†axis
  {axisÃ·â†©ğ•©}âŸ(âˆ§Â´â‰ âŸœ0â€¿1)+Â´âŒ¾(Ã—Ëœ)axis

  sinres â† Sin angle
  cosres â† Cos angle
  t â† 1 - cosres

  râ†[
    âŸ¨  cosres â‹„ -zÃ—sinres â‹„  yÃ—sinresâŸ©
    âŸ¨zÃ—sinres â‹„    cosres â‹„ -xÃ—sinresâŸ©
    âŸ¨zÃ—sinres â‹„    cosres â‹„ -xÃ—sinresâŸ©
  ]+tÃ—Ã—âŒœËœaxis
  
  âˆ¾[
    râ‹ˆlâ†3â¥Š0
    lâ‹ˆ1
  ]
}

# Get x-rotation matrix
# NOTE: Angle must be provided in radians
RMAPI Matrix MatrixRotateX(float angle)
{
    Matrix result = { 1.0f, 0.0f, 0.0f, 0.0f,
                      0.0f, 1.0f, 0.0f, 0.0f,
                      0.0f, 0.0f, 1.0f, 0.0f,
                      0.0f, 0.0f, 0.0f, 1.0f }; # MatrixIdentity()

    float cosres = cosf(angle);
    float sinres = sinf(angle);

    result.m5 = cosres;
    result.m6 = sinres;
    result.m9 = -sinres;
    result.m10 = cosres;

    return result;
}

# Get y-rotation matrix
# NOTE: Angle must be provided in radians
RMAPI Matrix MatrixRotateY(float angle)
{
    Matrix result = { 1.0f, 0.0f, 0.0f, 0.0f,
                      0.0f, 1.0f, 0.0f, 0.0f,
                      0.0f, 0.0f, 1.0f, 0.0f,
                      0.0f, 0.0f, 0.0f, 1.0f }; # MatrixIdentity()

    float cosres = cosf(angle);
    float sinres = sinf(angle);

    result.m0 = cosres;
    result.m2 = -sinres;
    result.m8 = sinres;
    result.m10 = cosres;

    return result;
}

# Get xyz-rotation matrix
# NOTE: Angle must be provided in radians
MatrixRotateXYZ {angle:
  âŸ¨
    cxâ€¿cyâ€¿cz
    sxâ€¿syâ€¿sz
  âŸ© â† (Cosâ‰Sin) -angle
  [
    âŸ¨
      czÃ—cy
      (czÃ—syÃ—sx) - szÃ—cx
      (czÃ—syÃ—cx) + szÃ—sx
    âŸ©
    âŸ¨
      szÃ—cy
      (sxÃ—syÃ—sz) + czÃ—cx
      (cxÃ—syÃ—sz) - czÃ—sx
    âŸ©
    âŸ¨
      -sy
      cyÃ—sx
      cyÃ—cx
    âŸ©
  ]âŒ¾(â‰3â€¿3âŠ¸â†‘)=âŒœËœâ†•4
}

# Get zyx-rotation matrix
# NOTE: Angle must be provided in radians
MatrixRotateZYX{ğ•Šangle:
  âŸ¨
    cxâ€¿cyâ€¿cz
    sxâ€¿syâ€¿sz
  âŸ© â† (Cosâ‰Sin) angle

  [
    âŸ¨
      czÃ—cy
      (czÃ—syÃ—sx) - cxÃ—sz
      (szÃ—sx) + czÃ—cxÃ—sy
    âŸ©
    âŸ¨
      cyÃ—sz
      (czÃ—cx) + szÃ—syÃ—sx
      (cxÃ—szÃ—sy) - czÃ—sx
    âŸ©
    âŸ¨
      -sy
      cyÃ—sx
      cyÃ—cx
    âŸ©
  ]âŒ¾(â‰3â€¿3âŠ¸â†‘)=âŒœËœâ†•4
}

# Get scaling matrix
MatrixScale â† {ğ•Šxâ€¿yâ€¿z:
  ğ•©âŠ¸Ã—âŒ¾(3â€¿3âŠ¸â†‘)=âŒœËœâ†•4
}

# Get perspective projection matrix
MatrixFrustum â† {ğ•Šleftâ€¿rightâ€¿bottomâ€¿topâ€¿nearâ€¿far:
  [
    âŸ¨nearÃ—2 â‹„ 0      â‹„ right+left   â‹„ 0         âŸ©Ã·right-left
    âŸ¨0      â‹„ nearÃ—2 â‹„   top+bottom â‹„ 0         âŸ©Ã·  top-bottom
    âŸ¨0      â‹„ 0      â‹„   far+near   â‹„ farÃ—nearÃ—2âŸ©Ã· near-far
    âŸ¨0      â‹„ 0      â‹„ Â¯1           â‹„ 0         âŸ©
  ]
}

# Get perspective projection matrix
# NOTE: Fovy angle must be provided in radians
MatrixPerspective â† {ğ•Šfovyâ€¿aspectâ€¿nearâ€¿far:
  top    â† nearÃ—Tan fovyÃ·2
  bottom â† -top
  right  â† topÃ—aspect
  left   â† -right

  # MatrixFrustum(-right, right, -top, top, near, far);
  [
    âŸ¨nearÃ—2 â‹„ 0      â‹„ right+left   â‹„ 0         âŸ©Ã·right-left
    âŸ¨0      â‹„ nearÃ—2 â‹„   top+bottom â‹„ 0         âŸ©Ã·  top-bottom
    âŸ¨0      â‹„ 0      â‹„   far+near   â‹„ farÃ—nearÃ—2âŸ©Ã· near-far
    âŸ¨0      â‹„ 0      â‹„ Â¯1           â‹„ 0         âŸ©
  ]
}

# Get orthographic projection matrix
MatrixOrtho â† {ğ•Šleftâ€¿rightâ€¿bottomâ€¿topâ€¿nearâ€¿far:
  [
    âŸ¨ 2 â‹„ 0 â‹„  0 â‹„ - right+left   âŸ©Ã·right-left
    âŸ¨ 0 â‹„ 2 â‹„  0 â‹„ -   top+bottom âŸ©Ã·  top-bottom
    âŸ¨ 0 â‹„ 0 â‹„  2 â‹„     far+near   âŸ©Ã·  near-far
    âŸ¨ 0 â‹„ 0 â‹„  0 â‹„ 1              âŸ©
  ]
}

# Get camera look-at matrix (view matrix)
MatrixLookAt â† {ğ•Šeyeâ€¿targetâ€¿up: # all are Vector3

    # Vector3Normalize(vz)
    vz â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ)) eye-target

    # Vector3CrossProduct(up, vz)
    vx â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ)) up{(Â¯1âŒ½ğ•¨)Ã—1âŒ½ğ•©}{ğ”½Ëœ-ğ”½}vz
    
    # Vector3CrossProduct(vz, vx)
    vy â† vz {(Â¯1âŒ½ğ•¨)Ã—1âŒ½ğ•©}{ğ”½Ëœ-ğ”½} vx
  [
    vxâˆ¾+Â´-vxÃ—eye
    vyâˆ¾+Â´-vyÃ—eye
    vzâˆ¾+Â´-vzÃ—eye
    Â¯4â†‘1
  ]
}

#----------------------------------------------------------------------------------
# Module Functions Definition - Quaternion math
#----------------------------------------------------------------------------------

# Invert provided quaternion
QuaternionInvert â† Â¯1â€¿Â¯1â€¿Â¯1â€¿1Ã—Ã·âŸœ(0âŠ¸=âŠ¸++Â´â—‹(Ã—Ëœ))

MP â† +Ëâˆ˜Ã—â‰1â€¿âˆ
# Calculate two quaternion multiplication
QuaternionMultiply â† {q2ğ•Šq1:
  qaxâ€¿qayâ€¿qazâ€¿qaw â† q1
  qbxâ€¿qbyâ€¿qbzâ€¿qbw â† q2
  âŸ¨
    +Â´ âŸ¨ qawÃ—qbx â‹„ -qazÃ—qby â‹„  qayÃ—qbz â‹„ qaxÃ—qbwâŸ©
    +Â´ âŸ¨ qazÃ—qbx â‹„  qawÃ—qby â‹„ -qaxÃ—qbz â‹„ qayÃ—qbwâŸ©
    +Â´ âŸ¨-qayÃ—qbx â‹„  qaxÃ—qby â‹„  qawÃ—qbz â‹„ qazÃ—qbwâŸ©
    +Â´ âŸ¨-qaxÃ—qbx â‹„ -qayÃ—qby â‹„ -qazÃ—qbz â‹„ qawÃ—qbwâŸ©
  âŸ©
}
QuaternionMultiply2 â† {q2ğ•Šq1: xâ€¿yâ€¿zâ€¿wâ†ğ•©
  ğ•¨ MPËœ [
    âŸ¨ w â‹„ -z â‹„  y â‹„ xâŸ©
    âŸ¨ z â‹„  w â‹„ -x â‹„ yâŸ©
    âŸ¨-y â‹„  x â‹„  w â‹„ zâŸ©
    âŸ¨-x â‹„ -y â‹„ -z â‹„ wâŸ©
  ]
}

# Calculate slerp-optimized interpolation between two quaternions
QuaternionNlerp â† {ğ•Šq1â€¿q2â€¿amount:
  Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))amountâŠ¸Ã—âŒ¾(-âŸœq1)q2
}

# Calculates spherical linear interpolation between two quaternions
QuaternionSlerp â† {ğ•Šq1â€¿q2â€¿amount:
  cosHalfTheta â† +Â´q1Ã—q2
  cosHalfThetaâ€¿q2Ã—â†©-âŸ(cosHalfTheta<0)1

  {
    1 â‰¤ cosHalfTheta? q1
  ;
    0.95 < cosHalfTheta? Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))amountâŠ¸Ã—âŒ¾(-âŸœq1)q2
  ;
    sinHalfTheta â† Sin halfTheta â† Cosâ¼cosHalfTheta
    0.001 â‰¤ sinHalfTheta?
    +Ë[q1â‹„q2]Ã—sinHalfThetaÃ·ËœSin halfThetaÃ—Â¬âŠ¸â‹ˆamount
  ;
    (+ËÃ·â‰ )[q1,q2]
  }
}

# Calculate quaternion based on the rotation from one vector to another
QuaternionFromVector3ToVector â† {toğ•Šfrom:
  cos2Theta â† +ËfromÃ—to
  cross     â† from{(Â¯1âŒ½ğ•¨)Ã—1âŒ½ğ•©}{ğ”½Ëœ-ğ”½}to

  # QuaternionNormalize(q);
  # NOTE: Normalize to essentially nlerp the original and identity to 0.5
  Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))crossâˆ¾1+cos2Theta
}


# Get rotation quaternion for an angle and axis
# NOTE: Angle must be provided in radians
QuaternionFromAxisAngle â† {angleğ•Šaxis:
  axisNormalized â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ)) axis    
  Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ)) (Cosâˆ¾ËœaxisNormalizedÃ—Sin) angleÃ·2
}

# Get the rotation angle and axis for a given quaternion
QuaternionToAxisAngle â† {ğ•Šxâ€¿yâ€¿zâ€¿w:
  # QuaternionNormalize(q);
    
  Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))âŸ(1<|w)ğ•©

  resAngle â† 2Ã—Cos w

  # when the angle is zero just set an arbitrary normalized axis. (0â€¿0â€¿1)
  resAxis â† (Sin Cosâ¼w){ğ•¨Ã·Ëœ3â†‘q}âŸ(â‰ âŸœ0)0â€¿0â€¿1
  
  resAxisâ€¿resAngle
}

# Get the quaternion equivalent to Euler angles
# NOTE: Rotation order is ZYX
QuaternionFromEuler{pitchâ€¿yawâ€¿roll:
  F â† Ã—Â´Ë˜(Sin Cosâ¼)âŒ¾(0â€¿0â‰âŠ¢)4âŠ¸â¥ŠË˜
  Â¯1â€¿1â€¿Â¯1â€¿1Ã—(Cos Ã—â—‹F Sin) ğ•©Ã·2
}

# Get the Euler angles equivalent to quaternion (roll, pitch, yaw)
# NOTE: Angles are returned in a Vector3 struct in radians
QuaternionToEuler â† {ğ•Šxâ€¿yâ€¿zâ€¿w:
  âŸ¨
    # Roll (x-axis rotation)
    Atan2Â´âŸ¨2Ã—(wÃ—x)+yÃ—z â‹„ 1-2Ã—+Â´Ã—Ëœxâ€¿yâŸ©

    # Pitch (y-axis rotation)
    Sinâ¼Â¯1âŒŠ1âŒˆ2Ã—-Â´Ã—Ë2â€¿2â¥Šğ•©

    # Yaw (z-axis rotation)
    Atan2Â´âŸ¨2Ã—+Â´Ã—Â´Â¨2(â†‘â‹ˆâ†“)ğ•© â‹„ 1-2Ã—+Â´Ã—Ëœyâ€¿zâŸ©
  âŸ©
}

# Transform a quaternion given a transformation matrix
QuaternionTransform â† {qğ•Šmat: # â†’Quaternion
  qâŠ¸Ã—Ë˜mat
}

# Check whether two given quaternions are almost equal
QuaternionEquals â† âˆ¨Â´Â·âˆ§Ë(|-â‰Ë˜+)â‰¤epsilonÃ—1âŒˆâŒˆâ—‹|


