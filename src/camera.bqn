# rcamera - Basic camera system with support for multiple camera modes

âŸ¨
  GetForward
  GetUp
  GetRight

  # Camera movement
  MoveForward
  MoveUp
  MoveRight
  MoveToTarget

  # Camera rotation
  Yaw
  Pitch
  Roll
  Rotateâ€¿RotateLocked
  RotateAroundTargetâ€¿RotateAroundTargetLocked

  GetViewMatrix
  GetProjectionMatrix
  MakeGetProjectionMatrix

  MakeUpdater

  UpdateFree
  UpdateFirstPerson
  UpdateThirdPerson
  UpdatePro
  UpdateMinecraft

  projection
  index
âŸ©â‡

keyâ€¿mouseâ€¿raylibâ€¿math â† â€¢args

âŸ¨
  up, left, down, right
  w, a, s, d, e, q
  space, left_control, IsPressed, keypad,
  IsDown
âŸ© â† key

âŸ¨
  GetFrameTime
  GetMouseDelta
  gamepadAxis
  GetGamepadAxisMovement
  IsGamepadAvailable
âŸ© â† raylib
âŸ¨
  Vector3RotateByAxisAngle
  VectorAngle
  MatrixLookAt
  MatrixPerspective
  MatrixOrtho
  deg2rad
  MP
  MatrixRotate
âŸ© â† math

projection â‡ { # Camera projection
  perspective  â‡ 0  # Perspective projection
  orthographic â‡ 1  # Orthographic projection
}

index â‡ {
  position   â‡ 0 # Camera position
  target     â‡ 1 # Camera target it looks-at
  up         â‡ 2 # Camera up vector (rotation over its axis)
  fovy       â‡ 3 # Camera field-of-view aperture in Y (degrees) in perspective, used as near plane width in orthographic
  projection â‡ 4 # Camera projection: projection.perspective or projection.orthographic
}


#----------------------------------------------------------------------------------
# Module Functions Definition
#----------------------------------------------------------------------------------
# Returns the cameras forward vector (normalized)
GetForward â† {ğ•Šcamera:
  Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))-Â´index.targetâ€¿index.positionâŠğ•©
}

# Returns the cameras up vector (normalized)
# Note: The up vector might not be perpendicular to the forward vector
GetUp â† {ğ•Šcamera:
  Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ)) index.upâŠ‘ğ•©
}

# Returns the cameras right vector (normalized)
GetRight â† {ğ•Šcamera:
  (GetForward camera) 1âŠ¸âŒ½âŠ¸Ã—{1âŒ½ğ”½Ëœ-ğ”½} GetUp camera
}

# Moves the camera in its forward direction
MoveForward â† {distanceğ•Šcamera:

  forward â† GetForward camera

  # Move position and target
  (forwardÃ—distance)âŠ¸+Â¨âŒ¾(index.positionâ€¿index.targetâŠ¸âŠ) camera
}

# Moves the camera in its forward direction
MoveForwardInWorldPlane â† {distanceğ•Šcamera:

  # Project vector onto world plane
  forward â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ)) 0âŒ¾(1âŠ¸âŠ‘) GetForward camera

  # Move position and target
  (forwardÃ—distance)âŠ¸+Â¨âŒ¾(index.positionâ€¿index.targetâŠ¸âŠ) camera
}

# Moves the camera in its up direction
MoveUp â† {distanceğ•Šcamera:
  (distanceÃ—GetUp camera)âŠ¸+Â¨âŒ¾(index.positionâ€¿index.targetâŠ¸âŠ)camera
}

# Moves the camera target in its current right direction
MoveRight â† {distanceğ•Šcamera:
  right â† GetRight camera

  # Scale by distance
  (rightÃ—distance)âŠ¸+Â¨âŒ¾(index.positionâ€¿index.targetâŠ¸âŠ)camera
}

# Moves the camera target in its current right direction
MoveRightInWorldPlane â† {distanceğ•Šcamera:
  # Project vector onto world plane
  right â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ)) 0âŒ¾(1âŠ¸âŠ‘) GetRight camera

  # Scale by distance
  (rightÃ—distance)âŠ¸+Â¨âŒ¾(index.positionâ€¿index.targetâŠ¸âŠ)camera
}

# Moves the camera position closer/farther to/from the camera target
MoveToTarget â† {deltağ•Šcamera:
  distance â† delta++Â´âŒ¾(Ã—Ëœ)-Â´index.positionâ€¿index.targetâŠcamera

  # Set new distance by moving the position along the forward vector
  forward â† distanceÃ—GetForward camera
  (forward -Ëœ index.targetâŠ‘camera)âŒ¾(index.positionâŠ¸âŠ‘)camera
}

# Rotates the camera around its up vector
# Yaw is "looking left and right"
# If rotateAroundTarget is false, the camera rotates around its position
# Note: angle must be provided in radians
Yaw â† {angleğ•Šcamera:
  up â† GetUp camera # Rotation axis

  # View vector
  targetPosition â† -Â´index.targetâ€¿index.positionâŠcamera

  # Rotate view vector around up axis
  targetPosition Vector3RotateByAxisAngleËœâ†©upâ€¿angle

  # rotate around camera.position
  # Move target relative to position
  (targetPosition + index.positionâŠ‘camera)âŒ¾(index.targetâŠ¸âŠ‘)camera
}

# Rotates the camera around its right vector, pitch is "looking up and down"
#  - lockView prevents camera overrotation (aka "somersaults")
#  - rotateUp rotates the up direction as well (typically only useful in mode.free)
# NOTE: angle must be provided in radians
Pitch â† {angleâ€¿lockViewâ€¿rotateUpğ•Šcamera:

  # clamp the Pitch angle to allow only viewing straight up or down.
  angle {
    t â† -Â´index.targetâ€¿index.positionâŠcamera
    ğ•© {ğ•ğ•©}Â´ âŒŠâ€¿âŒˆ{ğ•âŸœğ•©}Â¨1â€¿Â¯1Ã—Â¯0.001+t VectorAngleËœ â‰Ë˜âŸœ-GetUp camera
  }âŸlockView â†©

  # Rotation axis
  right â† GetRight camera

  # Rotate view vector around right axis
  targetPosition â† rightâ€¿angle Vector3RotateByAxisAngle -Â´index.targetâ€¿index.positionâŠcamera

  # rotate around camera.position
  # Move target relative to position
  camera {ğ•©â‹ˆğ•©+targetPosition}âˆ˜âŠ‘âŒ¾(index.positionâ€¿index.targetâŠ¸âŠ) â†©

  # Rotate up direction around right axis
  rightâ€¿angleâŠ¸Vector3RotateByAxisAngleâŒ¾(index.upâŠ¸âŠ‘)âŸrotateUp camera
}

# Rotates the camera around its forward vector
# Roll is "turning your head sideways to the left or right"
# Note: angle must be provided in radians
Roll â† {angleğ•Šcamera:
  # Rotation axis
  forward â† GetForward camera

  # Rotate up direction around forward axis
  forwardâ€¿angleâŠ¸Vector3RotateByAxisAngleâŒ¾(index.upâŠ¸âŠ‘)camera
}

# Returns the camera view matrix
GetViewMatrix â† {ğ•Šcamera:
  MatrixLookAt index.positionâ€¿index.targetâ€¿index.upâŠcamera
}

# Make GetProjectionMatrix with your own camera cull distance
MakeGetProjectionMatrix â† {ğ•Šcull_distance_nearâ€¿cull_distance_far:
  {aspectğ•Šcamera:
    { ğ•© â‰¡ projection.perspective?
      MatrixPerspectiveâŸ¨deg2radÃ—index.fovyâŠ‘camera, aspect, cull_distance_near, cull_distance_farâŸ©

    ; ğ•© â‰¡ projection.orthographic?
      top â† 2Ã·Ëœindex.fovyâŠ‘camera
      right â† topÃ—aspect

      MatrixOrthoâŸ¨-right, right, -top, top, cull_distance_near, cull_distance_farâŸ©
    ;
      =âŒœËœâ†•4
    }index.projectionâŠ‘camera
  }
}

# Default cull distance
GetProjectionMatrix â† MakeGetProjectionMatrix {ğ”½ğ•˜}0.01â€¿1000

ToTarget â‡ {
  ğ•Šâ¼:ğ•©+<-Â´ğ•©;
  ğ•Š: ğ•©-<-Â´ğ•©
}âŒ¾(index.positionâ€¿index.targetâŠ¸âŠ)

MakeUpdater â† {ğ•ŠâŸ¨
    moveInWorldPlane
    lockView
    rotateUp

    rotation_speed
    move_speed
    pan_speed
    mouse_move_sensitivity
    mouse_scroll_sensitivity
    keys
  âŸ©:
  tâ†{heightâ€¿pitchâ€¿yawâ€¿panModeâ‡keys}
  hUpKeyâ€¿hDownKeyâ†t.height
  pUpKeyâ€¿pDownKeyâ†t.pitch
  yUpKeyâ€¿yDownKeyâ†t.yaw
  panModeKeyâ†t.panMode

  {ğ•Šcamera:

    mouseDelta â† GetMouseDeltaâŸ¨âŸ©
    frameAdjusting â† 60Ã—GetFrameTimeâŸ¨âŸ©

    # Camera rotation
    camera PitchËœâ†© âŸ¨frameAdjustingÃ—rotation_speedÃ—-Â´IsDownÂ¨pUpKeyâ€¿pDownKey, lockView, rotateUpâŸ©
    camera Yaw  Ëœâ†©  frameAdjustingÃ—rotation_speedÃ—-Â´IsDownÂ¨yUpKeyâ€¿yDownKey

    right   â† moveInWorldPlaneâŠ‘MoveRightâ€¿MoveRightInWorldPlane
    forward â† moveInWorldPlaneâŠ‘MoveForwardâ€¿MoveForwardInWorldPlane

    # Camera movement
    {mouse.button.IsDown panModeKey?
      # Camera pan (for camera.free)
      camera Right Ëœâ†©  pan_speedÃ—Ã—0âŠ‘mouseDelta
      camera MoveUpËœâ†© -pan_speedÃ—Ã—1âŠ‘mouseDelta
    ;
      # Mouse support
      camera Yaw  Ëœâ†© -mouse_move_sensitivityÃ—0âŠ‘mouseDelta
      camera PitchËœâ†©âŸ¨-mouse_move_sensitivityÃ—1âŠ‘mouseDelta, lockView, rotateUpâŸ©
    }

    # Keyboard support
    camera ForwardËœâ†© frameAdjusting Ã— move_speedÃ—-Â´IsDownÂ¨wâ€¿s
    camera Right  Ëœâ†© frameAdjusting Ã— move_speedÃ—-Â´IsDownÂ¨dâ€¿a

    # Gamepad movement
    {ğ•¤
      G â† GetGamepadAxisMovement 0âŠ¸â‹ˆ

      # Gamepad controller support
      camera Yaw  Ëœâ†© frameAdjusting Ã— mouse_move_sensitivity Ã— Â¯20Ã—G gamepadAxis.gamepad_axis_right_x
      camera PitchËœâ†©âŸ¨frameAdjusting Ã— mouse_move_sensitivity Ã— Â¯20Ã—G gamepadAxis.gamepad_axis_right_y, lockView, rotateUpâŸ©
      camera ForwardËœâ†© frameAdjusting Ã— move_speed Ã— 0.25 (-âŠ¸â‰¥-â‰¤) G gamepadAxis.gamepad_axis_left_y
      camera RightËœâ†© -frameAdjusting Ã— move_speed Ã— 0.25 (-âŠ¸â‰¥-â‰¤) G gamepadAxis.gamepad_axis_left_x
      camera MoveUpËœâ†© frameAdjusting Ã— move_speed Ã— raylib.gamepadButton.gamepad_button_right_face_down -â—‹raylib.IsGamepadButtonDownâ—‹(0âŠ¸â‹ˆ) raylib.gamepadButton.gamepad_button_right_thumb
    }âŸâŠ¢ IsGamepadAvailable 0

    camera MoveUpËœâ†© frameAdjusting Ã— move_speed Ã— space -â—‹IsDown left_control

    camera
  }
}

# Zoom target distance
UpdateZoom â† {ğ•Šcamera: 1ğ•Šğ•©;
  zoomAmountğ•Šcamera:
  # scale multiplies the zoom speed to prevent you zooming past 0
  dist â† +Â´âŒ¾(Ã—Ëœ)-Â´index.targetâ€¿index.positionâŠğ•©

  # Zoom slows as you get close, and `0âŸ(0â‰¥dist+âŠ¢)` makes sure you can't get to/past 0 incase user zooms for a loooong time.
  camera MoveToTargetËœâ†© 0âŸ(0â‰¥dist+âŠ¢)- zoomAmount Ã— (mouse.WheelMoved@) + 2Ã—-Â´IsPressedÂ¨keypad.addâ€¿keypad.subtract
}
UpdateRoll â† {âŸ¨rotationSpeedâ‹„leftKeyâ€¿rightKeyâŸ©ğ•Šcamera: # rotation is Radians per second
  camera Roll Ëœâ†© (60Ã—GetFrameTimeâŸ¨âŸ©)Ã—rotationSpeedÃ—-Â´IsDownÂ¨leftKeyâ€¿rightKey
}
updateFree â† {0.03â€¿(ğ•¨.keys.roll) UpdateRoll ğ•{âŠ¢âŠ£âŒ¾(index.upâŠ¸âŠ‘)ğ”½}}âŸœMakeUpdater {
  rotation_speed â‡ 0.03
  move_speed     â‡ 0.09
  pan_speed      â‡ 0.2

  moveInWorldPlane â‡ 0
  lockView         â‡ 1
  rotateUp         â‡ 0

  # Camera mouse movement sensitivity
  mouse_move_sensitivity   â‡ 0.003     # TODO: it should be independant of framerate
  mouse_scroll_sensitivity â‡ 1.5

  keys â‡ {
    height  â‡ key.left_controlâ€¿key.space
    pitch   â‡ key.up          â€¿key.down
    yaw     â‡ key.left        â€¿key.right
    roll    â‡ key.e           â€¿key.q
    panMode â‡ mouse.button.middle
  }
}

# Orbital can just orbit
UpdateOrbital â‡ UpdateZoom {ğ•Š:0.5Ã—GetFrameTimeâŸ¨âŸ©}âŠ¸YawâŒ¾ToTarget

updateFirstPerson â‡ MakeUpdater {
  rotation_speed â‡ 0.03 # Radians per second
  move_speed     â‡ 0.09
  pan_speed      â‡ 0.2

  moveInWorldPlane   â‡ 0
  lockView           â‡ 1
  rotateUp           â‡ 1

  # Camera mouse movement sensitivity
  mouse_move_sensitivity   â‡ 0.003     # TODO: it should be independant of framerate
  mouse_scroll_sensitivity â‡ 1.5

  keys â‡ {
    height  â‡ key.left_controlâ€¿key.space
    pitch   â‡ key.up          â€¿key.down
    yaw     â‡ key.left        â€¿key.right
    panMode â‡ mouse.button.middle
  }
}
updateThirdPerson â‡ {UpdateZoom ğ•âŒ¾ToTarget} MakeUpdater {
  rotation_speed â‡ 0.03 # Radians per second
  move_speed     â‡ 0.09
  pan_speed      â‡ 0.2

  moveInWorldPlane   â‡ 0
  lockView           â‡ 1
  rotateUp           â‡ 0

  # Camera mouse movement sensitivity
  mouse_move_sensitivity   â‡ 0.003     # TODO: it should be independant of framerate
  mouse_scroll_sensitivity â‡ 1.5

  keys â‡ {
    height â‡ key.left_controlâ€¿key.space
    pitch â‡ key.upâ€¿key.down
    yaw   â‡ key.leftâ€¿key.right
    roll  â‡ key.eâ€¿key.q
    panMode â‡ mouse.button.middle
  }
}
updateMinecraft â† MakeUpdater{
  rotation_speed â‡ 0.03 # Radians per second
  move_speed     â‡ 0.09
  pan_speed      â‡ 0.2

  moveInWorldPlane   â‡ 1
  lockView           â‡ 1
  rotateUp           â‡ 0

  # Camera mouse movement sensitivity
  mouse_move_sensitivity   â‡ 0.003     # TODO: it should be independant of framerate
  mouse_scroll_sensitivity â‡ 1.5

  keys â‡ {
    height â‡ key.left_shiftâ€¿key.space
    pitch â‡ key.upâ€¿key.down
    yaw   â‡ key.leftâ€¿key.right
    roll  â‡ @â€¿@
    panMode â‡ mouse.button.middle
  }
}

# Update camera movement, movement/rotation values should be provided by user
UpdatePro â† UpdateZoom {movementâ€¿rotationâ€¿zoomğ•Šcamera:
  # Required values
  # movement.x - Move forward/backward
  # movement.y - Move right/left
  # movement.z - Move up/down
  # rotation.x - yaw
  # rotation.y - pitch
  # rotation.z - roll
  # zoom - Move towards target

  lockView           â† 1
  rotateAroundTarget â† 0
  rotateUp           â† 0
  moveInWorldPlane   â† 1

  # Camera rotation
  camera Yaw  Ëœâ†© -deg2radÃ—0âŠ‘rotation
  camera PitchËœâ†©âŸ¨-deg2radÃ—1âŠ‘rotation, lockView, rotateUpâŸ©

  # Camera movement
  camera MoveForwardInWorldPlaneËœâ†© 0âŠ‘movement
  camera MoveRightInWorldPlane  Ëœâ†© 1âŠ‘movement
  camera MoveUp                 Ëœâ†© 2âŠ‘movement

  camera
}

[
  Rotate â€¿ RotateLocked
  RotateAroundTarget â€¿ RotateAroundTargetLocked
] â† (â†•2â€¿2) {ğ•¨ğ•Šf: ğ•¨ _f}Â¨ {{
  angleYawâ€¿anglePitchâ€¿angleRoll RotateAroundTargetâ€¿LockView _ğ•£ positionâ€¿targetâ€¿upâ€¿fovyâ€¿projection:

  targetPosition â† upâ€¿angleYaw Vector3RotateByAxisAngle target-position
  right â† targetPosition 1âŠ¸âŒ½âŠ¸Ã—{1âŒ½ğ”½Ëœ-ğ”½} up

  anglePitch {
    # In these camera modes we clamp the Pitch angle
    # to allow only viewing straight up or down.

    # Clamp view up
    ğ•© âŒŠâ†© Â¯0.001+up VectorAngle targetPosition

    # Clamp view down
    ğ•© âŒˆ 0.001-(-up) VectorAngle targetPosition
  }âŸlockView â†©


  transpos â† rightâ€¿anglePitch Vector3RotateByAxisAngle targetPosition
  râ†rotateAroundTarget
  [positionâ‹„target] (+`transPosâ‰ËœâŠ)âŒ¾(râŒ½-âŸr)â†©

  âŸ¨
    position
    target
    up Vector3RotateByAxisAngleËtransPosâ€¿angleRollâ‰rightâ€¿anglePitch
    fovy
    projection
  âŸ©
}}
