âŸ¨ParseXMLâ‡ParseâŸ© â† â€¢Import "../../imports/bqn-libs/xml.bqn"
âŸ¨ToNumsâŸ© â† â€¢Import "../../imports/bqn-libs/strings.bqn"
âŸ¨Inverseâ‹„MPâŸ© â† â€¢Import "../../imports/bqn-libs/matrix.bqn"
âŸ¨colorâŸ© â† â€¢Import "../constants.bqn"

_MatFuncToListFunc â† {â¥Š2â†‘Ë˜ğ”½â—‹(0â€¿0â€¿1âˆ¾Ë˜Ëœ3â€¿2âŠ¸â¥Š)}

NSVG__xformmultiply â† MP _MatFuncToListFunc
NSVG__xforminverse â† Inverse _MatFuncToListFunc

# Parses SVG file from a null terminated string, returns SVG image as paths.
_ParseSVG_ â† {StartOperation _ğ•£_ EndOperation svgChars:
  {
    âŸ¨âŸ©â‰¡â‰¢ğ•©? @
    ; nameâ€¿argsâ€¿inside:
        name StartOperation args
        ğ•ŠÂ¨inside
        name EndOperation args
    ; nameâ€¿args:
      name StartOperation args
      name EndOperation args
    ;
      !âŸ¨"missed this with shape "âˆ¾â€¢Repr â‰¢ğ•©â‹„ğ•©âŸ©
  }Â¨ ParseXML svgChars
}

NSVG__getAverageScale â† {(+Â´Ã·â‰ )+ËâŒ¾(Ã—Ëœ)2â€¿2â¥Šğ•©}

NSVG__xformSetSkewX â† {â¥Š[1â€¿0 â‹„ âŸ¨â€¢math.Tan ğ•©â‹„1âŸ© â‹„ 0â€¿0]}
NSVG__xformSetSkewY â† {â¥Š[âŸ¨1â‹„â€¢math.Tan ğ•©âŸ© â‹„ 0â€¿1 â‹„ 0â€¿0]}
nsvg__xformIdentity â† â¥Š3â†‘=âŒœËœâ†•2

NSVG__parseTransformArgs â† {ğ•Šstrâ€¿maxNa:
  ("Incorrect amount of args"!maxNaâ‰¡â‰ )âŠ¸âŠ¢ ToNums str
}

NSVG__parseSkewX â† {ğ•Šstr: # strâ†’intâ€¿xform
  args â† NSVG__parseTransformArgs strâ€¿1
  NSVG__xformSetSkewX Ï€Ã—180Ã·ËœâŠ‘args
}

NSVG__xformSetTranslation â† (â¥Š=âŒœËœâ†•2)âŠ¸âˆ¾

# returns NSVGparser
CreateState â† {ğ•Š:

  image â‡ 0
  defsFlag â‡ 0
  SetDefsFlag â‡ {defsFlagâ†©ğ•©}

  dpiâ‡0
  SetDPI â‡ {dpiâ†©ğ•©}

  pathFlag â‡ 0
  SetPathFlag â‡ {pathFlagâ†©ğ•©}

  viewRec â‡ 0â€¿0â€¿0â€¿0
  SetViewRec â‡ {!4=â‰ ğ•©â‹„!âˆ§Â´1=â€¢TypeÂ¨ğ•©â‹„viewRecâ†©ğ•©}

  shapesTail â‡ @
  SetShapesTail â‡ {shapesTailâ†©ğ•©}

#  paths â‡ p.plist
#  p.SetPlistâŸ¨âŸ©

  # Init style
  attr â‡ âŸ¨
    {
      xform â‡ 2â†‘Ë˜=âŒœËœ3â€¿3
      id â‡ 0
      fillColor â‡ 0â€¿0â€¿0
      strokeColor â‡ 0â€¿0â€¿0
      opacity â‡ 1
      fillOpacity â‡ 1
      strokeOpacity â‡ 1
      stopOpacity â‡ 1
      strokeWidth â‡ 1
      strokeLineJoin â‡ nsvglineJoin.nsvg_join_miter
      strokeLineCap â‡ nsvglineCap.nsvg_cap_butt
      miterLimit â‡ 4
      fillRule â‡ nsvgfillRule.nsvg_fillrule_nonzero
      hasFill â‡ 1
      visible â‡ 1
    }
  âŸ©
  NSVG__pushAttr â‡ {ğ•Š:
    attr 1âŠ¸â†‘âŠ¸âˆ¾â†©
  }
  NSVG__getAttr â‡ {ğ•Š:
    âŠ‘attr
  }

  NSVG__popAttr â‡ {ğ•Š:
    attr 1âŠ¸â†“âŸ(1<â‰ )â†©
  }
}
nsvGpaintType â† {
  nsvg_paint_none â‡ 0
  nsvg_paint_color â‡ 1
  nsvg_paint_linear_gradient â‡ 2
  nsvg_paint_radial_gradient â‡ 3
}

nsvgspreadType â† {
  nsvg_spread_pad â‡ 0
  nsvg_spread_reflect â‡ 1
  nsvg_spread_repeat â‡ 2
}

nsvglineJoin â† {
  nsvg_join_miter â‡ 0
  nsvg_join_round â‡ 1
  nsvg_join_bevel â‡ 2
}

nsvglineCap â† {
  nsvg_cap_butt â‡ 0
  nsvg_cap_round â‡ 1
  nsvg_cap_square â‡ 2
}

nsvgfillRule â† {
  nsvg_fillrule_nonzero â‡ 0
  nsvg_fillrule_evenodd â‡ 1
}
nsvgflags â† {
  nsvg_flags_visible â‡ 1
}
nsvg_align_min â‡ 0
nsvg_align_mid â‡ 1
nsvg_align_max â‡ 2
nsvg_align_none â‡ 0
nsvg_align_meet â‡ 1
nsvg_align_slice â‡ 2

nsvggradientunits â† {
  nsvg_user_space â‡ 0
  nsvg_object_space â‡ 1
}

NSVG__xformPoint â† {ğ•Šxâ€¿yâ€¿t:
  +Ëxâ€¿yâ€¿1Ã—3â€¿2â¥Št
}

# returns NSVGgradientData*
NSVG__findGradientData â† {ğ•Špâ€¿id:
  âŠ‘@âˆ¾ËœidâŠ¸â‰¡âŸœ{ğ•©.id}Â¨âŠ¸/p.gradients
}

# returns *NSVGgradient â€¿ paintType
# input: NSVG_parserâ€¿strâ€¿*fâ€¿str
NSVG__createGradient â† {ğ•©â€¿ğ•©.paintType}âˆ˜{ğ•Špâ€¿idâ€¿localBounds:
	attr â† p.NSVG__getAttr@
	ref â† @  # NSVGgradientData*
	stops â† @  # NSVGgradientStop*
	nstops â‡ 0

	data â† NSVG__findGradientData pâ€¿id
  dataâ‰¢@?
    # TODO: use ref to fill in all unset values too.
    refIter â† 0
    {ğ•¤
      (stops = @) âˆ§ ğ•©.stops â‰  @?
        stops â†© ğ•©.stops
        nstops â†© ğ•©.nstops
    ;
      nextRef â† NSVG__findGradientData pâ€¿ğ•©.ref
      nextRefâ‰¢ğ•©? # prevent infite loops on malformed data
        refIter +â†© 1
        refIter â‰¤ 32? # prevent infite loops on malformed data
          ğ•ŠâŸ(@âŠ¸â‰ ) nextRef
    ;
      @
    }âŸ(@âŠ¸â‰ )data
    stops â‰  @?

      xform â‡ 6â¥Š0
      fxâ€¿fy â‡ 0â€¿0
      # stops â‡ âŸ¨
      #   {
      #     color â‡ 0â€¿0â€¿0â€¿0
      #     offset â‡ 0
      #   }
      # âŸ©

      # The shape width and height.
      oxâ€¿oyâ€¿swâ€¿sh â† {data.units = nsvggradientunits.nsvg_object_space?
        -Ëœ`2â€¿2â¥ŠlocalBounds
      ;
        âŸ¨
          p.viewMinx
          p.viewMiny
          p.viewWidth
          p.viewHeigght
        âŸ©
      }
      sl â† (âˆš2)Ã·Ëœsw+âŒ¾(Ã—Ëœ)sh

      {data.type = nsvGpaintType.nsvg_paint_linear_gradient?
        x1 â† p.NSVG__convertToPixels data.linear.x1â€¿oxâ€¿sw
        y1 â† p.NSVG__convertToPixels data.linear.y1â€¿oyâ€¿sh
        x2 â† p.NSVG__convertToPixels data.linear.x2â€¿oxâ€¿sw
        y2 â† p.NSVG__convertToPixels data.linear.y2â€¿oyâ€¿sh
        # Calculate transform aligned to the line
        dx â† x2 - x1
        dy â† y2 - y1
        xform â†© [dy â‹„ -dx
                dx â‹„ dy
                x1 â‹„ y1]
      ;
        cx â† p.NSVG__convertToPixels âŸ¨data.radial.cx, ox, swâŸ©
        cy â† p.NSVG__convertToPixels âŸ¨data.radial.cy, oy, shâŸ©
        fx â†© p.NSVG__convertToPixels âŸ¨data.radial.fx, ox, swâŸ©
        fy â†© p.NSVG__convertToPixels âŸ¨data.radial.fy, oy, shâŸ©
        r  â† p.NSVG__convertToPixels âŸ¨data.radial.r, 0, slâŸ©
        # Calculate transform aligned to the circle
        xform â†© [r â‹„ 0
                0 â‹„ r
                cxâ‹„ cy]
        fx Ã·â†© r
        fy Ã·â†© r
      }

      xform NSVG__xformMultiplyËœÂ´â†© attr.xformâ€¿data.xform

      spread â‡ data.spread
      paintType â‡ data.type
;
  @
}

NSVG__ptInBounds â† {ğ•Šptâ€¿bounds:
	âˆ§Â´(â‰¤âŸœptâˆ§ptâŠ¸â‰¤)Â´2(â†‘â‹ˆâ†“)bounds
}

nsvg_epsilon â† 1eÂ¯12

NSVG__evalBezier â† {ğ•Štâ€¿p:
	u â† Â¬t
	+Â´0â€¿3â€¿3â€¿0Ã—pÃ—Ã—Ëâ‰[tâ‹„u]âŠËœ4â†‘â‰¤âŒœËœâ†•3
}

NSVG__curveBounds â† {ğ•Šcurve: # returns bounds
	roots â† 0â€¿0
	curve 4â€¿2âŠ¸â¥Šâ†© # ?

	# Start the bounding box by end points
	bounds â† (Â¯1âŠcurve) (âŒŠâˆ¾âŒˆ) âŠcurve

	# Bezier curve fits inside the convex hull of it's control points.
	# If control points are inside the bounds, we're done.
	{
    âˆ§Â´NSVG__ptInBoundsÂ¨(1â€¿2âŠcurve)â‹ˆÂ¨<bounds?
      bounds
  ;
    # Add bezier curve inflection points in X and Y.
    {ğ•ŠrowsOfV:
      a â† +Â´Â¯3â€¿9â€¿Â¯9â€¿3Ã—ğ•©
      b â† +Â´6â€¿Â¯12â€¿6Ã—3â†‘ğ•©
      c â† +Â´Â¯3â€¿3Ã—2â†‘ğ•©
      count â† 0
      {nsvg_epsilon > |a?
        {ğ•¤
          {roots ğ•©âŒ¾((Â¯1+count+â†©1)âŠ¸âŠ‘)â†©}âŸ(nsvg_epsilonâŠ¸(<âˆ§Â¬âŠ¸>))b Ã·Ëœ -c
        }âŸ(nsvg_epsilonâŠ¸<)|b
      ;
        {ğ•¤
          {ğ•Š:roots ğ•©âŒ¾((Â¯1+count+â†©1)âŠ¸âŠ‘)â†©}âŸâŠ¢Â¨nsvg_epsilon(<âˆ§Â¬âŠ¸>)aÃ—2Ã·Ëœb-Ëœ1â€¿Â¯1Ã—âˆšğ•©
        }âŸ(nsvg_epsilonâŠ¸<) b Ã—ËœâŠ¸- 4Ã—cÃ—a
      }
      {ğ•¤
        v â† NSVG__evalBezierâŸ¨ğ•©âŠ‘rootsâŸ©âˆ¾rowsOfV
        bounds vâŠ¸âŒŠâŒ¾((0+ğ•©)âŠ¸âŠ‘)â†©
        bounds vâŠ¸âŒˆâŒ¾((2+ğ•©)âŠ¸âŠ‘)â†©
      }Â¨â†•count
    }Ë˜â‰curve
    bounds
  }
}

NSVG__getLocalBounds â† {ğ•Špathsâ€¿xform: # float*  NSVGshape* float*
  bounds â† 0â€¿0â€¿0â€¿0
  curve â† â¥Š4â€¿2â¥Š0
  boundss â† {ğ•Špath:
    curves â† NSVG__xformPointË˜Ë˜path.ptsâŠËœâ‰0â€¿1+âŒœ2Ã—1+âŒŠâ€¿3â¥Šâ†•1+path.npts
    start â† NSVG__xformPoint 2â†‘path.pts
    curveBoundss â† NSVG__curveBoundsÂ¨curvesâˆ¾ËœÂ¨<Â¨start<âŠ¸Â»Â¯1âŠË˜curves
    (âŒŠâ—‹(2âŠ¸â†‘) âˆ¾ âŒˆâ—‹(2âŠ¸â†“))Â´curveBoundss
  }Â¨paths
}

pathâ†{nptsâ‡5}
â€¢Show â†•âˆ˜âŒˆâŒ¾(Ã·âŸœ3) â€¢SHow path.npts-1


NSVG__addShape â† âŠ¢{parserğ•Šshape:
  # Add to tail
  {
    parser.image.shapes = @?
      parser.image.AddShapes shape
  ;
    parser.shapesTail.SetNext shape
  }

  parser.SetShapesTail ğ•©

} {ğ•©.plist=@?@; ğ•Šp: # NSVGparser
  attr â† state.NSVG__getAttr@

  id â‡ attr.id

  scale â‡ NSVG__getAverageScale attr.xform
  strokeWidth â‡ attr.strokeWidth Ã— scale
  strokeDashOffset â‡ attr.strokeDashOffset Ã— scale
  strokeDashCount â‡ attr.strokeDashCount
  strokeDashArray â‡ attr.strokeDashArray Ã— scale
  strokeLineJoin â‡ attr.strokeLineJoin
  strokeLineCap â‡ attr.strokeLineCap
  miterLimit â‡ attr.miterLimit
  fillRule â‡ attr.fillRule
  opacity â‡ attr.opacity

	paths â‡ p.plist
	p.SetPList âŸ¨âŸ©

  # Calculate shape bounds
  bounds â‡ paths.bounds (âŒŠâ—‹(2âŠ¸â†‘) âˆ¾ âŒˆâ—‹(2âŠ¸â†“))Â´ {ğ•©.bounds}Â¨paths.list

  # Set fill
  fill â‡ {
    typeâ€¿colorâ€¿gradientâ‡@â€¿@â€¿@
    {0:
      type â†© nsvGpaintType.nsvg_paint_none
    ;1:
      type â†© nsvGpaintType.nsvg_paint_color
      color â†© attr.fillColorâˆ¾attr.fillOpacityÃ—255
    ;2:
      inv â† NSVG__xformInverse attr.xform
      localBounds â† NSVG__getLocalBounds pathsâ€¿inv
      gradient â†© NSVG__createGradientâŸ¨p, attr.fillGradient, localBounds, typeâŸ©
      {ğ•Š:
        type â†© nsvGpaintType.nsvg_paint_none
      }âŸ(@âŠ¸â‰¡) gradient
    } attr.hasFill
  }

  # Set stroke
  stroke â‡ {
    typeâ€¿colorâ€¿gradientâ‡@â€¿@â€¿@
    {0: type â†© nsvGpaintType.nsvg_paint_none
    ;1:
      type â†© nsvGpaintType.nsvg_paint_color
      color â†© attr.strokeColorâˆ¾âŒŠattr.strokeOpacityÃ—255
    ;2:
      inv â† NSVG__xformInverse attr.xform
      localBounds â† NSVG__getLocalBounds pathsâ€¿inv
      gradientâ€¿type â†© NSVG__createGradientâŸ¨p, attr.strokeGradient, localBoundsâŸ©
      {ğ•Š:type â†© nsvGpaintType.nsvg_paint_none}âŸ(@âŠ¸â‰¡)gradient
    } attr.hasStroke
  }
  # Set flags
  flags â‡ attr.visibleâŠ‘0â€¿nsvgflags.nsvg_flags_visible
}


NSVG__parseNameValue â† {ğ•Špâ€¿str:
	nameâ€¿value â† âˆ¨`âˆ˜=âŸœ':'âŠ¸(Â¬âŠ¸/â‹ˆ1â†“/)str
  nameâ€¿value {ğ•©/Ëœ(âˆ¨`âŒ¾âŒ½âˆ§âˆ¨`)Â¬ğ•©âˆŠ' 'âˆ¾@+9+â†•5}Â¨â†©

	NSVG__parseAttr pâ€¿nameâ€¿value
}

NSVG__parseStyle â† {ğ•Špâ€¿str:
  {
    #                       Left and right trim
    NSVG__parseNameValue pâ‹ˆ ğ•©/Ëœ(âˆ¨`âŒ¾âŒ½âˆ§âˆ¨`)Â¬ğ•©âˆŠ' 'âˆ¾@+9+â†•5
  }Â¨ ';'((Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âˆ˜â‰ âŠ”âŠ¢) str
}

# returns id
NSVG__parseUrl â† {ğ•Šstr:
  âˆ§`âˆ˜â‰ âŸœ')'âŠ¸/('#'=âŠ‘)âŠ¸â†“"url("âŠ¸âˆ¾â¼ğ•©
}

NSVG__parseColorHex â† (âˆ¾"0A"+âŸœâ†•Â¨10â€¿6){hexCharsğ•Šstr:
	('#'â‰¡âŠ‘ğ•©)âˆ¨6=â‰ 1â†“ğ•©?		# 2 digit hex
		râ€¿gâ€¿b â† (16âŠ¸Ã—âŠ¸+ËœÂ´Â·âŒ½ğ•¨âŠ¸âŠ)Ë˜3â€¿2â¥Š'#'âˆ¾â¼ğ•©
	;('#'â‰¡âŠ‘ğ•©)âˆ¨3=â‰ 1â†“ğ•©?		# 1 digit hex, e.g. #abc -> 0xccbbaa
		râ€¿gâ€¿b â† 17Ã—16Ã—ğ•¨âŠ'#'âˆ¾â¼ğ•©
	;128â€¿128â€¿128
}âˆ˜(-âŸœ(32Ã—1="a{"âŠ¸â‹))

# Parse rgb color. The pointer 'str' must point at "rgb(" (4+ characters).
# This function returns gray (rgb(128, 128, 128) == '#808080') on parse errors
# for backwards compatibility. Note: other image viewers return black instead.
NSVG__parseColorRGB â†{ğ•Šstr:
  int i;
  rgbi[3]
  float rgbf[3];
  # try decimal integers first
  if (sscanf(str, "rgb(%u, %u, %u)", &rgbi[0], &rgbi[1], &rgbi[2]) != 3) {
    # integers failed, try percent values (float, locale independent)
    delimiter â† ",,)"
    str "rgb("âŠ¸âˆ¾â¼â†© # skip "rgb("
    {
      str âˆ¨`âˆ˜Â¬âˆ˜NSVG__isspaceâŠ¸/â†©   # skip leading spaces
      str '+'âŠ¸â‰¡âŸœâŠ‘âŠ¸â†“â†© # skip '+' (don't allow '-')

      strâ‰¢âŸ¨âŸ©?
        rgbf[i] â†© NSVG__atof str

        # Note 1: it would be great if nsvg__atof() returned how many
        # bytes it consumed but it doesn't. We need to skip the number,
        # the '%' character, spaces, and the delimiter ',' or ')'.

        # Note 2: The following code does not allow values like "33.%",
        # i.e. a decimal point w/o fractional part, but this is consistent
        # with other image viewers, e.g. firefox, chrome, eog, gimp.

        str âˆ¨`âˆ˜Â¬âˆ˜NSVG__isdigitâŠ¸/â†©
        str âˆ¨`âˆ˜Â¬âˆ˜âˆŠâŸœ('0'+â†•10)âŠ¸/â†© # skip integer part
        {ğ•¤
          strâ†“Ëœâ†©1
          "error: no digit after '.'"!strâŠ‘âŠ¸âˆŠ'0'+â†•10
          str âˆ¨`âˆ˜Â¬âˆ˜âˆŠâŸœ('0'+â†•10)âŠ¸/â†©
        }âŸâŠ¢'.'â‰¡âŠ‘str
        !'%'â‰¡âŠ‘str
        strâ†“Ëœâ†©1
        str âˆ¨`âˆ˜Â¬âˆ˜âˆŠâŸœ(' 'âˆ¾@+9+â†•5)âŠ¸/â†©
        !str âŠ‘âŠ¸= iâŠ‘delimiter
        strâˆ¾â¼ËœiâŠ‘delimiter
    ;
      @
    }Â¨ (+`Ã—Â¬)âŠ¸-âˆ˜=âŸœ','âŠ¸âŠ” str
    rgbi â† {i=3?
      âŒŠ0.5+2.55Ã—rgbf
    ;
      3â¥Š128
    }
  }
  # clip values as the CSS spec requires
  0âŒˆ255âŒŠrgbi
}

NSVG__parseColor â† {
  '#'â‰¡âŠ‘ğ•©?
    NSVG__parseColorHex ğ•©
; "rgb("â‰¡4â†‘ğ•©?
    NSVG__parseColorRGB ğ•©
;
  NSVG__parseColorName ğ•©
} âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/


# returns int
# takes NSVGparser*â€¿strâ€¿str
NSVG__parseAttr â† {ğ•Špâ€¿nameâ€¿value:
	attr â† p.NSVG__getAttr@ # NSVGattrib*
	attrâ‰¢@?
    r â† 1
    {"style":
      NSVG__parseStyle pâ€¿value
    ;"display":
      {ğ•Š:attr.SetVisible 0}âŸâŠ¢valueâ‰¡"none"
      # Don't reset ->visible on display:inline, one display:none hides the whole subtree

    ;"fill":
      {"none"â‰¡value?
        attr.SetHasfill 0
      ;"url("â‰¡4â†‘value?
        attr.SetHasfill 2
        NSVG__parseUrl attr.fillGradientâ€¿value
      ;
        attr.SetHasfill 1
        attr.SetFillColor NSVG__parseColor value
      }
    ;"opacity":
      attr.SetOpacity NSVG__parseOpacity value
    ;"fill-opacity":
      attr.SetFillOpacity NSVG__parseOpacity value
    ;"stroke":
      {valueâ‰¡"none"?
        attr.SetHasStroke 0
      ;"url("â‰¡4â†‘value?
        attr.SetHasStroke 2
        NSVG__parseUrl attr.strokeGradientâ€¿value
      ;
        attr.SetHasStroke 1
        attr.SetStrokeColor NSVG__parseColor value
      }
    ;"stroke-width":
      attr.SetStrokeWidth NSVG__parseCoordinate âŸ¨pâ‹„valueâ‹„0â‹„NSVG__actualLength pâŸ©
    ;"stroke-dasharray":
      attr.SetStrokeDashCount NSVG__parseStrokeDashArray pâ€¿valueâ€¿attr.strokeDashArray
    ;"stroke-dashoffset":
      attr.SetStrokeDashOffset NSVG__parseCoordinateâŸ¨p, value, 0, NSVG__actualLength pâŸ©
    ;"stroke-opacity":
      attr.SetStrokeOpacity NSVG__parseOpacity value
    ;"stroke-linecap":
      attr.SetStrokeLineCap NSVG__parseLineCap value
    ;"stroke-linejoin":
      attr.SetStrokeLineJoin NSVG__parseLineJoin value
    ;"stroke-miterlimit":
      attr.SetMIterLimit NSVG__parseMiterLimit value
    ;"fill-rule":
      attr.SetFillRule NSVG__parseFillRule value
    ;"font-size":
      attr.SetFontSize NSVG__parseCoordinateâŸ¨p, value, 0, NSVG__actualLength pâŸ©
    ;"transform":
    	xform â† NSVG__parseTransform value
      attr.SetXForm attr.xform NSVG__xformPremultiply xform
    ;"stop-color":
      attr.SetStopColor NSVG__parseColor value
    ;"stop-opacity":
      attr.SetStopOpacity NSVG__parseOpacity value
    ;"offset":
      attr.SetStopOffset NSVG__parseCoordinate pâ€¿valueâ€¿0â€¿1
    ;"id":
      attr.SetID value
    ;
      râ†©0
    } name
    r
;
  0
}


NSVG__parseRect â† {ğ•Špâ€¿attr: # NSVGParserâ€¿*str
	x â† 0
	y â† 0
	w â† 0
	h â† 0
	rx â† Â¯1 # marks not set
	ry â† Â¯1

	{ğ•Šattributeâ€¿val:
		{ğ•¤
			attributeâ‰¡"x"?      x â†©  NSVG__parseCoordinateâŸ¨p, val, NSVG__actualOrigX p, NSVG__actualWidth pâŸ©
			attributeâ‰¡"y"?      y â†©  NSVG__parseCoordinateâŸ¨p, val, NSVG__actualOrigY p, NSVG__actualHeight pâŸ©
			attributeâ‰¡"width"?  w â†©  NSVG__parseCoordinateâŸ¨p, val, 0,                    NSVG__actualWidth pâŸ©
			attributeâ‰¡"height"? h â†©  NSVG__parseCoordinateâŸ¨p, val, 0,                    NSVG__actualHeight pâŸ©
			attributeâ‰¡"rx"?    rx â†© |NSVG__parseCoordinateâŸ¨p, val, 0,                    NSVG__actualWidth pâŸ©
			attributeâ‰¡"ry"?    ry â†© |NSVG__parseCoordinateâŸ¨p, val, 0,                    NSVG__actualHeight pâŸ©
      ;@
    }âŸÂ¬NSVG__parseAttrâŸ¨pâŸ©âˆ¾ğ•©
	}Ë˜â‰attr

	{ğ•Š:rx â†© ry}âŸâŠ¢ (rx<0) âˆ§ ry>0
	{ğ•Š:ry â†© rx}âŸâŠ¢ (ry<0) âˆ§ rx>0
	{ğ•Š:rx â†© ğ•©}âŸ(rxâŠ¸<) 0
	{ğ•Š:ry â†© ğ•©}âŸ(ryâŠ¸<) 0
	{ğ•Š:rx â†© ğ•©}âŸ(rxâŠ¸>) wÃ·2
	{ğ•Š:ry â†© ğ•©}âŸ(ryâŠ¸>) hÃ·2

	{ğ•¤
		NSVG__resetPath p
		{âˆ¨Â´rxâ€¿ry<1eÂ¯5â€¿1eÂ¯4?
			NSVG__moveToâŸ¨p, x, yâŸ©
			NSVG__lineToâŸ¨p, x+w, yâŸ©
			NSVG__lineToâŸ¨p, x+w, y+hâŸ©
			NSVG__lineToâŸ¨p, x, y+hâŸ©
		;
			# Rounded rectangle
			NSVG__moveToâŸ¨p, x+rx, yâŸ©
			NSVG__lineToâŸ¨p, x+w-rx, yâŸ©
			NSVG__cubicBezToâŸ¨p, (x+w)-rxÃ—Â¬NSVG_KAPPA90, y, x+w, y+ryÃ—Â¬nsvg_KAPPA90, x+w, y+ryâŸ©
			NSVG__lineToâŸ¨p, x+w, (y+h)-ryâŸ©
			NSVG__cubicBezToâŸ¨p, x+w, (y+h)-ryÃ—Â¬nsvg_KAPPA90, (x+w)-rxÃ—Â¬nsvg_KAPPA90, y+h, (x+w)-rx, y+hâŸ©
			NSVG__lineToâŸ¨p, x+rx, y+hâŸ©
			NSVG__cubicBezToâŸ¨p, (x+rx)Ã—Â¬nsvg_KAPPA90, y+h, x, (y+h)-ryÃ—Â¬nsvg_KAPPA90, x, (y+h)-ryâŸ©
			NSVG__lineToâŸ¨p, x, y+ryâŸ©
			NSVG__cubicBezToâŸ¨p, x, (y+ry)Ã—Â¬nsvg_KAPPA90, (x+rx)Ã—Â¬nsvg_KAPPA90, y, x+rx, yâŸ©
		}

		p.NSVG__addPath pâ€¿1

		p.NSVG__addShape
	}âŸâŠ¢âˆ§Â´0â‰ wâ€¿h
}

NSVG__parseCircle â† â€¢Show
NSVG__parseEllipse â† â€¢Show
NSVG__parseLine â† â€¢Show
NSVG__parsePoly â† â€¢Show
NSVG__parseGradient â† â€¢Show
NSVG__parseGradientStop â† â€¢Show
NSVG__parseAttribs â† â€¢Show
NSVG__parsePath â† â€¢Show

NSVG__ParseSVG â† @âˆ˜{
  "viewBox"ğ•Šğ•©: state.SetViewRec ToNums ğ•©
  ;"xmlns"ğ•Šğ•©: !"http://www.w3.org/2000/svg"â‰¡ğ•©
  ;"width"ğ•Šğ•©: state.SetImageWidth ğ•©
  ;"height"ğ•Šğ•©: state.SetImageHeight ğ•©
  ;"preserveAspectRatio"ğ•Šğ•©:
    {
      âˆ¨Â´"none"â·ğ•©?
        # No uniform scaling
        state.SetAlignType nsvg_align_none
    ;
      # Parse X and Y align
      state.SetAlignPos âŸ¨
        {âˆ¨Â´"xMin"â·ğ•©? nsvg_align_min
        ;âˆ¨Â´"xMid"â·ğ•©? nsvg_align_mid
        ;âˆ¨Â´"xMax"â·ğ•©? nsvg_align_max
        ;@}ğ•©
        {âˆ¨Â´"yMin"â·ğ•©? nsvg_align_min
        ;âˆ¨Â´"yMid"â·ğ•©? nsvg_align_mid
        ;âˆ¨Â´"yMax"â·ğ•©? nsvg_align_max
        ;@}ğ•©
      âŸ©
      # Parse meet/slice
      state.SetAlignType nsvg_align_meetâ€¿nsvg_align_sliceâŠ‘Ëœâˆ¨Â´ğ•©â·"slice"
    }ğ•©
  ;"fill"ğ•Šğ•©: !ğ•©â‰¡"none"
}Â´Â¨<Ë˜âˆ˜â‰

state â† CreateState@

Start â† â€¢Outâˆ˜âˆ¾âŸœ" started"âŠ¢{
  state.defsFlag?
    # Skip everything but gradients in defs
    {"linearGradient"ğ•Šğ•©:
      NSVG__parseGradient stateâ€¿ğ•©â€¿nsvGpaintType.nsvg_paint_linear_gradient
    ;"radialGradient"ğ•Šğ•©:
      NSVG__parseGradient stateâ€¿ğ•©â€¿nsvGpaintType.nsvg_paint_radial_gradient
    ;"stop"ğ•Šğ•©:
      NSVG__parseGradientStop stateâ€¿ğ•©
    }Â´ğ•¨â€¿ğ•©

  ;"g"ğ•Šğ•©:
      state.NSVG__pushAttr@
      NSVG__parseAttribs stateâ€¿ğ•©
  ;"path"ğ•Šğ•©:
    {ğ•Š: # Do not allow nested paths.
      state.NSVG__pushAttr@
      NSVG__parsePath stateâ€¿ğ•©
      state.NSVG__popAttr@
    }âŸstate.pathFlag state
  ;"rect"ğ•Šğ•©:
    state.NSVG__pushAttr@
    NSVG__parseRect stateâ€¿ğ•©
    state.NSVG__popAttr@
  ;"circle"ğ•Šğ•©:
    state.NSVG__pushAttr@
    NSVG__parseCircle stateâ€¿ğ•©
    state.NSVG__popAttr@
  ;"ellipse"ğ•Šğ•©:
    state.NSVG__pushAttr@
    NSVG__parseEllipse stateâ€¿ğ•©
    state.NSVG__popAttr@
  ;"line"ğ•Šğ•©:
    state.NSVG__pushAttr@
    NSVG__parseLine stateâ€¿ğ•©
    state.NSVG__popAttr@
  ;"polyline"ğ•Šğ•©:
    state.NSVG__pushAttr@
    NSVG__parsePoly stateâ€¿ğ•©â€¿0
    state.NSVG__popAttr@
  ;"polygon"ğ•Šğ•©:
    state.NSVG__pushAttr@
    NSVG__parsePoly stateâ€¿ğ•©â€¿1
    state.NSVG__popAttr@
  ;"linearGradient"ğ•Šğ•©:
    NSVG__parseGradient stateâ€¿ğ•©â€¿nsvGpaintType.nsvg_paint_linear_gradient
  ;"radialGradient"ğ•Šğ•©:
    NSVG__parseGradient stateâ€¿ğ•©â€¿nsvGpaintType.nsvg_paint_radial_gradient
  ;"stop"ğ•Šğ•©:
    NSVG__parseGradientStop stateâ€¿ğ•©
  ;"defs"ğ•Šğ•©:
    state.SetDefsFlag 1
  ;"svg"ğ•Šğ•©:
    NSVG__ParseSVG ğ•©
  ;@
}

End â† â€¢Outâˆ˜âˆ¾âŸœ" Ended"âŠ¢{
   "g"ğ•Šargs: state.NSVG__popAttr@
  ;"path"ğ•Šargs: state.SetPathFlag 0
  ;"defs"ğ•Šargs: state.SetDefsFlag 0
  ;@
}


Start _ParseSVG_ End â€¢FChars "logo.svg"