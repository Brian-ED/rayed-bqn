# Math functions to work with Vectors, Matricies and Quaternions

# GOAL make raylib functions work on arbitrary vectors and matricies
# aswell as switch from raylib's collumn model to leading axis model.
# Also considering making Quaternions be realâ€¿iâ€¿jâ€¿k instead of iâ€¿jâ€¿kâ€¿real
# raylib and 3d graphics in general uses 4x4 matricies for rotation and position, but 3x3 are enough for just rotation.

# CONVENTIONS:
# - Functions are always self-contained, no function use another raymath function inside,
# - Angles are always in radians


#----------------------------------------------------------------------------------
# removed from raylib
#----------------------------------------------------------------------------------

## Removed QuaternionToMatrix and QuaternionFromMatrix:
# they have been said to be innacurate by ray - maintainer of raylib. 
# Under "module: raymath" at https://github.com/raysan5/raylib/discussions/2952 
## removed Vector3Perpendicular, as it isn't well defined.
âŸ¨
  # new, non-existant in raylib
  _ToDim_      # set length of square input arrays, ğ”½ being applied to the inputs after padding to length ğ•˜ 
  MatrixExtend # pad square matrix to a length

  # multiply by constants for converting
  deg2rad, rad2deg

  # scaler ops
  Wrap
  Normalize
  Remap
  FloatEquals

  # works on any shaped input
  Round
  Lerp

  # functions applied to a list
  Vector3Unproject
  Vector3OrthoNormalize
  Vector3RotateByAxisAngle
  VectorClampValue
  VectorAngle
  VectorLength â‹„ VectorLengthSqr
  VectorDotProduct
  VectorDistance
  Vector2LineAngle
  Vector2Reflect
  Vector2Rotate
  VectorMoveTowards
  Vector3CrossProduct
  VectorNormalize
  Vector3OrthoNormalize
  Vector3RotateByQuaternion
  Vector3RotateByAxisAngle
  VectorReflect
  Vector3Barycenter
  Vector3Unproject
  Vector3Refract
  
  # matrix operations
    # generalized
    MP â‹„ Inverse â‹„ MatrixDeterminant # from matrix.bqn in Marshall's bqn-libs
    MatrixScale â‹„ MatrixTrace

    # only output 3x3
    MatrixRotate â‹„ MatrixRotateX â‹„ MatrixRotateY â‹„ MatrixRotateZ

    # only take list length 3
    MatrixTranslate
    MatrixLookAt
    MatrixRotateXYZ
    MatrixRotateZYX
  
    # take scalers
    MatrixFrustum
    MatrixPerspective
    MatrixOrtho

  # quaternion operations
  QuaternionInvert
  QuaternionMultiply
  QuaternionNlerp
  QuaternionSlerp
  QuaternionFromVector3ToVector
  QuaternionFromAxisAngle
  QuaternionToAxisAngle
  QuaternionFromEuler
  QuaternionToEuler
  QuaternionEquals
âŸ©â‡





# Too simple:
# Vector2Add         â† Vector2AddValue â† Vector3Add â† Vector3AddValue â† MatrixAdd â† QuaternionAdd â† QuaternionAddValue â†  +
# Vector2Multiply    â† Vector2Scale â† Vector3Multiply â† Vector3Scale â† QuaternionScale â† Ã—
# Vector2Subtract    â† Vector2SubtractValue â† Vector2Negate â† Vector3Subtract â† Vector3SubtractValue â† Vector3Negate â† QuaternionSubtract â† QuaternionSubtractValue â† -
# Vector2Divide      â† Vector2Invert â† Vector3Divide â† Vector3Invert â† QuaternionDivide â† Ã·
# Vector3DistanceSqr â† Vector2DistanceSqr â† Ã—ËœVectorDistance
# MatrixTranspose    â† â‰
# MatrixIdentity     â† =âŒœËœâ†•âˆ˜4
# MatrixInvert       â† matrix.Inverse
# MatrixToFloatV     â† â¥Š
# Vector3Min         â† âŒŠ
# Vector3Max         â† âŒˆ
# Clamp              â† Vector2Clamp â† maxâŒŠminâŒˆx

# extended:
# Vector2Length       â† Vector3Length     â† QuaternionLength â† VectorLength
# Vector2LengthSqr    â† Vector3LengthSqr  â† VectorLengthSqr
# Vector2DotProduct   â† Vector3DotProduct â† VectorDotProduct 
# Vector2Distance     â† Vector3Distance   â† VectorDistance
# Vector2Lerp         â† Vector3Lerp       â† QuaternionLerp â† Lerp
# Vector2Transform    â† Vector3Transform  â† VectorTransform â† (1âˆ¾Ëœ3âŠ¸â†‘)âŠ¸MP
# QuaternionTransform â† MP
# Vector2ClampValue   â† Vector3ClampValue â† VectorClampValue
# Vector2Equals       â† Vector3Equals     â† VectorEquals â† VectorEquals
# Vector2Normalize    â† Vector3Normalize  â† QuaternionNormalize â† VectorNormalize
# Vector2Angle        â† Vector3Angle      â† VectorAngle
# Vector2MoveTowards  â† VectorMoveTowards
# Vector2CrossProduct â† Vector3CrossProduct


#----------------------------------------------------------------------------------
# Notes
#----------------------------------------------------------------------------------

# Why 4x4 Matricies?
#   https://stackoverflow.com/questions/29079685/how-does-4x4-matrix-work-in-3d-graphic
#   Matrices define linear transformations between vector spaces.
#   All linear transformations map the origin of the domain to the origin of the range.
#   Therefore 3x3 matrices cannot perform translation on 3D vectors since the origin in one space cannot be mapped to anything but the origin on another using linear maps.
#   To overcome this problem, we can fake the system into performing translations through the use of an extra dimension where all vectors will have a 1 in the last vector component. 
#   These 4D vectors will never be at the origin (having 1 in the last component) and so are not required to always map to the origin.
#   Through the use of this we can construct a 4x4 matrix to perform translation.

# Get scaling matrix
MatrixScale â† {ğ•Šv:ğ•©Ã—=âŒœËœâ‰ ğ•©}


#----------------------------------------------------------------------------------
# Defines
#----------------------------------------------------------------------------------

epsilon â† 1eÂ¯6
rad2deg â† Ã·deg2rad â† Ï€Ã·180

âŸ¨Sin, Cos, Tan, Atan2âŸ©â†â€¢math

raylibPathâ€¿bqnLibsPath â† â€¢Import "loadConfig.bqn"

âŸ¨MP, MatrixDeterminantâ‡Determinant, InverseâŸ© â† â€¢Import bqnLibsPath â€¢file.At "matrix.bqn"

Round â† {âŒŠâˆ˜+âŸœ0.5âŒ¾((10â‹†ğ•¨)âŠ¸Ã—)ğ•©}

#----------------------------------------------------------------------------------
# Utils math
#----------------------------------------------------------------------------------

# Calculate linear interpolation between two floats or vectors
Lerp â† {ğ•Šv1â€¿v2â€¿amount:
  amountâŠ¸Ã—âŒ¾(-âŸœv1)v2
}

# Normalize input value within input range
Normalize â† {startâ€¿endğ•Švalue:
  (âˆ§Â´â¥Šendâ‰ start)!Ëœ"Normalize: start can't equal end (startâ€¿endâ†ğ•¨ â‹„ endâ‰ start)"
  valueÃ·â—‹(-âŸœstart)end
}

# Remap input value within input range to output range
Remap â† {ğ•Švalueâ€¿inputStartâ€¿inputEndâ€¿outputStartâ€¿outputEnd:
  {ğ•©Ã—Ã·Â´valueâ€¿inputEnd-inputStart}âŒ¾(-âŸœoutputEnd) outputStart
}

Wrap â† {ğ•Švalueâ€¿minâ€¿max:
  "Wrap: Min can't equal max"!minâ‰¢max
  max|âŒ¾(-âŸœmin)value
}

# Check whether two given vectors are almost equal
FloatEquals â† âˆ§Â´âˆ˜â¥Š|âˆ˜-â‰¤epsilonÃ—1âŒˆâŒˆâ—‹|

#----------------------------------------------------------------------------------
# Vector math
#----------------------------------------------------------------------------------

# Calculate vector length
VectorLength â† +Â´âŒ¾(Ã—Ëœ)

# ğ•¨ğ•Šğ•©: Calculate two vectors dot product
#  ğ•Šğ•©: Calculate vector square length
VectorDotProduct â† VectorLengthSqr â† +Â´Ã—Ëœ

# Calculate distance between two vectors
VectorDistance â† +Â´âŒ¾(Ã—Ëœ)-

# Calculate angle between two vectors
# NOTE: Angle is calculated from origin point (0, 0)
VectorAngle â† {
  3=â‰ ğ•©: (Cosâ¼+Â´âˆ˜Ã—Ã·Ã—â—‹(+Â´âŒ¾(Ã—Ëœ)))Â´ğ•¨â€¿ğ•©  # length3 is faster
;
  (+Â´âˆ˜Ã—Atan2Â·+Â´âŒ¾(Ã—Ëœ)1âŠ¸âŒ½âŠ¸Ã—{1âŒ½ğ”½Ëœ-ğ”½})Â´ğ•¨â€¿ğ•©
}

# Calculate angle defined by a two vectors line
# NOTE: Parameters need to be normalized
# Current implementation should be aligned with glm::angle
Vector2LineAngle â† Cosâ¼1âŒˆÂ¯1âŒˆ+Â´âˆ˜Ã— # start ğ•Š end

# Calculate reflected vector to normal
Vector2Reflect â† {normalğ•Šv: # vector vector
  v-2Ã—normalÃ—+Â´vÃ—normal
}

# Rotate vector by angle:  angle ğ•Š vector2
Vector2Rotate â† (Cosâˆ¾Sin)âŠ¸(-Â´âˆ˜Ã—â‹ˆÂ·+Â´âŒ½âŠ¸Ã—)

# Move Vector towards target
VectorMoveTowards â† {targetâ€¿maxDistanceğ•Šv:
  targetâŒŠv+maxDistanceÃ—Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))target-v
}

# Clamp the magnitude of the vector between two min and max values
VectorClampValue â† {ğ•Švâ€¿minâ€¿max:
  (Ã·Ã—maxâŒŠminâŒˆâŠ¢)âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))v
}

# Calculate two vectors cross product
Vector3CrossProduct â† 1âŠ¸âŒ½âŠ¸Ã—{1âŒ½ğ”½Ëœ-ğ”½}

# Normalize provided vector
VectorNormalize â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))

# Orthonormalize provided vectors
# Makes vectors normalized and orthogonal to each other
# Gram-Schmidt function implementation
Vector3OrthoNormalize â† {v1ğ•Šv2:
  # Vector3Normalize v1
  F â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))

  # Vector3CrossProductÂ´v1â€¿v2
  G â† 1âŠ¸âŒ½âŠ¸Ã—{1âŒ½ğ”½Ëœ-ğ”½}
  
  v1 Gâ—‹FËœ v1 FâŠ¸G v2
}

# Transform a vector by quaternion rotation
Vector3RotateByQuaternion â† {qğ•Šv: xâ€¿yâ€¿zâ€¿wâ†q
  MPâŸœv MPâŸœq[
    [
      âŸ¨ x â‹„ -y â‹„ -z â‹„  wâŸ©
      âŸ¨ y â‹„  x â‹„ -w â‹„ -zâŸ©
      âŸ¨ z â‹„  w â‹„  x â‹„  yâŸ©
    ]
    [
      âŸ¨ y â‹„  x â‹„  w â‹„  zâŸ©
      âŸ¨-x â‹„  y â‹„ -z â‹„  wâŸ©
      âŸ¨-w â‹„  z â‹„  y â‹„ -xâŸ©
    ]
    [
      âŸ¨ z â‹„ -w â‹„  x â‹„ -yâŸ©
      âŸ¨ w â‹„  z â‹„  y â‹„  xâŸ©
      âŸ¨-x â‹„ -y â‹„  z â‹„  wâŸ©
    ]
  ]
}

# Rotates a vector around an axis
Vector3RotateByAxisAngle â† {ğ•Švâ€¿axisV3â€¿angle:
  # Using Euler-Rodrigues Formula
  # Ref.: https://en.wikipedia.org/w/index.php?title=Euler%E2%80%93Rodrigues_formula
  
  a â† Cos angleÃ·2
  w â† axisV3 Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))âŠ¸Ã— Sin angleÃ·2
  F â† 1âŠ¸âŒ½âŠ¸Ã—{1âŒ½ğ”½Ëœ-ğ”½}
  wv â† w F v
  v+2Ã—(wâŠ¸F+aâŠ¸Ã—) wv
}

# Calculate reflected vector to normal
VectorReflect â† {normalğ•Šv:
  v - (+Â´vÃ—normal)Ã—2Ã—normal
}

# Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c)
# NOTE: Assumes P is on the plane of the triangle
Vector3Barycenter â† {ğ•Špâ€¿aâ€¿bâ€¿c: # v3â€¿v3â€¿v3â€¿v3â†’v3
  # s0 and s1 are magic values, as in, i have no idea what they mean :)
  s0â€¿s1â€¿denom â† {-Â´Ã—ËâŒ½âŒ¾âŠğ•©}Â¨(<Ë˜â‰ âŒœËœâ†•3)/Â¨<+Â´Ë˜Ã—ËË˜(>â†•3â€¿2)âŠ-âŸœaÂ¨bâ€¿câ€¿p
  (Â¬+Â´)âŠ¸âˆ¾s0â€¿s1Ã·denom
}

# Projects a Vector3 from screen space into object space
# NOTE: We are avoiding calling other raymath functions despite available
Vector3Unproject â† {
  ğ•ŠâŸ¨
    source     # v3
    projection # Matrix
    view       # Matrix
  âŸ©:
  projectionâ€¿viewâ‰Â¨â†©
  # Create quaternion from source point
  quat â† sourceâˆ¾1

  qtransformed â† quat MP Inverse view MP projection

  # Normalized world points in vectors
  Â¯1(â†“Ã·âŠ‘)qtransformed
}

# Compute the direction of a refracted ray 
Vector3Refract â† {ğ•ŠâŸ¨
    v # v3: normalized direction of the incoming ray
    n # v3: normalized normal vector of the interface of two optical media
    r # f : ratio of the refractive index of the medium from where the ray comes to the refractive index of the medium on the other side of the surface
  âŸ©:
  dot â† +Â´vÃ—n
  d â† Â¬Â¬âŠ¸âˆ§Â´Ã—Ëœdotâ€¿r
  {ğ•Š:(rÃ—v)-nÃ—(âˆšd)+rÃ—dot}âŸ(dâ‰¥0)3â¥Š0
}

#----------------------------------------------------------------------------------
# Matrix math
#----------------------------------------------------------------------------------

# Extend square matrix by identity matrix:
MatrixExtend â† {lenğ•Šmat: # returns square matrix
  1Â¨âŒ¾(0â€¿0â‰((-len-â‰ ğ•©)Â¨â‰¢ğ•©)âŠ¸â†‘)ğ•¨Â¨âˆ˜â‰¢âŠ¸â†‘ğ•©
}

# ğ”½ is applied after resizing the square matricies ğ•© and ğ•¨ by padding identity matrix, so that ğ•© and ğ•¨ have length ğ•˜ (âˆ§Â´g=â‰ Â¨ğ•©â€¿ğ•¨)
_ToDim_ â† {ğ”½ _ğ•£_ dim:ğ”½â—‹(ğ•˜âŠ¸MatrixExtend)}

# Get the trace of the matrix (sum of the values along the diagonal)
MatrixTrace â† +Â´0â€¿0âŠ¸â‰

# Get translation matrix
MatrixTranslate â† {ğ•Šxâ€¿yâ€¿z:
  [
    1â€¿0â€¿0â€¿x
    0â€¿1â€¿0â€¿y
    0â€¿0â€¿1â€¿z
    0â€¿0â€¿0â€¿1
  ]
}
# Create rotation matrix from axis and angle
# NOTE: Angle should be provided in radians
MatrixRotate â† {ğ•Šaxisâ€¿angle: # v3 f
  v â† Ã—âŒœËœÃ·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ)) axis
  xâ€¿yâ€¿z â† axis
  (vÃ—Â¬Cos angle)+((=âŒœËœâ†•3)âŠ(Sinâˆ¾Cos)angle)Ã—[
    âŸ¨ 1 â‹„-z â‹„ yâŸ©
    âŸ¨ z â‹„ 1 â‹„-xâŸ©
    âŸ¨-y â‹„ x â‹„ 1âŸ©
  ]
}

# NOTE: Angle must be provided in radians
MatrixRotateXâ€¿MatrixRotateYâ€¿MatrixRotateZ â† {
  _RotMat â† {cut2x2OfMat On2x2Arr _ğ•£ degrees:
    (ğ”½(â‹ˆâŸœ-Â´â‰âŒ½)(â€¢math.Cosâˆ¾â€¢math.Sin)ğ•©)âŒ¾(ğ•¨âŠ¸âŠË˜ğ•¨âŠ¸âŠ)=âŒœËœâ†•3
  }
  âŸ¨1â€¿2 â‰_RotMat âŠ¢
   0â€¿2 âŠ¢_RotMat âŠ¢
   0â€¿1 â‰_RotMat âŠ¢âŸ©
}

# Get xyz-rotation matrix
# NOTE: Angle must be provided in radians
MatrixRotateXYZ â† {ğ•Šangle:
  [cxâ€¿cyâ€¿cz
   sxâ€¿syâ€¿sz] â† (Cosâ‰Sin)-ğ•©
  [
    âŸ¨ cyÃ—cz â‹„ (sxÃ—czÃ—sy) - szÃ—cx â‹„ (cxÃ—syÃ—cz) + szÃ—sx âŸ©
    âŸ¨ cyÃ—sz â‹„ (sxÃ—syÃ—sz) + czÃ—cx â‹„ (cxÃ—syÃ—sz) - czÃ—sx âŸ©
    âŸ¨   -sy â‹„  sxÃ—cy             â‹„  cxÃ—cy             âŸ©
  ]
}

# Get zyx-rotation matrix
# NOTE: Angle must be provided in radians
MatrixRotateZYX â† MatrixRotateXYZ-

# Get perspective projection matrix
MatrixFrustum â† {ğ•Šleftâ€¿rightâ€¿bottomâ€¿topâ€¿nearâ€¿far:
  [
    âŸ¨nearÃ—2 â‹„ 0      â‹„ right+left   â‹„ 0         âŸ©Ã·0âŠ¸=âŠ¸+right-left
    âŸ¨0      â‹„ nearÃ—2 â‹„   top+bottom â‹„ 0         âŸ©Ã·0âŠ¸=âŠ¸+  top-bottom
    âŸ¨0      â‹„ 0      â‹„   far+near   â‹„ farÃ—nearÃ—2âŸ©Ã·0âŠ¸=âŠ¸+ near-far
    âŸ¨0      â‹„ 0      â‹„ Â¯1           â‹„ 0         âŸ©
  ]
}

# Get perspective projection matrix
# NOTE: Fovy angle must be provided in radians
MatrixPerspective â† {ğ•Šfovyâ€¿aspectâ€¿nearâ€¿far:
  top    â† nearÃ—Tan fovyÃ·2
  bottom â† -top
  right  â† topÃ—aspect
  left   â† -right

  # MatrixFrustum(-right, right, -top, top, near, far);
  [
    âŸ¨nearÃ—2 â‹„ 0      â‹„ right+left   â‹„ 0         âŸ©0âŠ¸=âŠ¸+Ã·right-left
    âŸ¨0      â‹„ nearÃ—2 â‹„   top+bottom â‹„ 0         âŸ©0âŠ¸=âŠ¸+Ã·  top-bottom
    âŸ¨0      â‹„ 0      â‹„   far+near   â‹„ farÃ—nearÃ—2âŸ©0âŠ¸=âŠ¸+Ã· near-far
    âŸ¨0      â‹„ 0      â‹„ Â¯1           â‹„ 0         âŸ©
  ]
}

# Get orthographic projection matrix
MatrixOrtho â† {ğ•Šleftâ€¿rightâ€¿bottomâ€¿topâ€¿nearâ€¿far:
  [
    âŸ¨ 2 â‹„ 0 â‹„  0 â‹„ left  +right âŸ©Ã·left  -right
    âŸ¨ 0 â‹„ 2 â‹„  0 â‹„ bottom+top   âŸ©Ã·bottom-top
    âŸ¨ 0 â‹„ 0 â‹„  2 â‹„ near  +far   âŸ©Ã·near  -far
    âŸ¨ 0 â‹„ 0 â‹„  0 â‹„ 1            âŸ©
  ]
}

# Get camera look-at matrix (view matrix)
MatrixLookAt â† {ğ•Šeyeâ€¿targetâ€¿up: # all are Vector3
  Norm â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))
  Cross â† 1âŠ¸âŒ½âŠ¸Ã—{1âŒ½ğ”½Ëœ-ğ”½}
  vz â† Norm eye-target
  vx â† Norm up Cross vz
  vy â† vz Cross vx
  â‰[
    vxâˆ¾+Â´-vxÃ—eye
    vyâˆ¾+Â´-vyÃ—eye
    vzâˆ¾+Â´-vzÃ—eye
    Â¯4â†‘1
  ]
}


#----------------------------------------------------------------------------------
# Quaternion math
#----------------------------------------------------------------------------------

quaternionIdentity â† Â¯4â†‘1

# Invert provided quaternion
QuaternionInvert â† Â¯1â€¿Â¯1â€¿Â¯1â€¿1Ã—Ã·âŸœ(0âŠ¸=âŠ¸++Â´â—‹(Ã—Ëœ))

# Calculate two quaternion multiplication
QuaternionMultiply â† {q2ğ•Šq1: xâ€¿yâ€¿zâ€¿wâ†ğ•©
  ğ•¨ MPËœ [
    âŸ¨ w â‹„ -z â‹„  y â‹„ xâŸ©
    âŸ¨ z â‹„  w â‹„ -x â‹„ yâŸ©
    âŸ¨-y â‹„  x â‹„  w â‹„ zâŸ©
    âŸ¨-x â‹„ -y â‹„ -z â‹„ wâŸ©
  ]
}

# Calculate slerp-optimized interpolation between two quaternions
QuaternionNlerp â† {ğ•Šq1â€¿q2â€¿amount:
  Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))amountâŠ¸Ã—âŒ¾(-âŸœq1)q2
}

# Calculates spherical linear interpolation between two quaternions
QuaternionSlerp â† {ğ•Šq1â€¿q2â€¿amount:
  cosHalfTheta â† +Â´q1Ã—q2
  cosHalfThetaâ€¿q2Ã—â†©-âŸ(cosHalfTheta<0)1

  {
    1 â‰¤ cosHalfTheta? q1
  ;
    0.95 < cosHalfTheta? Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))amountâŠ¸Ã—âŒ¾(-âŸœq1)q2
  ;
    sinHalfTheta â† Sin halfTheta â† Cosâ¼cosHalfTheta
    0.001 â‰¤ sinHalfTheta?
    +Ë[q1â‹„q2]Ã—sinHalfThetaÃ·ËœSin halfThetaÃ—Â¬âŠ¸â‹ˆamount
  ;
    (+ËÃ·â‰ )[q1â‹„q2]
  }
}

# Calculate quaternion based on the rotation from one vector to another
QuaternionFromVector3ToVector â† {toğ•Šfrom:
  cos2Theta â† +ËfromÃ—to
  cross     â† from 1âŠ¸âŒ½âŠ¸Ã—{1âŒ½ğ”½Ëœ-ğ”½}to

  # QuaternionNormalize(q);
  # NOTE: Normalize to essentially nlerp the original and identity to 0.5
  Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))crossâˆ¾1+cos2Theta
}


# Get rotation quaternion for an angle and axis
# NOTE: Angle must be provided in radians
QuaternionFromAxisAngle â† {angleğ•Šaxis:
  Norm â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))
  Norm (Cosâˆ¾Ëœaxis NormâŠ¸Ã—Sin) angleÃ·2
}

# Get the rotation angle and axis for a given quaternion
QuaternionToAxisAngle â† {ğ•Šğ•©:

  # QuaternionNormalize(q);
  xâ€¿yâ€¿zâ€¿w â† q â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))ğ•© # removed âŸ{1<|Â¯1âŠ‘ğ•©}

  angle â† 2Ã—Cosâ¼w

  # when the angle is zero just set an arbitrary normalized axis. (0â€¿0â€¿1)
  axis â† (Sin Cosâ¼w){ğ•¨Ã·Ëœ3â†‘q}âŸ(â‰ âŸœ0)0â€¿0â€¿1

  axisâ€¿angle
}

# Get the quaternion equivalent to Euler angles
# NOTE: Rotation order is ZYX
QuaternionFromEuler â† {pitchâ€¿yawâ€¿roll:
  F â† Ã—Â´Ë˜(Sin Cosâ¼)âŒ¾(0â€¿0â‰âŠ¢)4âŠ¸â¥ŠË˜
  Â¯1â€¿1â€¿Â¯1â€¿1Ã—(Cos Ã—â—‹F Sin) ğ•©Ã·2
}

# Get the Euler angles equivalent to quaternion (roll, pitch, yaw)
# NOTE: Angles are returned in a Vector3 struct in radians
QuaternionToEuler â† {ğ•Šxâ€¿yâ€¿zâ€¿w:
  âŸ¨
    # Roll (x-axis rotation)
    Atan2âŸœÂ¬Â´2Ã—+Â´Â¨âŸ¨yÃ—wâ€¿z â‹„ Ã—Ëœxâ€¿yâŸ©

    # Pitch (y-axis rotation)
    Sinâ¼Â¯1âŒŠ1âŒˆ2Ã—-Â´Ã—Ë2â€¿2â¥Šğ•©

    # Yaw (z-axis rotation)
    Atan2Â´âŸ¨2Ã—+Â´Ã—Â´Â¨2(â†‘â‹ˆâ†“)ğ•© â‹„ Â¬2Ã—+Â´Ã—Ëœyâ€¿zâŸ©
  âŸ©
}

# Check whether two given quaternions are almost equal
QuaternionEquals â† âˆ¨Â´Â·âˆ§Ë(|-â‰Ë˜+)â‰¤epsilonÃ—1âŒˆâŒˆâ—‹|