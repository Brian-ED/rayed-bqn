# GOAL make raylib functions work on arbitrary vectors and matricies
# ALSO after i finish translating everything, i will try making arbitrary matricies
# aswell as switch from raylib's collumn model to leading axis model.
# Also raylib only uses 4x4 matricies, i'm considering limiting this since it pads matricies a lot
# Also considering making Quaternions be realâ€¿iâ€¿jâ€¿k instead of iâ€¿jâ€¿kâ€¿real

# raylib and 3d graphics in general uses 4x4 matricies for rotation and position, but 3x3 are enough for just rotation.


âŸ¨
  MPâ‹„MatrixLookAt
  MatrixScaleâ‹„MatrixRotate
  MatrixRotateXâ‹„MatrixRotateYâ‹„MatrixRotateZ
  MatrixDeterminant
  Inverse
âŸ©â‡

âŸ¨MP, MatrixDeterminantâ‡Determinant, InverseâŸ© â† â€¢Import "imports/bqn-libs/matrix.bqn"

Approx â† (âŒŠ0.5âŠ¸+)âŒ¾(100âŠ¸Ã—)

# Get scaling matrix
MatrixScale â† {ğ•Šxâ€¿yâ€¿z:
  ğ•©âŠ¸Ã—âŒ¾(3â€¿3âŠ¸â†‘)=âŒœËœâ†•4
}

# NOTE: Angle must be provided in radians
MatrixRotateXâ€¿MatrixRotateYâ€¿MatrixRotateZ â† {
  _RotMat â† {cut2x2OfMat On2x2Arr _ğ•£ degrees:
    (ğ”½(â‹ˆâŸœ-Â´â‰âŒ½)(â€¢math.Cosâˆ¾â€¢math.Sin)ğ•©)âŒ¾(ğ•¨âŠ¸âŠË˜ğ•¨âŠ¸âŠ)=âŒœËœâ†•4
  }
  âŸ¨1â€¿2 â‰_RotMat âŠ¢
   0â€¿2 âŠ¢_RotMat âŠ¢
   0â€¿1 â‰_RotMat âŠ¢âŸ©
}

###############################################################################################
#
#   raymath v1.5 - Math functions to work with Vectors, Matricies and Quaternions
#
#   CONVENTIONS:
#     - Matrix structure is defined as row-major (memory layout) but parameters naming AND all
#       math operations performed by the library consider the structure as it was column-major
#       It is like transposed versions of the matrices are used for all the maths
#       It benefits some functions making them cache-friendly and also avoids matrix
#       transpositions sometimes required by OpenGL
#       Example: In memory order, row0 is [m0 m4 m8 m12] but in semantic math row0 is [m0 m1 m2 m3]
#     - Functions are always self-contained, no function use another raymath function inside,
#       required code is directly re-implemented inside
#     - Functions use always a "result" variable for return
#     - Angles are always in radians
#
###############################################################################################

#----------------------------------------------------------------------------------
# removed from raylib
#----------------------------------------------------------------------------------

## Removed QuaternionToMatrix and QuaternionFromMatrix:
# they have been said to be innacurate by ray - maintainer of raylib. 
# Under "module: raymath" at https://github.com/raysan5/raylib/discussions/2952 
## removed Vector3Perpendicular, as it isn't well defined.
## removed Vector3ToFloatV as it's useless in bqn.


# Too simple:
# Clamp â† Vector2Clamp â† maxâŒŠminâŒˆx
#Vector2Add         â† Vector2AddValue â† Vector3Add â† QuaternionAdd â† QuaternionAddValue â† +
#Vector2Multiply    â† Vector2Scale â† QuaternionScale â† Ã—
#Vector2Subtract    â† Vector2SubtractValue â† Vector2Negate â† Vector3Negate â† QuaternionSubtract â† QuaternionSubtractValue â† -
#Vector2Divide      â† Vector2Invert â† Vector3Divide â† Vector3Invert â† QuaternionDivide â† Ã·
#Vector3DistanceSqr â† Vector2DistanceSqr â† Ã—ËœVectorDistance
#MatrixTranspose    â† â‰
#MatrixIdentity     â† =âŒœËœâ†•âˆ˜4
#MatrixInvert       â† matrix.Inverse
#MatrixToFloatV     â† â¥Š
#Vector3Min â† âŒŠ
#Vector3Max â† âŒˆ

# extended
#Vector2Length      â† Vector3Length     â† QuaternionLength â† VectorLength
#Vector2LengthSqr   â† Vector3LengthSqr  â† VectorLengthSqr
#Vector2DotProduct  â† Vector3DotProduct â† VectorDotProduct 
#Vector2Distance    â† Vector3Distance   â† VectorDistance
#Vector2Lerp        â† Vector3Lerp       â† QuaternionLerp â† Lerp
#Vector2Transform   â† Vector3Transform  â† VectorTransform â† (1âˆ¾Ëœ3âŠ¸â†‘)âŠ¸MP
#QuaternionTransform â† MP
#Vector2ClampValue  â† Vector3ClampValue â† VectorClampValue
#Vector2Equals      â† Vector3Equals     â† VectorEquals â† VectorEquals
#Vector2Normalize   â† Vector3Normalize  â† QuaternionNormalize â† VectorNormalize
#Vector2Angle       â† Vector3Angle      â† VectorAngle
#Vector2MoveTowards â† VectorMoveTowards

# MatrixAdd
# 
# Vector3AddValue
# Vector3Subtract
# Vector3SubtractValue
# Vector3Scale
# Vector3Multiply
# Vector3CrossProduct


#----------------------------------------------------------------------------------
# Notes
#----------------------------------------------------------------------------------

# Why 4x4 Matricies?
#   https://stackoverflow.com/questions/29079685/how-does-4x4-matrix-work-in-3d-graphic
#   Matrices define linear transformations between vector spaces.
#   All linear transformations map the origin of the domain to the origin of the range.
#   Therefore 3x3 matrices cannot perform translation on 3D vectors since the origin in one space cannot be mapped to anything but the origin on another using linear maps.
#   To overcome this problem, we can fake the system into performing translations through the use of an extra dimension where all vectors will have a 1 in the last vector component. 
#   These 4D vectors will never be at the origin (having 1 in the last component) and so are not required to always map to the origin.
#   Through the use of this we can construct a 4x4 matrix to perform translation.



#----------------------------------------------------------------------------------
# Defines
#----------------------------------------------------------------------------------

epsilon â† 1eÂ¯6
rad2deg â† Ã·deg2rad â† Ï€Ã·180

âŸ¨Sin, Cos, Tan, Atan2âŸ©â†â€¢math

#----------------------------------------------------------------------------------
# Module Functions Definition - Utils math
#----------------------------------------------------------------------------------

# Calculate linear interpolation between two floats or vectors
Lerp â† {ğ•Šv1â€¿v2â€¿amount:
  amountâŠ¸Ã—âŒ¾(-âŸœv1)v2
}

# Normalize input value within input range
Normalize â† {ğ•Švalueâ€¿startâ€¿end:
  Ã·Â´valueâ€¿end-start
}

# Remap input value within input range to output range
Remap â† {ğ•Švalueâ€¿inputStartâ€¿inputEndâ€¿outputStartâ€¿outputEnd:
  {ğ•©Ã—Ã·Â´valueâ€¿inputEnd-inputStart}âŒ¾(-âŸœoutputEnd) outputStart
}

# Wrap input value from min to max
Wrap â† {ğ•Švalueâ€¿minâ€¿max:
  (value - maxâŠ¸- Ã— valueâŠ¸- âŒŠâˆ˜Ã· maxâŠ¸-) min
}

# Check whether two given vectors are almost equal
FloatEquals â† âˆ§Â´âˆ˜â¥Š|âˆ˜-â‰¤epsilonÃ—1âŒˆâŒˆâ—‹|

#----------------------------------------------------------------------------------
# Module Functions Definition - Vector2 math
#----------------------------------------------------------------------------------

# Calculate vector length
VectorLength â† +Â´âŒ¾(Ã—Ëœ)

# ğ•¨ğ•Šğ•©: Calculate two vectors dot product
#  ğ•Šğ•©: Calculate vector square length
VectorDotProduct â† VectorLengthSqr â† +Â´Ã—Ëœ

# Calculate distance between two vectors
VectorDistance â† +Â´âŒ¾(Ã—Ëœ)-

# Calculate angle between two vectors
# NOTE: Angle is calculated from origin point (0, 0)
VectorAngle â† +Â´âˆ˜Ã—Atan2Â·+Â´âŒ¾(Ã—Ëœ){(Â¯1âŒ½ğ•¨)Ã—1âŒ½ğ•©}{ğ”½Ëœ-ğ”½}

# Calculate angle defined by a two vectors line
# NOTE: Parameters need to be normalized
# Current implementation should be aligned with glm::angle
Vector2LineAngle â† Cosâ¼1âŒˆÂ¯1âŒˆ+Â´âˆ˜Ã— # start ğ•Š end

# Calculate reflected vector to normal
Vector2Reflect â† {normalğ•Šv: # vector vector
  v-2Ã—normalÃ—+Â´vÃ—normal
}

# Rotate vector by angle:  angle ğ•Š vector2
Vector2Rotate â† (Cosâˆ¾Sin)âŠ¸(-Â´âˆ˜Ã—â‹ˆÂ·+Â´âŒ½âŠ¸Ã—)


# Move Vector towards target
VectorMoveTowards â† {targetâ€¿maxDistanceğ•Šv:
  targetâŒŠv+maxDistanceÃ—Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))target-v
}

# Clamp the magnitude of the vector between two min and max values
VectorClampValue â† {ğ•Švâ€¿minâ€¿max:
  (Ã·Ã—maxâŒŠminâŒˆâŠ¢)âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))v
}

#----------------------------------------------------------------------------------
# Module Functions Definition - Vector3 math
#----------------------------------------------------------------------------------

# Normalize provided vector
VectorNormalize â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))

# Orthonormalize provided vectors
# Makes vectors normalized and orthogonal to each other
# Gram-Schmidt function implementation
Vector3OrthoNormalize â† {v1ğ•Šv2:
  # Vector3Normalize v1
  F â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))

  # Vector3CrossProductÂ´v1â€¿v2
  G â† {(Â¯1âŒ½ğ•¨)Ã—1âŒ½ğ•©}{ğ”½Ëœ-ğ”½}
  
  v1 Gâ—‹FËœ v1 FâŠ¸G v2
}

# Transform a vector by quaternion rotation
Vector3RotateByQuaternion â† {qğ•Šv: xâ€¿yâ€¿zâ€¿wâ†q
  MPâŸœv MPâŸœq[
    [
      [ x â‹„ -y â‹„ -z â‹„  w]
      [ y â‹„  x â‹„ -w â‹„ -z]
      [ z â‹„  w â‹„  x â‹„  y]
    ]
    [
      [ y â‹„  x â‹„  w â‹„  z]
      [-x â‹„  y â‹„ -z â‹„  w]
      [-w â‹„  z â‹„  y â‹„ -x]
    ]
    [
      [ z â‹„ -w â‹„  x â‹„ -y]
      [ w â‹„  z â‹„  y â‹„  x]
      [-x â‹„ -y â‹„  z â‹„  w]
    ]
  ]
}

# Rotates a vector around an axis
Vector3RotateByAxisAngle â† {ğ•Švâ€¿axisV3â€¿angle:
  # Using Euler-Rodrigues Formula
  # Ref.: https://en.wikipedia.org/w/index.php?title=Euler%E2%80%93Rodrigues_formula
  
  a â† Cos angleÃ·2
  w â† axisV3 Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))âŠ¸Ã— Sin angleÃ·2
  F â† {(Â¯1âŒ½ğ•¨)Ã—1âŒ½ğ•©}{ğ”½Ëœ-ğ”½}
  wv â† w F v
  v+2Ã—(wâŠ¸F+aâŠ¸Ã—) wv
}

# Calculate reflected vector to normal
VectorReflect â† {normalğ•Šv:
  v - (+Â´vÃ—normal)Ã—2Ã—normal
}

# Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c)
# NOTE: Assumes P is on the plane of the triangle
Vector3Barycenter â† {ğ•Špâ€¿aâ€¿bâ€¿c: # v3â€¿v3â€¿v3â€¿v3â†’v3
  # s0 and s1 are magic values, as in, i have no idea what they mean :)
  s0â€¿s1â€¿denom â† {-Â´Ã—ËâŒ½âŒ¾âŠğ•©}Â¨(<Ë˜â‰ âŒœËœâ†•3)/Â¨<+Â´Ë˜Ã—ËË˜(>â†•3â€¿2)âŠ-âŸœaÂ¨bâ€¿câ€¿p
  (Â¬+Â´)âŠ¸âˆ¾s0â€¿s1Ã·denom
}

# Projects a Vector3 from screen space into object space
# NOTE: We are avoiding calling other raymath functions despite available
Vector3Unproject â† {
  ğ•ŠâŸ¨
    source     # v3
    projection # Matrix
    view       # Matrix
  âŸ©:
  # Create quaternion from source point
  quat â† sourceâˆ¾1

  qtransformed â† quat MP Inverse view MP projection

  # Normalized world points in vectors
  qtransformedÃ·Â¯1âŠ‘qtransformed
}

# Compute the direction of a refracted ray 
Vector3Refract â† {ğ•ŠâŸ¨
    v # v3: normalized direction of the incoming ray
    n # v3: normalized normal vector of the interface of two optical media
    r # f : ratio of the refractive index of the medium from where the ray comes to the refractive index of the medium on the other side of the surface
  âŸ©:
  dot â† +Â´vÃ—n
  d â† Â¬Â¬âŠ¸âˆ§Â´Ã—Ëœdotâ€¿r
  {ğ•Š:(rÃ—v)-nÃ—(âˆšd)+rÃ—dot}âŸ(dâ‰¥0)3â¥Š0
}

#----------------------------------------------------------------------------------
# Module Functions Definition - Matrix math
#----------------------------------------------------------------------------------

# Get the trace of the matrix (sum of the values along the diagonal)
MatrixTrace â† +Â´0â€¿0â‰âŠ¢

# Get translation matrix
MatrixTranslate â† {ğ•Šxâ€¿yâ€¿z:
  [
    1â€¿0â€¿0â€¿x
    0â€¿1â€¿0â€¿y
    0â€¿0â€¿1â€¿z
    0â€¿0â€¿0â€¿1
  ]
}
# Create rotation matrix from axis and angle
# NOTE: Angle should be provided in radians
MatrixRotate â† {ğ•Šaxisâ€¿angle: # v3 f
  v â† Ã—âŒœËœÃ·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ)) axis
  xâ€¿yâ€¿z â† axis
  m â† (vÃ—Â¬Cos angle)+((=âŒœËœâ†•3)âŠ(Sinâˆ¾Cos)angle)Ã—[
    âŸ¨ 1 â‹„-z â‹„ yâŸ©
    âŸ¨ z â‹„ 1 â‹„-xâŸ©
    âŸ¨-y â‹„ x â‹„ 1âŸ©
  ]
  âˆ¾[ m â‹„3â¥Š0
    3â¥Š0â‹„1  ]
}

# Get xyz-rotation matrix
# NOTE: Angle must be provided in radians
MatrixRotateXYZ â† {ğ•Šangle:
  [
    cxâ€¿cyâ€¿cz
    sxâ€¿syâ€¿sz
  ] â† (Cosâ‰Sin) -angle
  [
    âŸ¨ czÃ—cy â‹„ (czÃ—syÃ—sx) - szÃ—cx â‹„ (czÃ—syÃ—cx) + szÃ—sx âŸ©
    âŸ¨ szÃ—cy â‹„ (sxÃ—syÃ—sz) + czÃ—cx â‹„ (cxÃ—syÃ—sz) - czÃ—sx âŸ©
    âŸ¨ -sy   â‹„ cyÃ—sx              â‹„ cyÃ—cxâŸ©
  ]âŒ¾(â‰3â€¿3âŠ¸â†‘)=âŒœËœâ†•4
}

# Get zyx-rotation matrix
# NOTE: Angle must be provided in radians
MatrixRotateZYX â† {ğ•Šangle:
  [
    cxâ€¿cyâ€¿cz
    sxâ€¿syâ€¿sz
  ] â† (Cosâ‰Sin) angle

  [
    âŸ¨
      czÃ—cy
      (czÃ—syÃ—sx) - cxÃ—sz
      (szÃ—sx) + czÃ—cxÃ—sy
    âŸ©
    âŸ¨
      cyÃ—sz
      (czÃ—cx) + szÃ—syÃ—sx
      (cxÃ—szÃ—sy) - czÃ—sx
    âŸ©
    âŸ¨
      -sy
      cyÃ—sx
      cyÃ—cx
    âŸ©
  ]âŒ¾(â‰3â€¿3âŠ¸â†‘)=âŒœËœâ†•4
}

# Get perspective projection matrix
MatrixFrustum â† {ğ•Šleftâ€¿rightâ€¿bottomâ€¿topâ€¿nearâ€¿far:
  [
    âŸ¨nearÃ—2 â‹„ 0      â‹„ right+left   â‹„ 0         âŸ©Ã·0âŠ¸=âŠ¸+right-left
    âŸ¨0      â‹„ nearÃ—2 â‹„   top+bottom â‹„ 0         âŸ©Ã·0âŠ¸=âŠ¸+  top-bottom
    âŸ¨0      â‹„ 0      â‹„   far+near   â‹„ farÃ—nearÃ—2âŸ©Ã·0âŠ¸=âŠ¸+ near-far
    âŸ¨0      â‹„ 0      â‹„ Â¯1           â‹„ 0         âŸ©
  ]
}

# Get perspective projection matrix
# NOTE: Fovy angle must be provided in radians
MatrixPerspective â† {ğ•Šfovyâ€¿aspectâ€¿nearâ€¿far:
  top    â† nearÃ—Tan fovyÃ·2
  bottom â† -top
  right  â† topÃ—aspect
  left   â† -right

  # MatrixFrustum(-right, right, -top, top, near, far);
  [
    âŸ¨nearÃ—2 â‹„ 0      â‹„ right+left   â‹„ 0         âŸ©0âŠ¸=âŠ¸+Ã·right-left
    âŸ¨0      â‹„ nearÃ—2 â‹„   top+bottom â‹„ 0         âŸ©0âŠ¸=âŠ¸+Ã·  top-bottom
    âŸ¨0      â‹„ 0      â‹„   far+near   â‹„ farÃ—nearÃ—2âŸ©0âŠ¸=âŠ¸+Ã· near-far
    âŸ¨0      â‹„ 0      â‹„ Â¯1           â‹„ 0         âŸ©
  ]
}

# Get orthographic projection matrix
MatrixOrtho â† {ğ•Šleftâ€¿rightâ€¿bottomâ€¿topâ€¿nearâ€¿far:
  [
    âŸ¨ 2 â‹„ 0 â‹„  0 â‹„ left  +right âŸ©Ã·left  -right
    âŸ¨ 0 â‹„ 2 â‹„  0 â‹„ bottom+top   âŸ©Ã·bottom-top
    âŸ¨ 0 â‹„ 0 â‹„  2 â‹„ near  +far   âŸ©Ã·near  -far
    âŸ¨ 0 â‹„ 0 â‹„  0 â‹„ 1            âŸ©
  ]
}

# Get camera look-at matrix (view matrix)
MatrixLookAt â† {ğ•Šeyeâ€¿targetâ€¿up: # all are Vector3
  Norm â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))
  Cross â† {(Â¯1âŒ½ğ•¨)Ã—1âŒ½ğ•©}{ğ”½Ëœ-ğ”½}
  vz â† Norm eye-target
  vx â† Norm up Cross vz
  vy â† vz Cross vx
  â‰[
    vxâˆ¾+Â´-vxÃ—eye
    vyâˆ¾+Â´-vyÃ—eye
    vzâˆ¾+Â´-vzÃ—eye
    Â¯4â†‘1
  ]
}


#----------------------------------------------------------------------------------
# Module Functions Definition - Quaternion math
#----------------------------------------------------------------------------------

quaternionIdentity â† Â¯4â†‘1

# Invert provided quaternion
QuaternionInvert â† Â¯1â€¿Â¯1â€¿Â¯1â€¿1Ã—Ã·âŸœ(0âŠ¸=âŠ¸++Â´â—‹(Ã—Ëœ))

# Calculate two quaternion multiplication
QuaternionMultiply â† {q2ğ•Šq1:
  qaxâ€¿qayâ€¿qazâ€¿qaw â† q1
  qbxâ€¿qbyâ€¿qbzâ€¿qbw â† q2
  âŸ¨
    +Â´ âŸ¨ qawÃ—qbx â‹„ -qazÃ—qby â‹„  qayÃ—qbz â‹„ qaxÃ—qbwâŸ©
    +Â´ âŸ¨ qazÃ—qbx â‹„  qawÃ—qby â‹„ -qaxÃ—qbz â‹„ qayÃ—qbwâŸ©
    +Â´ âŸ¨-qayÃ—qbx â‹„  qaxÃ—qby â‹„  qawÃ—qbz â‹„ qazÃ—qbwâŸ©
    +Â´ âŸ¨-qaxÃ—qbx â‹„ -qayÃ—qby â‹„ -qazÃ—qbz â‹„ qawÃ—qbwâŸ©
  âŸ©
}
QuaternionMultiply2 â† {q2ğ•Šq1: xâ€¿yâ€¿zâ€¿wâ†ğ•©
  ğ•¨ MPËœ [
    âŸ¨ w â‹„ -z â‹„  y â‹„ xâŸ©
    âŸ¨ z â‹„  w â‹„ -x â‹„ yâŸ©
    âŸ¨-y â‹„  x â‹„  w â‹„ zâŸ©
    âŸ¨-x â‹„ -y â‹„ -z â‹„ wâŸ©
  ]
}

# Calculate slerp-optimized interpolation between two quaternions
QuaternionNlerp â† {ğ•Šq1â€¿q2â€¿amount:
  Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))amountâŠ¸Ã—âŒ¾(-âŸœq1)q2
}

# Calculates spherical linear interpolation between two quaternions
QuaternionSlerp â† {ğ•Šq1â€¿q2â€¿amount:
  cosHalfTheta â† +Â´q1Ã—q2
  cosHalfThetaâ€¿q2Ã—â†©-âŸ(cosHalfTheta<0)1

  {
    1 â‰¤ cosHalfTheta? q1
  ;
    0.95 < cosHalfTheta? Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))amountâŠ¸Ã—âŒ¾(-âŸœq1)q2
  ;
    sinHalfTheta â† Sin halfTheta â† Cosâ¼cosHalfTheta
    0.001 â‰¤ sinHalfTheta?
    +Ë[q1â‹„q2]Ã—sinHalfThetaÃ·ËœSin halfThetaÃ—Â¬âŠ¸â‹ˆamount
  ;
    (+ËÃ·â‰ )[q1,q2]
  }
}

# Calculate quaternion based on the rotation from one vector to another
QuaternionFromVector3ToVector â† {toğ•Šfrom:
  cos2Theta â† +ËfromÃ—to
  cross     â† from{(Â¯1âŒ½ğ•¨)Ã—1âŒ½ğ•©}{ğ”½Ëœ-ğ”½}to

  # QuaternionNormalize(q);
  # NOTE: Normalize to essentially nlerp the original and identity to 0.5
  Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))crossâˆ¾1+cos2Theta
}


# Get rotation quaternion for an angle and axis
# NOTE: Angle must be provided in radians
QuaternionFromAxisAngle â† {angleğ•Šaxis:
  Norm â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))
  Norm (Cosâˆ¾Ëœaxis NormâŠ¸Ã—Sin) angleÃ·2
}

# Get the rotation angle and axis for a given quaternion
QuaternionToAxisAngle â† {ğ•Šğ•©:
  # QuaternionNormalize(q);

  xâ€¿yâ€¿zâ€¿w â† q â† Ã·âŸœ(0âŠ¸=âŠ¸++Â´âŒ¾(Ã—Ëœ))ğ•© # removed âŸ{1<|Â¯1âŠ‘ğ•©}

  angle â† 2Ã—Cosâ¼w

  # when the angle is zero just set an arbitrary normalized axis. (0â€¿0â€¿1)
  axis â† (Sin Cosâ¼w){ğ•¨Ã·Ëœ3â†‘q}âŸ(â‰ âŸœ0)0â€¿0â€¿1

  axisâ€¿angle
}

# Get the quaternion equivalent to Euler angles
# NOTE: Rotation order is ZYX
QuaternionFromEuler â† {pitchâ€¿yawâ€¿roll:
  F â† Ã—Â´Ë˜(Sin Cosâ¼)âŒ¾(0â€¿0â‰âŠ¢)4âŠ¸â¥ŠË˜
  Â¯1â€¿1â€¿Â¯1â€¿1Ã—(Cos Ã—â—‹F Sin) ğ•©Ã·2
}

# Get the Euler angles equivalent to quaternion (roll, pitch, yaw)
# NOTE: Angles are returned in a Vector3 struct in radians
QuaternionToEuler â† {ğ•Šxâ€¿yâ€¿zâ€¿w:
  âŸ¨
    # Roll (x-axis rotation)
    Atan2âŸœÂ¬Â´2Ã—+Â´Â¨âŸ¨yÃ—wâ€¿z â‹„ Ã—Ëœxâ€¿yâŸ©

    # Pitch (y-axis rotation)
    Sinâ¼Â¯1âŒŠ1âŒˆ2Ã—-Â´Ã—Ë2â€¿2â¥Šğ•©

    # Yaw (z-axis rotation)
    Atan2Â´âŸ¨2Ã—+Â´Ã—Â´Â¨2(â†‘â‹ˆâ†“)ğ•© â‹„ 1-2Ã—+Â´Ã—Ëœyâ€¿zâŸ©
  âŸ©
}

# Check whether two given quaternions are almost equal
QuaternionEquals â† âˆ¨Â´Â·âˆ§Ë(|-â‰Ë˜+)â‰¤epsilonÃ—1âŒˆâŒˆâ—‹|