## Conventions:
# if position is an argument, it's always ğ•©.
# if color is an argument, it's always ğ•—.
# if function has no intended output, output ğ•©, it makes chaining look nicer.

âŸ¨draw, image, texture, monitor, window, mouse
 font, color, key, # obj (removed obj temporarily for push, because i don't like the current version of it)
 _bitwise, rayffiâŸ©â‡  

rayFFI â‡ â€¢Import "rayffi.bqn"

IsInt â† {ğ•©âŠ£(âŒˆâŸœ=ğ•©)!Ëœ" has to be int"âˆ¾Ëœğ•¨âŠ£"ğ•©"}

_bitwise â‡ {
  _into â† {ğ•—_ğ•£â¼ğ•©: ğ•—âŠ¸Ã—âŠ¸+ËœÂ´ğ•©; ğ•—|âŒŠâˆ˜Ã·âŸœğ•—âŸ(â†•1+Â·âŒŠğ•—â‹†â¼1âŒˆâŠ¢)ğ•©}
  ğ•—{_ğ•£:(ğ”½Â´âŒˆâ—‹â‰ â†‘Â¨â‹ˆ)âŒ¾(2 _into)}
}
NeedsWindow â† {ğ•Š:ğ•©âŠ£"Expected window to be open"!window.isOpen}

image â† {
  # TODO: remember to check if file exists before running.
  Load   â‡ {ğ•ŠstrPath   : NeedsWindow@ â‹„ âŠ‘rayFFI.LoadImageğ•©âˆ¾@} # âŠ‘ is used because LoadImage outputs imageâ€¿strPath for unknown reasons.
  Unload â‡ {ğ•Šimage     : NeedsWindow@ â‹„ @âŠ£rayFFI.UnloadImageğ•©}
  _with  â‡ {ğ”½_ğ•£ strPath: NeedsWindow@ â‹„ Unload ğ”½ Loadğ•©}
}
texture â† {
  # TODO: remember to check if file exists before running.
  Load   â‡ {ğ•ŠstrPath: NeedsWindow@ â‹„   rayFFI.LoadTextureğ•©âˆ¾@} # Load texture from file into GPU memory (VRAM)
  Unload â‡ {ğ•Štexture: NeedsWindow@ â‹„ @âŠ£rayFFI.UnloadImageğ•©}
  _with  â‡ {ğ”½_ğ•£ strPath: NeedsWindow@ â‹„râ†ğ”½Ëœxâ†Loadğ•©â‹„ Unload x â‹„ r}
}
mouse â† {
  GetPos     â‡rayFFI.GetMousePositionâŸ¨âŸ©âŠ£NeedsWindow
  WheelMoved â‡rayFFI.GetMouseWheelMoveâŸ¨âŸ©âŠ£NeedsWindow
}
monitor â† {
  âŸ¨Selected â‹„ Count â‹„ RefreshRate â‹„ Size
   Sizemm â‹„ NameâŸ©â‡
  Selected    â† rayFFI.GetCurrentMonitorâˆ˜âŸ¨âŸ©
  Count       â† rayFFI.GetMonitorCountâˆ˜âŸ¨âŸ©
  RefreshRate â† rayFFI.GetMonitorRefreshRate
  Size        â† (rayFFI.GetMonitorWidth âˆ¾ rayFFI.GetMonitorHeight)
  Sizemm      â† (rayFFI.GetMonitorPhysicalWidth âˆ¾ rayFFI.GetMonitorPhysicalHeight)
  Name        â† rayFFI.GetMonitorName
  
  âŸ¨RefreshRate, Size, Sizemm, NameâŸ©{ğ•@âŠ¸â‰¢â—¶Selectedâ€¿{
      ğ•©âŠ£(âŠ‘ğ•©âˆŠâ†•Count@)!Ëœ"Invalid monitor ğ•©, can only be @ for currently selected monitor or a monitor number; ( ğ•©âˆŠâ†•monitor.Count@ ) v ( ğ•©â‰¡@ )"
    }}Â¨â†©
  âŸ¨Selected â‹„ Count â‹„ RefreshRate â‹„ Size
   Sizemm â‹„ NameâŸ© {ğ•âŠ£NeedsWindow}Â¨â†©
}

window â† {
  âŸ¨_openAs â‹„ SetIcon â‹„ fps â‹„ GetSize
   ShouldClose â‹„ isOpen â‹„ Open â‹„ CloseâŸ©â‡
  isOpen â† 0
  fpsâ‡{
    Get â‡ rayFFI.GetFPSâˆ˜âŸ¨âŸ©NeedsWindow
    Set â‡ {
      NeedsWindow@
      (ğ•©=âŒˆ0âŒˆğ•©)!Ëœ"FPS has to be a positive int"
      ğ•©âŠ£rayFFI.SetTargetFPSğ•©
    }
  }
  Open â† {ğ•¨ğ•Š title: scaleâ†ğ•¨âŠ£1
    (Â¬isOpen)!Ëœ"The window cannot be opened twice"
    (scaleâ‰¡0âŒˆ1âŒŠscale)!Ëœ"Scale can only be between 0 and 1"
    ((âŸ¨âŸ©âŠ¸â‰¡âˆ¨âŸ¨2âŸ©âŠ¸â‰¡)â‰¢scale)!Ëœ"Scale can be a scaler (âŸ¨âŸ©â‰¢â‰¢ğ•¨) or length two list (âŸ¨2âŸ©â‰¡â‰¢ğ•¨)"
    rayFFI.InitWindow 0â€¿0âˆ¾<ğ•©âˆ¾@
    isOpenâ†©1
    rayFFI.SetWindowPosition 0â€¿42 # 42 here is the window header size (might be windows only)
    rayFFI.SetWindowSize monitor.Sizeâˆ˜@âŠ¸Ã— scale
    fps.Set monitor.RefreshRate@
    ğ•©âŠ£rayFFI.SetWindowState 4
  }
  GetSize â†{ğ•¤
    NeedsWindow@
    âŸ¨rayFFI.GetScreenWidthâŸ¨âŸ©
     rayFFI.GetScreenHeightâŸ¨âŸ©âŸ©
  }
  ShouldClose â† 0â‰ rayFFI.WindowShouldCloseâˆ˜âŸ¨âŸ©âˆ˜NeedsWindow
  Close â† {
    NeedsWindow@
    rayFFI.CloseWindowâŸ¨âŸ©
    ğ•©âŠ£isOpenâ†©0
  }
  _openAs â† {ğ•¨ App _ğ•£ title: scaleâ†ğ•¨âŠ£1
    scale(CloseâŠ¢ğ”½âŠ£Open)ğ•©
  }
  # TODO: Needs to test input for image
  SetIcon â† {ğ•Šimage: NeedsWindow@ â‹„ rayFFI.SetWindowIconğ•©}
  
  # NOTE: Every bit registers one state (use it with bit masks)
  # By default all flags are set to 0
  configFlags â‡{âŸ¨
    fullscreen       # Set to run program in fullscreen
    resizable        # Set to allow resizable window
    undecorated      # Set to disable window decoration (frame and buttons)
    transparent      # Set to allow transparent framebuffer
    msaa_4x          # Set to try enabling MSAA 4X
    vSYNC            # Set to try enabling V-Sync on GPU
    hidden           # Set to hide window
    alwaysRun        # Set to allow windows running while minimized
    minimized        # Set to minimize window (iconify)
    maximized        # Set to maximize window (expanded to monitor)
    unfocused        # Set to window non focused
    awaysOnTop       # Set to window always on top
    highDPI          # Set to support HighDPI
    mousePassthrough # Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
    interlaced       # Set to try enabling interlaced video format (for V3D)
  âŸ©â‡2â‹†1âŠ¸+âŒ¾(âŠ‘âŒ½)1+â†•15}
}

draw â† {
  âŸ¨Start     â‹„ End        â‹„ _withCanvas_
   _Circle   â‹„ _Rectangle â‹„ _Text_   â‹„ _Line
  Background â‹„ _Texture_  â‹„ _Ellipse â‹„ _EllipseOutline
  âŸ©â‡
  Background â† {ğ•Šrâ€¿gâ€¿bâ€¿a:
    NeedsWindow@
    (âˆ§Â´ğ•©âˆŠâ†•256)!Ëœ"ClearBackground only accepts ints in the range 0-255 inclusive"
    rayFFI.ClearBackground ğ•©
  }
  Start â† âŠ¢âŠ£rayFFI.BeginDrawingâˆ˜âŸ¨âŸ©âˆ˜NeedsWindow
  End   â† âŠ¢âŠ£rayFFI.EndDrawing  âˆ˜âŸ¨âŸ©âˆ˜NeedsWindow
  _withCanvas_ â† {ğ•¨Func _ğ•£_ Func_Returning_A_Colorğ•©:
    Start@
    Background ğ•¨ğ”¾ğ•©
    âŠ£âŸœEndğ•¨ğ”½ğ•©
  }
  _Circle â† {radius âŸ¨r,g,b,aâŸ©_ğ•£ posXâ€¿posY :
    NeedsWindow@
    "Circle only accepts ints as args"!âˆ§Â´âŒŠâŠ¸=nâ†ğ•©âˆ¾ğ•¨âˆ¾ğ•—
    "Incorrect amount of arguments"!7=â‰ n
    rayFFI.DrawCircle âŒŠğ•©âˆ¾ğ•¨â€¿ğ•—
  }
  _Rectangle â† {widthâ€¿height âŸ¨r,g,b,aâŸ©_ğ•£ posXâ€¿posY :
    NeedsWindow@
    "Rectangle only accepts ints as args"!âˆ§Â´âŒˆâŠ¸=ğ•©âˆ¾ğ•¨âˆ¾ğ•—
    rayFFI.DrawRectangleâŒŠ(ğ•©âˆ¾ğ•¨)âˆ¾<ğ•—
  }
  _Text_ â† {text âŸ¨r,g,b,aâŸ©_ğ•£_ fontSize âŸ¨posX,posYâŸ©:
    NeedsWindow@
    rayFFI.DrawText (ğ•¨âˆ¾@)<âŠ¸âˆ¾âŒŠğ•©âˆ¾ğ•˜â€¿ğ•—
  }
  _Line â† { #TODO add asserts
    âŸ¨r,g,b,aâŸ©_ğ•£ startPosâ€¿endPos:
      NeedsWindow@
      rayFFI.DrawLine (âˆ¾ğ•©)âˆ¾<ğ•—;
    thickness âŸ¨r,g,b,aâŸ© _ğ•£ startPosâ€¿endPos:
      NeedsWindow@
      rayFFI.DrawLineEx ğ•©âˆ¾ğ•¨âˆ¾<ğ•—
  }
  _Texture_ â† {scaleâ€¿rotation color _ğ•£_ texture pos:
    NeedsWindow@
    rayFFI.DrawTextureExâŸ¨texture,pos,rotation,scale,colorâŸ©
  }
  _Ellipse â† {widthâ€¿height âŸ¨r,g,b,aâŸ©_ğ•£ posXâ€¿posY :
    NeedsWindow@
    "Ellipse only accepts ints as args"!âˆ§Â´âŒˆâŠ¸=ğ•©âˆ¾ğ•—
    rayffi.DrawEllipse (ğ•©âˆ¾ğ•¨)âˆ¾<ğ•—
  }
  _EllipseOutline â† {widthâ€¿height âŸ¨r,g,b,aâŸ©_ğ•£ posXâ€¿posY :
    NeedsWindow@
    "EllipseOutline only accepts ints as args"!âˆ§Â´âŒˆâŠ¸=ğ•©âˆ¾ğ•—
    rayffi.DrawEllipseLines (ğ•©âˆ¾ğ•¨)âˆ¾<ğ•—
  }
}

font â† { # TODO: This is untested, please test this later
  Load â‡ rayFFI.LoadFontExâˆ˜{
    ğ•ŠfontFilePath:
      âŸ¨ğ•©âˆ¾@, 40, â‰@, 0âŸ©; # fontSize fontChars glyphCount # use NULL for fontChars and 0 for glyphCount to load the default character set
    charactersYouCanUse ğ•Š fontFilePath:
      âŸ¨ğ•©âˆ¾@, 40, ğ•¨-@, â‰ ğ•¨âŸ©
  }NeedsWindow
  LoadBQN â‡ {ğ•ŠfontSize: # Sorce of font and chars: https://dzaima.github.io/BQN386/
    chars â† "â•ââˆ†â™ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_^âŒ¹â³â´!%*+,-<=>?|~âŠ¢âŠ£âŒ·â‰¤â‰¥â‰ âˆ¨âˆ§Ã·Ã—âˆŠâ†‘â†“â—‹âŒˆâŒŠâŠ‚âŠƒâˆ©âˆªâŠ¥âŠ¤â±â²â’â‹â‰âŒ½âŠ–âŸâ•ââªâ‰¡â‰¢â·â¸âŠ†âŠ‡â§â®âˆšÏ¼â€¦Â¨â¨âŒ¸ââ©á‘ˆáµâŒ¶/\&.@âˆ˜âŒºâ«â£â¢â¤â›â¡â¥â 0123456789Â¯âˆâ¬#âºâµâ¶â¹âˆ‡{}:â‹„â†â†’+-Ã—Ã·â‹†âˆšâŒŠâŒˆâˆ§âˆ¨Â¬|=â‰ â‰¤<>â‰¥â‰¡â‰¢âŠ£âŠ¢â¥Šâˆ¾â‰â‹ˆâ†‘â†“â†•âŒ½â‰/â‹â’âŠâŠ‘âŠâŠ’âˆŠâ·âŠ”`ËœË˜Â¨â¼âŒœÂ´ËË™âˆ˜âŠ¸âŸœâ—‹âŒ¾â‰âš‡âŸâŠ˜â—¶âŠÏ€â€¿âˆâ€¿@â†©â†â‡â†’,â‹„ğ•¨ğ•©ğ”½ğ”¾ğ•ğ•ğ•—ğ•˜ğ•Šğ•¤â„ğ•£â¦ƒâ¦„âŸ¨âŸ©"
    rayFFI.LoadFontEx âŸ¨"BQN386.ttf"âˆ¾@, ğ•©, chars-@, â‰ charsâŸ©
  }NeedsWindow
}

color â† {
  hex â‡ {
    From â‡ 16âŠ¸Ã—âŠ¸+ËœÂ´âˆ˜âŒ½Ë˜Â·(âˆ¾"0A"+âŸœâ†•Â¨10â€¿6)âŠ¸âŠË˜âˆ˜â€¿2â¥ŠâŠ¢
  }
  exactâ‡{
    whiteâ‡4â¥Š255 â‹„ blackâ‡Â¯4â†‘255
    [red â€¿green  â€¿blue
     cyanâ€¿magentaâ€¿yellow]â‡255Ã—1âˆ¾ËœÂ¨â‰(-â†•3)âŒ½âŒœâ‹ˆâŸœÂ¬3â†‘1
  
  }
  lightgreen â‡ 144â€¿238â€¿144â€¿255
  darkgreen  â‡ 0â€¿100â€¿0â€¿255
  lightred   â‡ 255â€¿102â€¿102â€¿255
  darkred    â‡ 139â€¿0â€¿0â€¿255
  lightblue  â‡ 173â€¿216â€¿230â€¿255
  darkblue   â‡ 0â€¿0â€¿139â€¿255
  orange     â‡ 255â€¿165â€¿0â€¿255
  brown      â‡ 165â€¿42â€¿42â€¿255
  green      â‡ 0â€¿255â€¿0â€¿255
  white      â‡ 4â¥Š255
  black      â‡ Â¯4â†‘255
  red        â‡ 230â€¿41â€¿55â€¿255
  yellow     â‡ 255â€¿255â€¿0â€¿255
  cyan       â‡ 0â€¿255â€¿255â€¿255
  magenta    â‡ 255â€¿0â€¿255â€¿255
  pink       â‡ 255â€¿192â€¿203â€¿255
  purple     â‡ 128â€¿0â€¿128â€¿255
  teal       â‡ 0â€¿128â€¿128â€¿255
  navy       â‡ 0â€¿0â€¿128â€¿255
  lavender   â‡ 230â€¿230â€¿250â€¿255
  gold       â‡ 255â€¿215â€¿0â€¿255
  silver     â‡ 192â€¿192â€¿192â€¿255
  blue       â‡ 0â€¿121â€¿241â€¿255
  skyBlue    â‡ 102â€¿191â€¿255â€¿255
  gray       â‡ 128â€¿128â€¿128â€¿255
  lightGray  â‡ 200â€¿200â€¿200â€¿255
  darkGray   â‡ 70â€¿78â€¿81â€¿255
}
key â† {
  âŸ¨IsPressed, GetPressedâŸ©â‡
  IsPressed â† {ğ•Š key:
    NeedsWindow@
    0â‰ rayFFI.IsKeyPressed @-ËœâŸ>ğ•©
  }âš‡0
  GetPressed â† {ğ•¤  # Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
    NeedsWindow@
    rayFFI.GetKeyPressedâŸ¨âŸ©
  }
  # consider switching to `letter-@` when possible.

  # vars           Keycodes   Keys
  kNULL           â‡ 0        # NULL, used for no key pressed
  # Alphanumeric keys
  kAPOSTROPHE    â‡ 39       # '
  kCOMMA         â‡ 44       # ,
  kMINUS         â‡ 45       # -
  kPERIOD        â‡ 46       # .
  kSLASH         â‡ 47       # /
  kZERO          â‡ 48       # 0
  kONE           â‡ 49       # 1
  kTWO           â‡ 50       # 2
  kTHREE         â‡ 51       # 3
  kFOUR          â‡ 52       # 4
  kFIVE          â‡ 53       # 5
  kSIX           â‡ 54       # 6
  kSEVEN         â‡ 55       # 7
  kEIGHT         â‡ 56       # 8
  kNINE          â‡ 57       # 9
  kSEMICOLON     â‡ 59       # ;
  kEQUAL         â‡ 61       # =
  kA             â‡ 65       # A | a
  kB             â‡ 66       # B | b
  kC             â‡ 67       # C | c
  kD             â‡ 68       # D | d
  kE             â‡ 69       # E | e
  kF             â‡ 70       # F | f
  kG             â‡ 71       # G | g
  kH             â‡ 72       # H | h
  kI             â‡ 73       # I | i
  kJ             â‡ 74       # J | j
  kK             â‡ 75       # K | k
  kL             â‡ 76       # L | l
  kM             â‡ 77       # M | m
  kN             â‡ 78       # N | n
  kO             â‡ 79       # O | o
  kP             â‡ 80       # P | p
  kQ             â‡ 81       # Q | q
  kR             â‡ 82       # R | r
  kS             â‡ 83       # S | s
  kT             â‡ 84       # T | t
  kU             â‡ 85       # U | u
  kV             â‡ 86       # V | v
  kW             â‡ 87       # W | w
  kX             â‡ 88       # X | x
  kY             â‡ 89       # Y | y
  kZ             â‡ 90       # Z | z
  kLEFT_BRACKET  â‡ 91       # [
  kBACKSLASH     â‡ 92       # '\'
  kRIGHT_BRACKET â‡ 93       # ]
  kGRAVE         â‡ 96       # `
  # Function keys
  kSPACE         â‡ 32       # Space
  kESCAPE        â‡ 256      # Esc
  kENTER         â‡ 257      # Enter
  kTAB           â‡ 258      # Tab
  kBACKSPACE     â‡ 259      # Backspace
  kINSERT        â‡ 260      # Ins
  kDELETE        â‡ 261      # Del
  kRIGHT         â‡ 262      # Cursor right
  kLEFT          â‡ 263      # Cursor left
  kDOWN          â‡ 264      # Cursor down
  kUP            â‡ 265      # Cursor up
  kPAGE_UP       â‡ 266      # Page up
  kPAGE_DOWN     â‡ 267      # Page down
  kHOME          â‡ 268      # Home
  kEND           â‡ 269      # End
  kCAPS_LOCK     â‡ 280      # Caps lock
  kSCROLL_LOCK   â‡ 281      # Scroll down
  kNUM_LOCK      â‡ 282      # Num lock
  kPRINT_SCREEN  â‡ 283      # Print screen
  kPAUSE         â‡ 284      # Pause
  kF1            â‡ 290      # F1
  kF2            â‡ 291      # F2
  kF3            â‡ 292      # F3
  kF4            â‡ 293      # F4
  kF5            â‡ 294      # F5
  kF6            â‡ 295      # F6
  kF7            â‡ 296      # F7
  kF8            â‡ 297      # F8
  kF9            â‡ 298      # F9
  kF10           â‡ 299      # F10
  kF11           â‡ 300      # F11
  kF12           â‡ 301      # F12
  kLEFT_SHIFT    â‡ 340      # Shift left
  kLEFT_CONTROL  â‡ 341      # Control left
  kLEFT_ALT      â‡ 342      # Alt left
  kLEFT_SUPER    â‡ 343      # Super left
  kRIGHT_SHIFT   â‡ 344      # Shift right
  kRIGHT_CONTROL â‡ 345      # Control right
  kRIGHT_ALT     â‡ 346      # Alt right
  kRIGHT_SUPER   â‡ 347      # Super right
  kKB_MENU       â‡ 348      # KB menu
  # Keypad keys
  kKP_0          â‡ 320      # Keypad 0
  kKP_1          â‡ 321      # Keypad 1
  kKP_2          â‡ 322      # Keypad 2
  kKP_3          â‡ 323      # Keypad 3
  kKP_4          â‡ 324      # Keypad 4
  kKP_5          â‡ 325      # Keypad 5
  kKP_6          â‡ 326      # Keypad 6
  kKP_7          â‡ 327      # Keypad 7
  kKP_8          â‡ 328      # Keypad 8
  kKP_9          â‡ 329      # Keypad 9
  kKP_DECIMAL    â‡ 330      # Keypad .
  kKP_DIVIDE     â‡ 331      # Keypad /
  kKP_MULTIPLY   â‡ 332      # Keypad *
  kKP_SUBTRACT   â‡ 333      # Keypad -
  kKP_ADD        â‡ 334      # Keypad +
  kKP_ENTER      â‡ 335      # Keypad Enter
  kKP_EQUAL      â‡ 336      # Keypad =
  kBACK          â‡ 4        # Android back button
  kMENU          â‡ 82       # Android menu button
  kVOLUME_UP     â‡ 24       # Android volume up button
  kVOLUME_DOWN   â‡ 25       # Android volume down button
}

drawCopy â† draw